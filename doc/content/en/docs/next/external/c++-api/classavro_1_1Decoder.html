<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Avro C++: avro::Decoder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceavro.html">avro</a></li><li class="navelem"><a class="el" href="classavro_1_1Decoder.html">Decoder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classavro_1_1Decoder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">avro::Decoder Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> is an interface implemented by every decoder capable of decoding Avro data.  
 <a href="classavro_1_1Decoder.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Decoder_8hh_source.html">Decoder.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for avro::Decoder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classavro_1_1Decoder.png" usemap="#avro::Decoder_map" alt=""/>
  <map id="avro::Decoder_map" name="avro::Decoder_map">
<area href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of..." alt="avro::ResolvingDecoder" shape="rect" coords="0,56,148,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a2306d75ec6a6ef84215c5781267eaf"><td class="memItemLeft" align="right" valign="top"><a id="a4a2306d75ec6a6ef84215c5781267eaf"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a4a2306d75ec6a6ef84215c5781267eaf">init</a> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;is)=0</td></tr>
<tr class="memdesc:a4a2306d75ec6a6ef84215c5781267eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">All future decoding will come from is, which should be valid until replaced by another call to <a class="el" href="classavro_1_1Decoder.html#a4a2306d75ec6a6ef84215c5781267eaf" title="All future decoding will come from is, which should be valid until replaced by another call to init()...">init()</a> or this <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> is destructed. <br /></td></tr>
<tr class="separator:a4a2306d75ec6a6ef84215c5781267eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4d3b59b0840b8cddae07a50d9757a8"><td class="memItemLeft" align="right" valign="top"><a id="a2d4d3b59b0840b8cddae07a50d9757a8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a2d4d3b59b0840b8cddae07a50d9757a8">decodeNull</a> ()=0</td></tr>
<tr class="memdesc:a2d4d3b59b0840b8cddae07a50d9757a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a null from the current stream. <br /></td></tr>
<tr class="separator:a2d4d3b59b0840b8cddae07a50d9757a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb5d57e25e6558f1efec83a1796788c"><td class="memItemLeft" align="right" valign="top"><a id="a6fb5d57e25e6558f1efec83a1796788c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a6fb5d57e25e6558f1efec83a1796788c">decodeBool</a> ()=0</td></tr>
<tr class="memdesc:a6fb5d57e25e6558f1efec83a1796788c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a bool from the current stream. <br /></td></tr>
<tr class="separator:a6fb5d57e25e6558f1efec83a1796788c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40caf8fe0ae133f2e19542db5cf30109"><td class="memItemLeft" align="right" valign="top"><a id="a40caf8fe0ae133f2e19542db5cf30109"></a>
virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a40caf8fe0ae133f2e19542db5cf30109">decodeInt</a> ()=0</td></tr>
<tr class="memdesc:a40caf8fe0ae133f2e19542db5cf30109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a 32-bit int from the current stream. <br /></td></tr>
<tr class="separator:a40caf8fe0ae133f2e19542db5cf30109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb879546d0c95c0b31bd644eb934973"><td class="memItemLeft" align="right" valign="top"><a id="a8bb879546d0c95c0b31bd644eb934973"></a>
virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a8bb879546d0c95c0b31bd644eb934973">decodeLong</a> ()=0</td></tr>
<tr class="memdesc:a8bb879546d0c95c0b31bd644eb934973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a 64-bit signed int from the current stream. <br /></td></tr>
<tr class="separator:a8bb879546d0c95c0b31bd644eb934973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704768e7ff55ea8736b54737a52bac4c"><td class="memItemLeft" align="right" valign="top"><a id="a704768e7ff55ea8736b54737a52bac4c"></a>
virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a704768e7ff55ea8736b54737a52bac4c">decodeFloat</a> ()=0</td></tr>
<tr class="memdesc:a704768e7ff55ea8736b54737a52bac4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a single-precision floating point number from current stream. <br /></td></tr>
<tr class="separator:a704768e7ff55ea8736b54737a52bac4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd007718928920fd65b643fefb6e9ab"><td class="memItemLeft" align="right" valign="top"><a id="acdd007718928920fd65b643fefb6e9ab"></a>
virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#acdd007718928920fd65b643fefb6e9ab">decodeDouble</a> ()=0</td></tr>
<tr class="memdesc:acdd007718928920fd65b643fefb6e9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a double-precision floating point number from current stream. <br /></td></tr>
<tr class="separator:acdd007718928920fd65b643fefb6e9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf991b9e4d42bc0d6e992435192714ad"><td class="memItemLeft" align="right" valign="top"><a id="adf991b9e4d42bc0d6e992435192714ad"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#adf991b9e4d42bc0d6e992435192714ad">decodeString</a> ()</td></tr>
<tr class="memdesc:adf991b9e4d42bc0d6e992435192714ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a UTF-8 string from the current stream. <br /></td></tr>
<tr class="separator:adf991b9e4d42bc0d6e992435192714ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8066eb634df77f083d36b1d88980153"><td class="memItemLeft" align="right" valign="top"><a id="aa8066eb634df77f083d36b1d88980153"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#aa8066eb634df77f083d36b1d88980153">decodeString</a> (std::string &amp;value)=0</td></tr>
<tr class="memdesc:aa8066eb634df77f083d36b1d88980153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a UTF-8 string from the stream and assigns it to value. <br /></td></tr>
<tr class="separator:aa8066eb634df77f083d36b1d88980153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b150983caf510f12855cd124a38e5c"><td class="memItemLeft" align="right" valign="top"><a id="ab8b150983caf510f12855cd124a38e5c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#ab8b150983caf510f12855cd124a38e5c">skipString</a> ()=0</td></tr>
<tr class="memdesc:ab8b150983caf510f12855cd124a38e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips a string on the current stream. <br /></td></tr>
<tr class="separator:ab8b150983caf510f12855cd124a38e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50882d78ce6fe028ff03206b60231d63"><td class="memItemLeft" align="right" valign="top"><a id="a50882d78ce6fe028ff03206b60231d63"></a>
std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a50882d78ce6fe028ff03206b60231d63">decodeBytes</a> ()</td></tr>
<tr class="memdesc:a50882d78ce6fe028ff03206b60231d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes arbitrary binary data from the current stream. <br /></td></tr>
<tr class="separator:a50882d78ce6fe028ff03206b60231d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c603f5008ec8d1756f30e6ab5acab"><td class="memItemLeft" align="right" valign="top"><a id="a778c603f5008ec8d1756f30e6ab5acab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a778c603f5008ec8d1756f30e6ab5acab">decodeBytes</a> (std::vector&lt; uint8_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a778c603f5008ec8d1756f30e6ab5acab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes arbitrary binary data from the current stream and puts it in value. <br /></td></tr>
<tr class="separator:a778c603f5008ec8d1756f30e6ab5acab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bafd4865694ded2060ef579241f0686"><td class="memItemLeft" align="right" valign="top"><a id="a4bafd4865694ded2060ef579241f0686"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a4bafd4865694ded2060ef579241f0686">skipBytes</a> ()=0</td></tr>
<tr class="memdesc:a4bafd4865694ded2060ef579241f0686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips bytes on the current stream. <br /></td></tr>
<tr class="separator:a4bafd4865694ded2060ef579241f0686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff413217a31b08e9f66e361b2a18b6e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#abff413217a31b08e9f66e361b2a18b6e">decodeFixed</a> (size_t n)</td></tr>
<tr class="memdesc:abff413217a31b08e9f66e361b2a18b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes fixed length binary from the current stream.  <a href="classavro_1_1Decoder.html#abff413217a31b08e9f66e361b2a18b6e">More...</a><br /></td></tr>
<tr class="separator:abff413217a31b08e9f66e361b2a18b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156efba788d2aa51d17a57edf7793632"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a156efba788d2aa51d17a57edf7793632">decodeFixed</a> (size_t n, std::vector&lt; uint8_t &gt; &amp;value)=0</td></tr>
<tr class="memdesc:a156efba788d2aa51d17a57edf7793632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a fixed from the current stream.  <a href="classavro_1_1Decoder.html#a156efba788d2aa51d17a57edf7793632">More...</a><br /></td></tr>
<tr class="separator:a156efba788d2aa51d17a57edf7793632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11670ef98740c8d639ebdfb3790f28be"><td class="memItemLeft" align="right" valign="top"><a id="a11670ef98740c8d639ebdfb3790f28be"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a11670ef98740c8d639ebdfb3790f28be">skipFixed</a> (size_t n)=0</td></tr>
<tr class="memdesc:a11670ef98740c8d639ebdfb3790f28be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips fixed length binary on the current stream. <br /></td></tr>
<tr class="separator:a11670ef98740c8d639ebdfb3790f28be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833593bf32b78174bfc6e319ad518847"><td class="memItemLeft" align="right" valign="top"><a id="a833593bf32b78174bfc6e319ad518847"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a833593bf32b78174bfc6e319ad518847">decodeEnum</a> ()=0</td></tr>
<tr class="memdesc:a833593bf32b78174bfc6e319ad518847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes enum from the current stream. <br /></td></tr>
<tr class="separator:a833593bf32b78174bfc6e319ad518847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901142577da580531e1ebac610e5b49"><td class="memItemLeft" align="right" valign="top"><a id="a6901142577da580531e1ebac610e5b49"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a6901142577da580531e1ebac610e5b49">arrayStart</a> ()=0</td></tr>
<tr class="memdesc:a6901142577da580531e1ebac610e5b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start decoding an array. Returns the number of entries in first chunk. <br /></td></tr>
<tr class="separator:a6901142577da580531e1ebac610e5b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4629a6b123b1eed417879b3092ce0a82"><td class="memItemLeft" align="right" valign="top"><a id="a4629a6b123b1eed417879b3092ce0a82"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a4629a6b123b1eed417879b3092ce0a82">arrayNext</a> ()=0</td></tr>
<tr class="memdesc:a4629a6b123b1eed417879b3092ce0a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in next chunk. 0 if last. <br /></td></tr>
<tr class="separator:a4629a6b123b1eed417879b3092ce0a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861e396bae1f736632948ba99c7b4317"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a861e396bae1f736632948ba99c7b4317">skipArray</a> ()=0</td></tr>
<tr class="memdesc:a861e396bae1f736632948ba99c7b4317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip an array.  <a href="classavro_1_1Decoder.html#a861e396bae1f736632948ba99c7b4317">More...</a><br /></td></tr>
<tr class="separator:a861e396bae1f736632948ba99c7b4317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e8a7d7e4fd123ffc6219f75fd03175"><td class="memItemLeft" align="right" valign="top"><a id="a50e8a7d7e4fd123ffc6219f75fd03175"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a50e8a7d7e4fd123ffc6219f75fd03175">mapStart</a> ()=0</td></tr>
<tr class="memdesc:a50e8a7d7e4fd123ffc6219f75fd03175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start decoding a map. Returns the number of entries in first chunk. <br /></td></tr>
<tr class="separator:a50e8a7d7e4fd123ffc6219f75fd03175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c3be19c33ce5cd04478be5f6d7e454"><td class="memItemLeft" align="right" valign="top"><a id="a06c3be19c33ce5cd04478be5f6d7e454"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a06c3be19c33ce5cd04478be5f6d7e454">mapNext</a> ()=0</td></tr>
<tr class="memdesc:a06c3be19c33ce5cd04478be5f6d7e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of entries in next chunk. 0 if last. <br /></td></tr>
<tr class="separator:a06c3be19c33ce5cd04478be5f6d7e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cfe7538606efec884549eba9c7545e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a70cfe7538606efec884549eba9c7545e">skipMap</a> ()=0</td></tr>
<tr class="memdesc:a70cfe7538606efec884549eba9c7545e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to skip a map.  <a href="classavro_1_1Decoder.html#a70cfe7538606efec884549eba9c7545e">More...</a><br /></td></tr>
<tr class="separator:a70cfe7538606efec884549eba9c7545e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa55c2e0fe4e1cb728cdd6283c4f219"><td class="memItemLeft" align="right" valign="top"><a id="a5aa55c2e0fe4e1cb728cdd6283c4f219"></a>
virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#a5aa55c2e0fe4e1cb728cdd6283c4f219">decodeUnionIndex</a> ()=0</td></tr>
<tr class="memdesc:a5aa55c2e0fe4e1cb728cdd6283c4f219"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a branch of a union. The actual value is to follow. <br /></td></tr>
<tr class="separator:a5aa55c2e0fe4e1cb728cdd6283c4f219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e3537882cf6ac05e0d02130873b77a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html#ad8e3537882cf6ac05e0d02130873b77a">drain</a> ()=0</td></tr>
<tr class="memdesc:ad8e3537882cf6ac05e0d02130873b77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drains any additional data at the end of the current entry in a stream.  <a href="classavro_1_1Decoder.html#ad8e3537882cf6ac05e0d02130873b77a">More...</a><br /></td></tr>
<tr class="separator:ad8e3537882cf6ac05e0d02130873b77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> is an interface implemented by every decoder capable of decoding Avro data. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abff413217a31b08e9f66e361b2a18b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff413217a31b08e9f66e361b2a18b6e">&#9670;&nbsp;</a></span>decodeFixed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;uint8_t&gt; avro::Decoder::decodeFixed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes fixed length binary from the current stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size (byte count) of the fixed being read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The fixed data that has been read. The size of the returned vector is guaranteed to be equal to <code>n</code>. </dd></dl>

<p class="reference">Referenced by <a class="el" href="structavro_1_1codec__traits_3_01std_1_1array_3_01uint8__t_00_01N_01_4_01_4.html#acc868a365f15018f2de1216ed2b83588">avro::codec_traits&lt; std::array&lt; uint8_t, N &gt; &gt;::decode()</a>.</p>

</div>
</div>
<a id="a156efba788d2aa51d17a57edf7793632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156efba788d2aa51d17a57edf7793632">&#9670;&nbsp;</a></span>decodeFixed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void avro::Decoder::decodeFixed </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes a fixed from the current stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size (byte count) of the fixed being read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The value that receives the fixed. The vector will be size-adjusted based on the fixed schema's size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8e3537882cf6ac05e0d02130873b77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e3537882cf6ac05e0d02130873b77a">&#9670;&nbsp;</a></span>drain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void avro::Decoder::drain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drains any additional data at the end of the current entry in a stream. </p>
<p>It also returns any unused bytes back to any underlying input stream. One situation this happens is when the reader's schema and the writer's schema are records but are different and the writer's record has more fields at the end of the record. Leaving such data unread is usually not a problem. If multiple records are stored consecutively in a stream (e.g. Avro data file) any attempt to read the next record will automatically skip those extra fields of the current record. It would still leave the extra fields at the end of the last record in the stream. This would mean that the stream is not in a good state. For example, if some non-avro information is stored at the end of the stream, the consumers of such data would see the bytes left behind by the avro decoder. Similar set of problems occur if the <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> consumes more than what it should. </p>

</div>
</div>
<a id="a861e396bae1f736632948ba99c7b4317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861e396bae1f736632948ba99c7b4317">&#9670;&nbsp;</a></span>skipArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t avro::Decoder::skipArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to skip an array. </p>
<p>If it can, it returns 0. Otherwise it returns the number of elements to be skipped. The client should skip the individual items. In such cases, skipArray is identical to arrayStart. </p>

</div>
</div>
<a id="a70cfe7538606efec884549eba9c7545e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cfe7538606efec884549eba9c7545e">&#9670;&nbsp;</a></span>skipMap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t avro::Decoder::skipMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to skip a map. </p>
<p>If it can, it returns 0. Otherwise it returns the number of elements to be skipped. The client should skip the individual items. In such cases, skipMap is identical to mapStart. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>api/<a class="el" href="Decoder_8hh_source.html">Decoder.hh</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
