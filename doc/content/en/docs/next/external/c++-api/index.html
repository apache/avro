<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Avro C++: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Avro C++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2 id="Introduction">Introduction to Avro C++ <a href="#Introduction">§</a></h2>
<p>Avro is a data serialization system. See <a href="https://avro.apache.org/docs/current/">https://avro.apache.org/docs/current/</a> for background information.</p>
<p>Avro C++ is a C++ library which implements parts of the <a href="https://avro.apache.org/docs/current/spec.html">Avro Specification</a>. The library includes the following functionality:</p>
<ul>
<li>
Assembling schemas programmatically. </li>
<li>
A schema parser, which can parse Avro schema (written in JSON) into a Schema object. </li>
<li>
Encoders and decoders to encode data into Avro format and decode it back using primitive functions. There are multiple implementations of encoders and decoders. <ul>
<li>
A binary encoder, which encodes into binary Avro data. </li>
<li>
A JSON encoder, which encodes into JSON Avro data. </li>
<li>
A validating encoder, an encoder proxy, which validates the call sequence to the encoder before sending the calls to another encoder. </li>
<li>
A binary decoder, which decodes binary Avro data. </li>
<li>
A JSON decoder, which decodes JSON Avro data. </li>
<li>
A validating decoder, a decoder proxy, which validates the call sequence to the decoder before sending the calls to another decoder. </li>
<li>
A resolving decoder, which accepts calls for according to a reader's schema but decodes data corresponding to a different (writer's) schema doing schema resolution according to resolution rules in the Avro specification. </li>
</ul>
</li>
<li>
Streams for storing and reading data, which Encoders and Decoders use. </li>
<li>
Support for Avro DataFile. </li>
<li>
A code generator, which generates C++ classes and functions to encode and decode them. The code generator produces a C++ header file from a given schema file. </li>
</ul>
<p>Presently there is no support for the following specified in Avro specification. </p><ul>
<li>
Avro RPC </li>
</ul>
<p><b>Note:</b> Prior to Avro release 1.5, some of the functionality mentioned above was available through a somewhat different API and set tools. They are partially incompatible to the present ones. They continue to be available but will be deprecated and discontinued sometime in the future. The documentation on that API can be found at <a href="https://avro.apache.org/docs/1.4.0/api/cpp/html/index.html">https://avro.apache.org/docs/1.4.0/api/cpp/html/index.html</a></p>
<h2 id="Installing">Installing Avro C++ <a href="#Installing">§</a></h2>
<h3>Supported platforms and pre-requisites</h3>
<p>One should be able to build Avro C++ on (1) any UNIX flavor including cygwin for Windows and (2) natively on Windows using Visual Studio. We have tested it on (1) Linux systems (Ubuntu and RHEL) and Cygwin and Visual Studio 2010 Express edition.</p>
<p>In order to build Avro C++, one needs the following: </p><ul>
<li>
A C++ compiler and runtime libraries. </li>
<li>
Boost library version 1.38 or later. Apart from the header-only libraries of Boost, Avro C++ requires filesystem, iostreams, system and program_options libraries. Please see <a href="https://www.boost.org/">https://www.boost.org</a> or your platform's documentation for details on how to set up Boost for your platform. </li>
<li>
CMake build tool version 2.6 or later. Please see <a href="https://www.cmake.org">https://www.cmake.org</a> or your platform's documentation for details on how to set up CMake for your system. </li>
<li>
Python. If not already present, please consult your platform-specific documentation on how to install Python on your system. </li>
</ul>
<p>For Ubuntu Linux, for example, you can have these by doing <code>apt-get install</code> for the following packages: \ul </p><ul>
<li>cmake </li>
<li>g++ </li>
<li>libboost-dev </li>
<li>libboost-filesystem-dev </li>
<li>libboost-iostreams-dev </li>
<li>libboost-program-options-dev </li>
<li>libboost-system-dev</li>
</ul>
<p>For Windows native builds, you need to install the following: \ul </p><ul>
<li>cmake </li>
<li>boost distribution from Boost consulting </li>
<li>Visual studio</li>
</ul>
<h3>Installing Avro C++</h3>
<ol>
<li>
Download the latest Avro distribution. Avro distribution is a compressed tarball. Please see the main documentation if you want to build anything more than Avro C++. </li>
</ol>
<h4>On Unix systems and on Cygwin</h4>
<ol>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Type <code>./build.sh test</code>. This builds Avro C++ and runs tests on it. </li>
<li>
Type <code>./build.sh install</code>. This installs Avro C++ under /usr/local on your system. </li>
</ol>
<h4>On native Windows</h4>
<ol>
<li>
Ensure that CMake's bin directory and Boost's lib directory are in the path. </li>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Create a subdirectory, say, build.win, and change to that directory. </li>
<li>
Type <code>cmake -G "Visual Studio 10"</code>. It creates, among other things, Avro-cpp.sln file. </li>
<li>
Open the solution file using Visual Studio and build the projects from within the Visual Studio. </li>
<li>
To run all unit tests, build the special project named "RUN_TESTS". </li>
<li>
<p class="startli">After building all the projects, you can also execute the unit tests from command line. <code>ctest -C release</code> or <code>ctest -C debug</code>.</p>
<p class="endli"></p>
</li>
</ol>
<h2 id="GettingStarted">Getting started with Avro C++ <a href="#GettingStarted">§</a></h2>
<p>Although Avro does not require use of code generation, that is the easiest way to get started with the Avro C++ library. The code generator reads a schema, and generates a C++ header file that defines one or more C++ <code>struct</code>s to represent the data for the schema and functions to encode and decode those <code>struct</code>s. Even if you wish to write custom code to encode and decode your objects using the core functionality of Avro C++, the generated code can serve as an example of how to use the code functionality.</p>
<p>Let's walk through an example, using a simple schema. Use the schema that represents an complex number:</p>
<p><b>File: cpx.json</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &quot;type&quot;: &quot;record&quot;,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &quot;name&quot;: &quot;cpx&quot;,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &quot;fields&quot; : [</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        {&quot;name&quot;: &quot;re&quot;, &quot;type&quot;: &quot;double&quot;},</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        {&quot;name&quot;: &quot;im&quot;, &quot;type&quot; : &quot;double&quot;}</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ]</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --> <p><b>Note:</b> All the example code given here can be found under <code>examples</code> directory of the distribution.</p>
<p>Assume this JSON representation of the schema is stored in a file called <code>cpx.json</code>. To generate the code issue the command:. </p><pre>
avrogencpp -i cpx.json -o cpx.hh -n c
</pre><p> The <code>-i</code> flag specifies the input schema file and <code>-o</code> flag specifies the output header file to generate. The generated C++ code will be in the namespace specified with <code>-n</code> flag.</p>
<p>The generated file, among other things will have the following:</p>
<pre>

...
namespace c {
...

struct cpx {
    double re;
    double im;
};


...

}

</pre><p> <code>cpx</code> is a C++ representation of the Avro schema <code>cpx</code>.</p>
<p>Now let's see how we can use the code generated to encode data into avro and decode it back.</p>
<p><b>File: generated.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;main()</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;{</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a>();</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <a class="code" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a>();</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    c1.re = 1.0;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    c1.im = 2.13;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(*e, c1);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a>(*out);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a>();</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160; </div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    c::cpx c2;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(*d, c2);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160; </div>
<div class="ttc" id="anamespaceavro_html_a04f78e53cb84a0189b626e6a5726b148"><div class="ttname"><a href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a></div><div class="ttdeci">AVRO_DECL DecoderPtr binaryDecoder()</div><div class="ttdoc">Returns an decoder that can decode binary Avro standard.</div></div>
<div class="ttc" id="anamespaceavro_html_a068734327d24a1e80caeee07b70b367f"><div class="ttname"><a href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a></div><div class="ttdeci">void encode(Encoder &amp;e, const T &amp;t)</div><div class="ttdoc">Generic encoder function that makes use of the codec_traits.</div><div class="ttdef"><b>Definition:</b> Specific.hh:343</div></div>
<div class="ttc" id="anamespaceavro_html_a0e961740e43d3f800220f03de11654e8"><div class="ttname"><a href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a></div><div class="ttdeci">AVRO_DECL OutputStreamPtr memoryOutputStream(size_t chunkSize=4 *1024)</div><div class="ttdoc">Returns a new OutputStream, which grows in memory chunks of specified size.</div></div>
<div class="ttc" id="anamespaceavro_html_a2bf627d2676075c8eeaf6a25103b5d5e"><div class="ttname"><a href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a></div><div class="ttdeci">std::shared_ptr&lt; Encoder &gt; EncoderPtr</div><div class="ttdoc">Shared pointer to Encoder.</div><div class="ttdef"><b>Definition:</b> Encoder.hh:147</div></div>
<div class="ttc" id="anamespaceavro_html_a2e61ab3fbdffc13d2a20efd80c5811b1"><div class="ttname"><a href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a></div><div class="ttdeci">std::shared_ptr&lt; Decoder &gt; DecoderPtr</div><div class="ttdoc">Shared pointer to Decoder.</div><div class="ttdef"><b>Definition:</b> Decoder.hh:177</div></div>
<div class="ttc" id="anamespaceavro_html_a9893c6f7b0f264029261056da57fbd2d"><div class="ttname"><a href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a></div><div class="ttdeci">void decode(Decoder &amp;d, T &amp;t)</div><div class="ttdoc">Generic decoder function that makes use of the codec_traits.</div><div class="ttdef"><b>Definition:</b> Specific.hh:351</div></div>
<div class="ttc" id="anamespaceavro_html_a98b7a8baaef11e477db89699ab27359b"><div class="ttname"><a href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a></div><div class="ttdeci">AVRO_DECL InputStreamPtr memoryInputStream(const uint8_t *data, size_t len)</div><div class="ttdoc">Returns a new InputStream, with the data from the given byte array.</div></div>
<div class="ttc" id="anamespaceavro_html_ad0158bd2fc76615b68db68d7e4f7c4f6"><div class="ttname"><a href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a></div><div class="ttdeci">AVRO_DECL EncoderPtr binaryEncoder()</div><div class="ttdoc">Returns an encoder that can encode binary Avro standard.</div></div>
</div><!-- fragment --><p>In line 27, we construct a memory output stream. By this we indicate that we want to send the encoded Avro data into memory. In line 28, we construct a binary encoder, whereby we mean the output should be encoded using the Avro binary standard. In line 29, we attach the output stream to the encoder. At any given time an encoder can write to only one output stream. </p>
<p>In line 32, we write the contents of c1 into the output stream using the encoder. Now the output stream contains the binary representation of the object. The rest of the code verifies that the data is indeed in the stream. </p>
<p>In line 35, we construct a memory input stream from the contents of the output stream. Thus the input stream has the binary representation of the object. In line 36 and 37, we construct a binary decoder and attach the input stream to it. Line 40 decodes the contents of the stream into another object c2. Now c1 and c2 should have identical contents, which one can readily verify from the output of the program, which should be:</p>
<pre>
(1, 2.13)
</pre><p>Now, if you want to encode the data using Avro JSON encoding, you should use <a class="el" href="namespaceavro.html#a0847ef62f42f6f0d0af28da9f7c7cf15" title="Returns an encoder that encodes Avro standard for JSON.">avro::jsonEncoder()</a> instead of <a class="el" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder()</a> in line 28 and <a class="el" href="namespaceavro.html#a7ac8a9c93b0621227de3dcca383e36ff" title="Returns an decoder that can decode Avro standard for JSON.">avro::jsonDecoder()</a> instead of <a class="el" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder()</a> in line 36. </p>
<p>On the other hand, if you want to write the contents to a file instead of memory, you should use <a class="el" href="namespaceavro.html#a164e34d709ba33d2464c295e7874f784" title="Returns a new OutputStream whose contents would be stored in a file.">avro::fileOutputStream()</a> instead of <a class="el" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream()</a> in line 27 and <a class="el" href="namespaceavro.html#a1e5251d2ad9581e353399c1bac90c9fb" title="Returns a new InputStream whose contents come from the given file.">avro::fileInputStream()</a> instead of <a class="el" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream()</a> in line 35. </p>
<h2 id="ReadingJsonSchema"><a class="anchor" id="ReadingJsonSchema"></a>Reading a JSON schema <a href="index.html#ReadingJsonSchema">§</a></h2>
<p>The section above demonstrated pretty much all that's needed to know to get started reading and writing objects using the Avro C++ code generator. The following sections will cover some more information.</p>
<p>The library provides some utilities to read a schema that is stored in a JSON file:</p>
<p><b>File: schemaload.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;main()</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;{</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    std::ifstream in(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> cpxSchema;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a>(in, cpxSchema);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;}</div>
<div class="ttc" id="aclassavro_1_1ValidSchema_html"><div class="ttname"><a href="classavro_1_1ValidSchema.html">avro::ValidSchema</a></div><div class="ttdoc">A ValidSchema is basically a non-mutable Schema that has passed some minimum of sanity checks.</div><div class="ttdef"><b>Definition:</b> ValidSchema.hh:40</div></div>
<div class="ttc" id="anamespaceavro_html_a31c14823127aff747cc83e6714de9e31"><div class="ttname"><a href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a></div><div class="ttdeci">AVRO_DECL void compileJsonSchema(std::istream &amp;is, ValidSchema &amp;schema)</div><div class="ttdoc">Given a stream containing a JSON schema, compiles the schema to a ValidSchema object.</div></div>
</div><!-- fragment --><p>This reads the file, and parses the JSON schema into an in-memory schema object of type <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minimum of sanity checks.">avro::ValidSchema</a>. If, for some reason, the schema is not valid, the <code>cpxSchema</code> object will not be set, and an exception will be thrown. </p>
<p>If you always use code Avro generator you don't really need the in-memory schema objects. But if you use custom objects and routines to encode or decode avro data, you will need the schema objects. Other uses of schema objects are generic data objects and schema resolution described in the following sections.</p>
<h2 id="CustomEncodingDecoding">Custom encoding and decoding <a href="#CustomEncodingDecoding">§</a></h2>
<p>Suppose you want to encode objects of type std::complex&lt;double&gt; from C++ standard library using the schema defined in cpx.json. Since std::complex&lt;double&gt; was not generated by Avro, it doesn't know how to encode or decode objects of that type. You have to tell Avro how to do that.</p>
<p>The recommended way to tell Avro how to encode or decode is to specialize Avro's codec_traits template. For std::complex&lt;double&gt;, here is what you'd do:</p>
<p><b>File: custom.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceavro.html">avro</a> {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt; &gt; {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">encode</a>(Encoder&amp; e, <span class="keyword">const</span> std::complex&lt;T&gt;&amp; c) {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(e, std::real(c));</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(e, std::imag(c));</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    }</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">decode</a>(Decoder&amp; d, std::complex&lt;T&gt;&amp; c) {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        T re, im;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(d, re);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(d, im);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        c = std::complex&lt;T&gt;(re, im);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;};</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;}</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;main()</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a>();</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <a class="code" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a>();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    std::complex&lt;double&gt; c1(1.0, 2.0);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(*e, c1);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160; </div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a>(*out);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a>();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160; </div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    std::complex&lt;double&gt; c2;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(*d, c2);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div>
<div class="ttc" id="anamespaceavro_html"><div class="ttname"><a href="namespaceavro.html">avro</a></div><div class="ttdoc">A bunch of templates and specializations for encoding and decoding specific types.</div><div class="ttdef"><b>Definition:</b> AvroParse.hh:30</div></div>
</div><!-- fragment --><p>Please notice that the main function is pretty much similar to that we used for the generated class. Once <code>codec_traits</code> for a specific type is supplied, you do not really need to do anything special for your custom types.</p>
<p>But wait, how does Avro know that complex&lt;double&gt; represents the data for the schema in <code>cpx.json</code>? It doesn't. In fact, if you have used <code>std::complex&lt;float&gt;</code> instead of <code>std::complex&lt;double&gt;</code> program would have worked. But the data in the memory would not have been corresponding to the schema in <code>cpx.json</code>.</p>
<p>In order to ensure that you indeed use the correct type, you can use the validating encoders and decoder. Here is how:</p>
<p><b>File: validating.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespaceavro.html">avro</a> {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt; &gt; {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">encode</a>(Encoder&amp; e, <span class="keyword">const</span> std::complex&lt;T&gt;&amp; c) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(e, std::real(c));</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(e, std::imag(c));</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">decode</a>(Decoder&amp; d, std::complex&lt;T&gt;&amp; c) {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        T re, im;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(d, re);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(d, im);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        c = std::complex&lt;T&gt;(re, im);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;};</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;}</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;main()</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;{</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> cpxSchema;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a>(ifs, cpxSchema);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; </div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a>();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <a class="code" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e">avro::validatingEncoder</a>(cpxSchema,</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a>());</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    std::complex&lt;double&gt; c1(1.0, 2.0);</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(*e, c1);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a>(*out);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae">avro::validatingDecoder</a>(cpxSchema,</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a>());</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160; </div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::complex&lt;double&gt; c2;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(*d, c2);</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div>
<div class="ttc" id="anamespaceavro_html_a1ba750d980390623baeae24bc24b286e"><div class="ttname"><a href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e">avro::validatingEncoder</a></div><div class="ttdeci">AVRO_DECL EncoderPtr validatingEncoder(const ValidSchema &amp;schema, const EncoderPtr &amp;base)</div><div class="ttdoc">Returns an encoder that validates sequence of calls to an underlying Encoder against the given schema...</div></div>
<div class="ttc" id="anamespaceavro_html_a9408498d77f42a536074433cc541d8ae"><div class="ttname"><a href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae">avro::validatingDecoder</a></div><div class="ttdeci">AVRO_DECL DecoderPtr validatingDecoder(const ValidSchema &amp;schema, const DecoderPtr &amp;base)</div><div class="ttdoc">Returns an decoder that validates sequence of calls to an underlying Decoder against the given schema...</div></div>
</div><!-- fragment --><p>Here, instead of using the plain binary encoder, you use a validating encoder backed by a binary encoder. Similarly, instead of using the plain binary decoder, you use a validating decoder backed by a binary decoder. Now, if you use <code>std::complex&lt;float&gt;</code> instead of <code>std::complex&lt;double&gt;</code> the validating encoder and decoder will throw exception stating that you are trying to encode or decode <code>float</code> instead of <code>double</code>. </p>
<p>You can use any encoder behind the validating encoder and any decoder behind the validating decoder. But in practice, only the binary encoder and the binary decoder have no knowledge of the underlying schema. All other encoders (JSON encoder) and decoders (JSON decoder, resolving decoder) do know about the schema and they validate internally. So, fronting them with a validating encoder or validating decoder is wasteful.</p>
<h2 id="GenericDataObjects">Generic data objects <a href="#GenericDataObjects">§</a></h2>
<p>A third way to encode and decode data is to use Avro's generic datum. Avro's generic datum allows you to read any arbitrary data corresponding to an arbitrary schema into a generic object. One need not know anything about the schema or data at compile time.</p>
<p>Here is an example how one can use the generic datum.</p>
<p><b>File: generic.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;main()</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;{</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> cpxSchema;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a>(ifs, cpxSchema);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a>();</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <a class="code" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a>();</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    c1.re = 100.23;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    c1.im = 105.77;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(*e, c1);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a>(*out);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a>();</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    <a class="code" href="classavro_1_1GenericDatum.html">avro::GenericDatum</a> datum(cpxSchema);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(*d, datum);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Type: &quot;</span> &lt;&lt; datum.type() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    <span class="keywordflow">if</span> (datum.type() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">avro::AVRO_RECORD</a>) {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericRecord.html">avro::GenericRecord</a>&amp; r = datum.value&lt;<a class="code" href="classavro_1_1GenericRecord.html">avro::GenericRecord</a>&gt;();</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Field-count: &quot;</span> &lt;&lt; r.<a class="code" href="classavro_1_1GenericRecord.html#a9767db73c93f49538882d3d675949322">fieldCount</a>() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keywordflow">if</span> (r.<a class="code" href="classavro_1_1GenericRecord.html#a9767db73c93f49538882d3d675949322">fieldCount</a>() == 2) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericDatum.html">avro::GenericDatum</a>&amp; f0 = r.<a class="code" href="classavro_1_1GenericRecord.html#a29c2793a54a7e223548290a0fbf046ef">fieldAt</a>(0);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            <span class="keywordflow">if</span> (f0.<a class="code" href="classavro_1_1GenericDatum.html#aae8325a782f95c74c98886c061c4269f">type</a>() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">avro::AVRO_DOUBLE</a>) {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;Real: &quot;</span> &lt;&lt; f0.<a class="code" href="classavro_1_1GenericDatum.html#a489e7aa51a1235b2c3954d90c7672e28">value</a>&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            }</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;            <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericDatum.html">avro::GenericDatum</a>&amp; f1 = r.<a class="code" href="classavro_1_1GenericRecord.html#a29c2793a54a7e223548290a0fbf046ef">fieldAt</a>(1);</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            <span class="keywordflow">if</span> (f1.<a class="code" href="classavro_1_1GenericDatum.html#aae8325a782f95c74c98886c061c4269f">type</a>() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">avro::AVRO_DOUBLE</a>) {</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; f1.<a class="code" href="classavro_1_1GenericDatum.html#a489e7aa51a1235b2c3954d90c7672e28">value</a>&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;            }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;        }</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    }</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;}</div>
<div class="ttc" id="aclassavro_1_1GenericDatum_html"><div class="ttname"><a href="classavro_1_1GenericDatum.html">avro::GenericDatum</a></div><div class="ttdoc">Generic datum which can hold any Avro type.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:61</div></div>
<div class="ttc" id="aclassavro_1_1GenericDatum_html_a489e7aa51a1235b2c3954d90c7672e28"><div class="ttname"><a href="classavro_1_1GenericDatum.html#a489e7aa51a1235b2c3954d90c7672e28">avro::GenericDatum::value</a></div><div class="ttdeci">const T &amp; value() const</div><div class="ttdoc">Returns the value held by this datum.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:576</div></div>
<div class="ttc" id="aclassavro_1_1GenericDatum_html_aae8325a782f95c74c98886c061c4269f"><div class="ttname"><a href="classavro_1_1GenericDatum.html#aae8325a782f95c74c98886c061c4269f">avro::GenericDatum::type</a></div><div class="ttdeci">Type type() const</div><div class="ttdoc">The avro data type this datum holds.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:541</div></div>
<div class="ttc" id="aclassavro_1_1GenericRecord_html"><div class="ttname"><a href="classavro_1_1GenericRecord.html">avro::GenericRecord</a></div><div class="ttdoc">The generic container for Avro records.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:286</div></div>
<div class="ttc" id="aclassavro_1_1GenericRecord_html_a29c2793a54a7e223548290a0fbf046ef"><div class="ttname"><a href="classavro_1_1GenericRecord.html#a29c2793a54a7e223548290a0fbf046ef">avro::GenericRecord::fieldAt</a></div><div class="ttdeci">const GenericDatum &amp; fieldAt(size_t pos) const</div><div class="ttdoc">Returns the field at the given position pos.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:341</div></div>
<div class="ttc" id="aclassavro_1_1GenericRecord_html_a9767db73c93f49538882d3d675949322"><div class="ttname"><a href="classavro_1_1GenericRecord.html#a9767db73c93f49538882d3d675949322">avro::GenericRecord::fieldCount</a></div><div class="ttdeci">size_t fieldCount() const</div><div class="ttdoc">Returns the number of fields in the current record.</div><div class="ttdef"><b>Definition:</b> GenericDatum.hh:299</div></div>
<div class="ttc" id="anamespaceavro_html_a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3"><div class="ttname"><a href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">avro::AVRO_RECORD</a></div><div class="ttdeci">@ AVRO_RECORD</div><div class="ttdef"><b>Definition:</b> Types.hh:42</div></div>
<div class="ttc" id="anamespaceavro_html_a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800"><div class="ttname"><a href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">avro::AVRO_DOUBLE</a></div><div class="ttdeci">@ AVRO_DOUBLE</div><div class="ttdef"><b>Definition:</b> Types.hh:38</div></div>
</div><!-- fragment --><p>In this example, we encode the data using generated code and decode it with generic datum. Then we examine the contents of the generic datum and extract them. Please see <a class="el" href="classavro_1_1GenericDatum.html">avro::GenericDatum</a> for more details on how to use it.</p>
<h2 id="ReadingDifferentSchema">Reading data with a schema different from that of the writer <a href="#ReadingDifferentSchema">§</a></h2>
<p>It is possible to read the data written according to one schema using a different schema, provided the reader's schema and the writer's schema are compatible according to the Avro's Schema resolution rules. </p>
<p>For example, you have a reader which is interested only in the imaginary part of a complex number while the writer writes both the real and imaginary parts. It is possible to do automatic schema resolution between the writer's schema and schema as shown below.</p>
<p><b>File: imaginary.json</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &quot;type&quot;: &quot;record&quot;,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &quot;name&quot;: &quot;cpx&quot;,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &quot;fields&quot; : [</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        {&quot;name&quot;: &quot;im&quot;, &quot;type&quot; : &quot;double&quot;}</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ]</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --><pre>
avrogencpp -i imaginary.json -o imaginary.hh -n i
</pre><p><b>File: resolving.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;imaginary.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160; </div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> load(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;{</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    std::ifstream ifs(filename);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> result;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a>(ifs, result);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;}</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160; </div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;main()</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;{</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> cpxSchema = load(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> imaginarySchema = load(<span class="stringliteral">&quot;imaginary.json&quot;</span>);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160; </div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">avro::memoryOutputStream</a>();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    <a class="code" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">avro::binaryEncoder</a>();</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    c1.re = 100.23;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    c1.im = 105.77;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">avro::encode</a>(*e, c1);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">avro::memoryInputStream</a>(*out);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">avro::resolvingDecoder</a>(cpxSchema, imaginarySchema,</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">avro::binaryDecoder</a>());</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160; </div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    i::cpx c2;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">avro::decode</a>(*d, c2);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; c2.im &lt;&lt; std::endl;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160; </div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;}</div>
<div class="ttc" id="anamespaceavro_html_aeef8b583abe36b25a8d2094d7a3d4b96"><div class="ttname"><a href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">avro::resolvingDecoder</a></div><div class="ttdeci">AVRO_DECL ResolvingDecoderPtr resolvingDecoder(const ValidSchema &amp;writer, const ValidSchema &amp;reader, const DecoderPtr &amp;base)</div><div class="ttdoc">Returns a decoder that decodes avro data from base written according to writerSchema and resolves aga...</div></div>
</div><!-- fragment --><p>In this example, writer and reader deal with different schemas, both have a record with the name 'cpx'. The writer schema has two fields and the reader's has just one. We generated code for writer's schema in a namespace <code>c</code> and the reader's in <code>i</code>.</p>
<p>Please notice how the reading part of the example at line 60 reads as if the stream contains the data corresponding to its schema. The schema resolution is automatically done by the resolving decoder.</p>
<p>In this example, we have used a simple (somewhat artificial) projection (where the set of fields in the reader's schema is a subset of set of fields in the writer's). But more complex resolutions are allowed by Avro specification.</p>
<h2 id="UsingAvroDataFiles">Using Avro data files <a href="#UsingAvroDataFiles">§</a></h2>
<p>Avro specification specifies a format for data files. Avro C++ implements the specification. The code below demonstrates how one can use the Avro data file to store and retrieve a collection of objects corresponding to a given schema.</p>
<p><b>File: datafile.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;avro/DataFile.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; </div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> loadSchema(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;{</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::ifstream ifs(filename);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> result;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a>(ifs, result);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="keywordtype">int</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;main()</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;{</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    <a class="code" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a> cpxSchema = loadSchema(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160; </div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <a class="code" href="classavro_1_1DataFileWriter.html">avro::DataFileWriter&lt;c::cpx&gt;</a> dfw(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        c::cpx c1;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) {</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            c1.re = i * 100;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            c1.im = i + 100;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            dfw.write(c1);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        dfw.close();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    {</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <a class="code" href="classavro_1_1DataFileReader.html">avro::DataFileReader&lt;c::cpx&gt;</a> dfr(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        c::cpx c2;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;        <span class="keywordflow">while</span> (dfr.read(c2)) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;            std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    }</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;}</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160; </div>
<div class="ttc" id="aclassavro_1_1DataFileReader_html"><div class="ttname"><a href="classavro_1_1DataFileReader.html">avro::DataFileReader</a></div><div class="ttdoc">Reads the contents of data file one after another.</div><div class="ttdef"><b>Definition:</b> DataFile.hh:306</div></div>
<div class="ttc" id="aclassavro_1_1DataFileWriter_html"><div class="ttname"><a href="classavro_1_1DataFileWriter.html">avro::DataFileWriter</a></div><div class="ttdoc">An Avro datafile that can store objects of type T.</div><div class="ttdef"><b>Definition:</b> DataFile.hh:147</div></div>
</div><!-- fragment --><p>Please see <a class="el" href="DataFile_8hh_source.html">DataFile.hh</a> for more details. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
