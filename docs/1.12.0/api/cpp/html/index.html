<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Avro C++: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Avro C++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2 id="Introduction">Introduction to Avro C++ <a href="#Introduction">ยง</a></h2>
<p>Avro is a data serialization system. See <a href="https://avro.apache.org/docs/current/">https://avro.apache.org/docs/current/</a> for background information.</p>
<p>Avro C++ is a C++ library which implements parts of the <a href="https://avro.apache.org/docs/current/spec.html">Avro Specification</a>. The library includes the following functionality:</p>
<ul>
<li>
Assembling schemas programmatically. </li>
<li>
A schema parser, which can parse Avro schema (written in JSON) into a Schema object. </li>
<li>
Encoders and decoders to encode data into Avro format and decode it back using primitive functions. There are multiple implementations of encoders and decoders. <ul>
<li>
A binary encoder, which encodes into binary Avro data. </li>
<li>
A JSON encoder, which encodes into JSON Avro data. </li>
<li>
A validating encoder, an encoder proxy, which validates the call sequence to the encoder before sending the calls to another encoder. </li>
<li>
A binary decoder, which decodes binary Avro data. </li>
<li>
A JSON decoder, which decodes JSON Avro data. </li>
<li>
A validating decoder, a decoder proxy, which validates the call sequence to the decoder before sending the calls to another decoder. </li>
<li>
A resolving decoder, which accepts calls for according to a reader's schema but decodes data corresponding to a different (writer's) schema doing schema resolution according to resolution rules in the Avro specification. </li>
</ul>
</li>
<li>
Streams for storing and reading data, which Encoders and Decoders use. </li>
<li>
Support for Avro DataFile. </li>
<li>
A code generator, which generates C++ classes and functions to encode and decode them. The code generator produces a C++ header file from a given schema file. </li>
</ul>
<p>Presently there is no support for the following specified in Avro specification. </p><ul>
<li>
Avro RPC </li>
</ul>
<p><b>Note:</b> Prior to Avro release 1.5, some of the functionality mentioned above was available through a somewhat different API and set tools. They are partially incompatible to the present ones. They continue to be available but will be deprecated and discontinued sometime in the future. The documentation on that API can be found at <a href="https://avro.apache.org/docs/1.4.0/api/cpp/html/index.html">https://avro.apache.org/docs/1.4.0/api/cpp/html/index.html</a></p>
<h2 id="Installing">Installing Avro C++ <a href="#Installing">ยง</a></h2>
<h3>Supported platforms and pre-requisites</h3>
<p>One should be able to build Avro C++ on (1) any UNIX flavor including cygwin for Windows and (2) natively on Windows using Visual Studio. We have tested it on (1) Linux systems (Ubuntu and RHEL) and Cygwin and Visual Studio 2010 Express edition.</p>
<p>In order to build Avro C++, one needs the following: </p><ul>
<li>
A C++17 or later compiler and runtime libraries. </li>
<li>
Boost library version 1.38 or later. Apart from the header-only libraries of Boost, Avro C++ requires filesystem, iostreams, system and program_options libraries. Please see <a href="https://www.boost.org/">https://www.boost.org</a> or your platform's documentation for details on how to set up Boost for your platform. </li>
<li>
CMake build tool version 3.5 or later. Please see <a href="https://www.cmake.org">https://www.cmake.org</a> or your platform's documentation for details on how to set up CMake for your system. </li>
<li>
Python. If not already present, please consult your platform-specific documentation on how to install Python on your system. </li>
</ul>
<p>For Ubuntu Linux, for example, you can have these by doing <code>apt-get install</code> for the following packages: </p><ul>
<li>cmake </li>
<li>g++ </li>
<li>libboost-dev </li>
<li>libboost-filesystem-dev </li>
<li>libboost-iostreams-dev </li>
<li>libboost-program-options-dev </li>
<li>libboost-system-dev</li>
</ul>
<p>For Windows native builds, you need to install the following: </p><ul>
<li>cmake </li>
<li>boost distribution from Boost consulting </li>
<li>Visual studio</li>
</ul>
<h3>Installing Avro C++</h3>
<ol>
<li>
Download the latest Avro distribution. Avro distribution is a compressed tarball. Please see the main documentation if you want to build anything more than Avro C++. </li>
</ol>
<h4>On Unix systems and on Cygwin</h4>
<ol>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Type <code>./build.sh test</code>. This builds Avro C++ and runs tests on it. </li>
<li>
Type <code>./build.sh install</code>. This installs Avro C++ under /usr/local on your system. </li>
</ol>
<h4>On native Windows</h4>
<ol>
<li>
Ensure that CMake's bin directory and Boost's lib directory are in the path. </li>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Create a subdirectory, say, build.win, and change to that directory. </li>
<li>
Type <code>cmake -G "Visual Studio 10"</code>. It creates, among other things, Avro-cpp.sln file. </li>
<li>
Open the solution file using Visual Studio and build the projects from within the Visual Studio. </li>
<li>
To run all unit tests, build the special project named "RUN_TESTS". </li>
<li>
<p class="startli">After building all the projects, you can also execute the unit tests from command line. <code>ctest -C release</code> or <code>ctest -C debug</code>.</p>
<p class="endli"></p>
</li>
</ol>
<h2 id="GettingStarted">Getting started with Avro C++ <a href="#GettingStarted">ยง</a></h2>
<p>Although Avro does not require use of code generation, that is the easiest way to get started with the Avro C++ library. The code generator reads a schema, and generates a C++ header file that defines one or more C++ <code>struct</code>s to represent the data for the schema and functions to encode and decode those <code>struct</code>s. Even if you wish to write custom code to encode and decode your objects using the core functionality of Avro C++, the generated code can serve as an example of how to use the code functionality.</p>
<p>Let's walk through an example, using a simple schema. Use the schema that represents an complex number:</p>
<p><b>File: cpx.json</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &quot;type&quot;: &quot;record&quot;,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &quot;name&quot;: &quot;cpx&quot;,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &quot;fields&quot; : [</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        {&quot;name&quot;: &quot;re&quot;, &quot;type&quot;: &quot;double&quot;},</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;        {&quot;name&quot;: &quot;im&quot;, &quot;type&quot; : &quot;double&quot;}</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;    ]</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;}</div>
</div><!-- fragment --> <p><b>Note:</b> All the example code given here can be found under <code>examples</code> directory of the distribution.</p>
<p>Assume this JSON representation of the schema is stored in a file called <code>cpx.json</code>. To generate the code issue the command:. </p><pre>
avrogencpp -i cpx.json -o cpx.hh -n c
</pre><p> The <code>-i</code> flag specifies the input schema file and <code>-o</code> flag specifies the output header file to generate. The generated C++ code will be in the namespace specified with <code>-n</code> flag.</p>
<p>The generated file, among other things will have the following:</p>
<pre>

...
namespace c {
...

struct cpx {
    double re;
    double im;
};


...

}

</pre><p> <code>cpx</code> is a C++ representation of the Avro schema <code>cpx</code>.</p>
<p>Now let's see how we can use the code generated to encode data into avro and decode it back.</p>
<p><b>File: generated.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; </div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = avro::memoryOutputStream();</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    avro::EncoderPtr e = avro::binaryEncoder();</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    c1.re = 1.0;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    c1.im = 2.13;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    avro::encode(*e, c1);</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160; </div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = avro::memoryInputStream(*out);</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    avro::DecoderPtr d = avro::binaryDecoder();</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    c::cpx c2;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    avro::decode(*d, c2);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div>
</div><!-- fragment --><p>In line 27, we construct a memory output stream. By this we indicate that we want to send the encoded Avro data into memory. In line 28, we construct a binary encoder, whereby we mean the output should be encoded using the Avro binary standard. In line 29, we attach the output stream to the encoder. At any given time an encoder can write to only one output stream. </p>
<p>In line 32, we write the contents of c1 into the output stream using the encoder. Now the output stream contains the binary representation of the object. The rest of the code verifies that the data is indeed in the stream. </p>
<p>In line 35, we construct a memory input stream from the contents of the output stream. Thus the input stream has the binary representation of the object. In line 36 and 37, we construct a binary decoder and attach the input stream to it. Line 40 decodes the contents of the stream into another object c2. Now c1 and c2 should have identical contents, which one can readily verify from the output of the program, which should be:</p>
<pre>
(1, 2.13)
</pre><p>Now, if you want to encode the data using Avro JSON encoding, you should use avro::jsonEncoder() instead of avro::binaryEncoder() in line 28 and avro::jsonDecoder() instead of avro::binaryDecoder() in line 36. </p>
<p>On the other hand, if you want to write the contents to a file instead of memory, you should use avro::fileOutputStream() instead of avro::memoryOutputStream() in line 27 and avro::fileInputStream() instead of avro::memoryInputStream() in line 35. </p>
<h2 id="ReadingJsonSchema"><a class="anchor" id="ReadingJsonSchema"></a>Reading a JSON schema <a href="index.html#ReadingJsonSchema">ยง</a></h2>
<p>The section above demonstrated pretty much all that's needed to know to get started reading and writing objects using the Avro C++ code generator. The following sections will cover some more information.</p>
<p>The library provides some utilities to read a schema that is stored in a JSON file:</p>
<p><b>File: schemaload.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    std::ifstream in(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    avro::ValidSchema cpxSchema;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    avro::compileJsonSchema(in, cpxSchema);</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;}</div>
</div><!-- fragment --><p>This reads the file, and parses the JSON schema into an in-memory schema object of type avro::ValidSchema. If, for some reason, the schema is not valid, the <code>cpxSchema</code> object will not be set, and an exception will be thrown. </p>
<p>If you always use code Avro generator you don't really need the in-memory schema objects. But if you use custom objects and routines to encode or decode avro data, you will need the schema objects. Other uses of schema objects are generic data objects and schema resolution described in the following sections.</p>
<h2 id="CustomEncodingDecoding">Custom encoding and decoding <a href="#CustomEncodingDecoding">ยง</a></h2>
<p>Suppose you want to encode objects of type std::complex&lt;double&gt; from C++ standard library using the schema defined in cpx.json. Since std::complex&lt;double&gt; was not generated by Avro, it doesn't know how to encode or decode objects of that type. You have to tell Avro how to do that.</p>
<p>The recommended way to tell Avro how to encode or decode is to specialize Avro's codec_traits template. For std::complex&lt;double&gt;, here is what you'd do:</p>
<p><b>File: custom.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160; </div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">namespace </span>avro {</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt;&gt; {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(Encoder &amp;e, <span class="keyword">const</span> std::complex&lt;T&gt; &amp;c) {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;        avro::encode(e, std::real(c));</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;        avro::encode(e, std::imag(c));</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    }</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> decode(Decoder &amp;d, std::complex&lt;T&gt; &amp;c) {</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;        T re, im;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        avro::decode(d, re);</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        avro::decode(d, im);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        c = std::complex&lt;T&gt;(re, im);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    }</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;};</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;} <span class="comment">// namespace avro</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = avro::memoryOutputStream();</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    avro::EncoderPtr e = avro::binaryEncoder();</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    std::complex&lt;double&gt; c1(1.0, 2.0);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    avro::encode(*e, c1);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = avro::memoryInputStream(*out);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    avro::DecoderPtr d = avro::binaryDecoder();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160; </div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    std::complex&lt;double&gt; c2;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    avro::decode(*d, c2);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div>
</div><!-- fragment --><p>Please notice that the main function is pretty much similar to that we used for the generated class. Once <code>codec_traits</code> for a specific type is supplied, you do not really need to do anything special for your custom types.</p>
<p>But wait, how does Avro know that complex&lt;double&gt; represents the data for the schema in <code>cpx.json</code>? It doesn't. In fact, if you have used <code>std::complex&lt;float&gt;</code> instead of <code>std::complex&lt;double&gt;</code> program would have worked. But the data in the memory would not have been corresponding to the schema in <code>cpx.json</code>.</p>
<p>In order to ensure that you indeed use the correct type, you can use the validating encoders and decoder. Here is how:</p>
<p><b>File: validating.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160; </div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">namespace </span>avro {</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt;&gt; {</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> encode(Encoder &amp;e, <span class="keyword">const</span> std::complex&lt;T&gt; &amp;c) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;        avro::encode(e, std::real(c));</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;        avro::encode(e, std::imag(c));</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    }</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <span class="keyword">static</span> <span class="keywordtype">void</span> decode(Decoder &amp;d, std::complex&lt;T&gt; &amp;c) {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        T re, im;</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        avro::decode(d, re);</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        avro::decode(d, im);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        c = std::complex&lt;T&gt;(re, im);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;};</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160; </div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;} <span class="comment">// namespace avro</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160; </div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    avro::ValidSchema cpxSchema;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    avro::compileJsonSchema(ifs, cpxSchema);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160; </div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = avro::memoryOutputStream();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    avro::EncoderPtr e = avro::validatingEncoder(cpxSchema,</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;                                                 avro::binaryEncoder());</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    std::complex&lt;double&gt; c1(1.0, 2.0);</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    avro::encode(*e, c1);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160; </div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = avro::memoryInputStream(*out);</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    avro::DecoderPtr d = avro::validatingDecoder(cpxSchema,</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;                                                 avro::binaryDecoder());</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160; </div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    std::complex&lt;double&gt; c2;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    avro::decode(*d, c2);</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div>
</div><!-- fragment --><p>Here, instead of using the plain binary encoder, you use a validating encoder backed by a binary encoder. Similarly, instead of using the plain binary decoder, you use a validating decoder backed by a binary decoder. Now, if you use <code>std::complex&lt;float&gt;</code> instead of <code>std::complex&lt;double&gt;</code> the validating encoder and decoder will throw exception stating that you are trying to encode or decode <code>float</code> instead of <code>double</code>. </p>
<p>You can use any encoder behind the validating encoder and any decoder behind the validating decoder. But in practice, only the binary encoder and the binary decoder have no knowledge of the underlying schema. All other encoders (JSON encoder) and decoders (JSON decoder, resolving decoder) do know about the schema and they validate internally. So, fronting them with a validating encoder or validating decoder is wasteful.</p>
<h2 id="GenericDataObjects">Generic data objects <a href="#GenericDataObjects">ยง</a></h2>
<p>A third way to encode and decode data is to use Avro's generic datum. Avro's generic datum allows you to read any arbitrary data corresponding to an arbitrary schema into a generic object. One need not know anything about the schema or data at compile time.</p>
<p>Here is an example how one can use the generic datum.</p>
<p><b>File: generic.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;complex&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; </div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160; </div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    avro::ValidSchema cpxSchema;</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    avro::compileJsonSchema(ifs, cpxSchema);</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; </div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = avro::memoryOutputStream();</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;    avro::EncoderPtr e = avro::binaryEncoder();</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    c1.re = 100.23;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    c1.im = 105.77;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    avro::encode(*e, c1);</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160; </div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = avro::memoryInputStream(*out);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    avro::DecoderPtr d = avro::binaryDecoder();</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160; </div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;    avro::GenericDatum datum(cpxSchema);</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    avro::decode(*d, datum);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Type: &quot;</span> &lt;&lt; datum.type() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    <span class="keywordflow">if</span> (datum.type() == avro::AVRO_RECORD) {</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keyword">const</span> avro::GenericRecord &amp;r = datum.value&lt;avro::GenericRecord&gt;();</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;Field-count: &quot;</span> &lt;&lt; r.fieldCount() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordflow">if</span> (r.fieldCount() == 2) {</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;            <span class="keyword">const</span> avro::GenericDatum &amp;f0 = r.fieldAt(0);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;            <span class="keywordflow">if</span> (f0.type() == avro::AVRO_DOUBLE) {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;Real: &quot;</span> &lt;&lt; f0.value&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;            }</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;            <span class="keyword">const</span> avro::GenericDatum &amp;f1 = r.fieldAt(1);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;            <span class="keywordflow">if</span> (f1.type() == avro::AVRO_DOUBLE) {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;                std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; f1.value&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;            }</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;        }</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    }</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;}</div>
</div><!-- fragment --><p>In this example, we encode the data using generated code and decode it with generic datum. Then we examine the contents of the generic datum and extract them. Please see avro::GenericDatum for more details on how to use it.</p>
<h2 id="ReadingDifferentSchema">Reading data with a schema different from that of the writer <a href="#ReadingDifferentSchema">ยง</a></h2>
<p>It is possible to read the data written according to one schema using a different schema, provided the reader's schema and the writer's schema are compatible according to the Avro's Schema resolution rules. </p>
<p>For example, you have a reader which is interested only in the imaginary part of a complex number while the writer writes both the real and imaginary parts. It is possible to do automatic schema resolution between the writer's schema and schema as shown below.</p>
<p><b>File: imaginary.json</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    &quot;type&quot;: &quot;record&quot;,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    &quot;name&quot;: &quot;cpx&quot;,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    &quot;fields&quot; : [</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;        {&quot;name&quot;: &quot;im&quot;, &quot;type&quot; : &quot;double&quot;}</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;    ]</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;}</div>
</div><!-- fragment --><pre>
avrogencpp -i imaginary.json -o imaginary.hh -n i
</pre><p><b>File: resolving.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;imaginary.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160; </div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span></div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; </div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;avro::ValidSchema load(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename) {</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    std::ifstream ifs(filename);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    avro::ValidSchema result;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    avro::compileJsonSchema(ifs, result);</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;}</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; </div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    avro::ValidSchema cpxSchema = load(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;    avro::ValidSchema imaginarySchema = load(<span class="stringliteral">&quot;imaginary.json&quot;</span>);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160; </div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    std::unique_ptr&lt;avro::OutputStream&gt; out = avro::memoryOutputStream();</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    avro::EncoderPtr e = avro::binaryEncoder();</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;    e-&gt;init(*out);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    c::cpx c1;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;    c1.re = 100.23;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    c1.im = 105.77;</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    avro::encode(*e, c1);</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    std::unique_ptr&lt;avro::InputStream&gt; in = avro::memoryInputStream(*out);</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    avro::DecoderPtr d = avro::resolvingDecoder(cpxSchema, imaginarySchema,</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;                                                avro::binaryDecoder());</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    d-&gt;init(*in);</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; </div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    i::cpx c2;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    avro::decode(*d, c2);</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; c2.im &lt;&lt; std::endl;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div>
</div><!-- fragment --><p>In this example, writer and reader deal with different schemas, both have a record with the name 'cpx'. The writer schema has two fields and the reader's has just one. We generated code for writer's schema in a namespace <code>c</code> and the reader's in <code>i</code>.</p>
<p>Please notice how the reading part of the example at line 60 reads as if the stream contains the data corresponding to its schema. The schema resolution is automatically done by the resolving decoder.</p>
<p>In this example, we have used a simple (somewhat artificial) projection (where the set of fields in the reader's schema is a subset of set of fields in the writer's). But more complex resolutions are allowed by Avro specification.</p>
<h2 id="UsingAvroDataFiles">Using Avro data files <a href="#UsingAvroDataFiles">ยง</a></h2>
<p>Avro specification specifies a format for data files. Avro C++ implements the specification. The code below demonstrates how one can use the Avro data file to store and retrieve a collection of objects corresponding to a given schema.</p>
<p><b>File: datafile.cc</b></p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160; </div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; </div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span></div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;avro/DataFile.hh&quot;</span></div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span></div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;cpx.hh&quot;</span></div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160; </div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;avro::ValidSchema loadSchema(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename) {</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    std::ifstream ifs(filename);</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    avro::ValidSchema result;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;    avro::compileJsonSchema(ifs, result);</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;}</div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; </div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="keywordtype">int</span> main() {</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;    avro::ValidSchema cpxSchema = loadSchema(<span class="stringliteral">&quot;cpx.json&quot;</span>);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; </div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;    {</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        avro::DataFileWriter&lt;c::cpx&gt; dfw(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        c::cpx c1;</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) {</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;            c1.re = i * 100;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;            c1.im = i + 100;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            dfw.write(c1);</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;        }</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        dfw.close();</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    }</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160; </div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    {</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;        avro::DataFileReader&lt;c::cpx&gt; dfr(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;        c::cpx c2;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;        <span class="keywordflow">while</span> (dfr.read(c2)) {</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;            std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        }</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    }</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;}</div>
</div><!-- fragment --><p>Please see DataFile.hh for more details. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
