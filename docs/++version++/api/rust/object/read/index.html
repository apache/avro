<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interface for reading object files."><title>object::read - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="object" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../../static.files/storage-68b7e25d.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../object/index.html">object</a><span class="version">0.36.7</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module read</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#unified-read-api" title="Unified read API">Unified read API</a></li><li><a href="#low-level-read-api" title="Low level read API">Low level read API</a></li><li><a href="#naming-convention" title="Naming Convention">Naming Convention</a></li><li><a href="#example-for-unified-read-api" title="Example for unified read API">Example for unified read API</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate object</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">object</a></div><h1>Module <span>read</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/object/read/mod.rs.html#1-1037">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interface for reading object files.</p>
<h3 id="unified-read-api"><a class="doc-anchor" href="#unified-read-api">§</a>Unified read API</h3>
<p>The <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a> trait provides a unified read API for accessing common features of
object files, such as sections and symbols. There is an implementation of this
trait for <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>, which allows reading any file format, as well as implementations
for each file format:
<a href="elf/struct.ElfFile.html" title="struct object::read::elf::ElfFile"><code>ElfFile</code></a>, <a href="macho/struct.MachOFile.html" title="struct object::read::macho::MachOFile"><code>MachOFile</code></a>, <a href="coff/struct.CoffFile.html" title="struct object::read::coff::CoffFile"><code>CoffFile</code></a>,
<a href="pe/struct.PeFile.html" title="struct object::read::pe::PeFile"><code>PeFile</code></a>, <a href="wasm::WasmFile"><code>WasmFile</code></a>, <a href="xcoff/struct.XcoffFile.html" title="struct object::read::xcoff::XcoffFile"><code>XcoffFile</code></a>.</p>
<h3 id="low-level-read-api"><a class="doc-anchor" href="#low-level-read-api">§</a>Low level read API</h3>
<p>The submodules for each file format define helpers that operate on the raw structs.
These can be used instead of the unified API, or in conjunction with it to access
details that are not available via the unified API.</p>
<p>See the <a href="#modules">submodules</a> for examples of the low level read API.</p>
<h3 id="naming-convention"><a class="doc-anchor" href="#naming-convention">§</a>Naming Convention</h3>
<p>Types that form part of the unified API for a file format are prefixed with the
name of the file format.</p>
<h3 id="example-for-unified-read-api"><a class="doc-anchor" href="#example-for-unified-read-api">§</a>Example for unified read API</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>object::{Object, ObjectSection};
<span class="kw">use </span>std::error::Error;
<span class="kw">use </span>std::fs;

<span class="doccomment">/// Reads a file and displays the name of each section.
</span><span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
   <span class="kw">let </span>data = fs::read(<span class="string">"path/to/binary"</span>)<span class="question-mark">?</span>;
   <span class="kw">let </span>file = object::File::parse(<span class="kw-2">&amp;*</span>data)<span class="question-mark">?</span>;
   <span class="kw">for </span>section <span class="kw">in </span>file.sections() {
       <span class="macro">println!</span>(<span class="string">"{}"</span>, section.name()<span class="question-mark">?</span>);
   }
   <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="archive/index.html" title="mod object::read::archive">archive</a></dt><dd>Support for archive files.</dd><dt><a class="mod" href="coff/index.html" title="mod object::read::coff">coff</a></dt><dd>Support for reading Windows COFF files.</dd><dt><a class="mod" href="elf/index.html" title="mod object::read::elf">elf</a></dt><dd>Support for reading ELF files.</dd><dt><a class="mod" href="macho/index.html" title="mod object::read::macho">macho</a></dt><dd>Support for reading Mach-O files.</dd><dt><a class="mod" href="pe/index.html" title="mod object::read::pe">pe</a></dt><dd>Support for reading PE files.</dd><dt><a class="mod" href="xcoff/index.html" title="mod object::read::xcoff">xcoff</a></dt><dd>Support for reading AIX XCOFF files.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Bytes.html" title="struct object::read::Bytes">Bytes</a></dt><dd>A newtype for byte slices.</dd><dt><a class="struct" href="struct.CodeView.html" title="struct object::read::CodeView">Code<wbr>View</a></dt><dd>PDB information from the debug directory in a PE file.</dd><dt><a class="struct" href="struct.Comdat.html" title="struct object::read::Comdat">Comdat</a></dt><dd>A COMDAT section group in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.ComdatIterator.html" title="struct object::read::ComdatIterator">Comdat<wbr>Iterator</a></dt><dd>An iterator for the COMDAT section groups in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.ComdatSectionIterator.html" title="struct object::read::ComdatSectionIterator">Comdat<wbr>Section<wbr>Iterator</a></dt><dd>An iterator for the sections in a <a href="struct.Comdat.html" title="struct object::read::Comdat"><code>Comdat</code></a>.</dd><dt><a class="struct" href="struct.CompressedData.html" title="struct object::read::CompressedData">Compressed<wbr>Data</a></dt><dd>Data that may be compressed.</dd><dt><a class="struct" href="struct.CompressedFileRange.html" title="struct object::read::CompressedFileRange">Compressed<wbr>File<wbr>Range</a></dt><dd>A range in a file that may be compressed.</dd><dt><a class="struct" href="struct.DynamicRelocationIterator.html" title="struct object::read::DynamicRelocationIterator">Dynamic<wbr>Relocation<wbr>Iterator</a></dt><dd>An iterator for the dynamic relocation entries in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.Error.html" title="struct object::read::Error">Error</a></dt><dd>The error type used within the read module.</dd><dt><a class="struct" href="struct.Export.html" title="struct object::read::Export">Export</a></dt><dd>An exported symbol.</dd><dt><a class="struct" href="struct.Import.html" title="struct object::read::Import">Import</a></dt><dd>An imported symbol.</dd><dt><a class="struct" href="struct.NoDynamicRelocationIterator.html" title="struct object::read::NoDynamicRelocationIterator">NoDynamic<wbr>Relocation<wbr>Iterator</a></dt><dd>An iterator for files that don’t have dynamic relocations.</dd><dt><a class="struct" href="struct.ObjectMap.html" title="struct object::read::ObjectMap">Object<wbr>Map</a></dt><dd>A map from addresses to symbol names and object files.</dd><dt><a class="struct" href="struct.ObjectMapEntry.html" title="struct object::read::ObjectMapEntry">Object<wbr>MapEntry</a></dt><dd>A symbol in an <a href="struct.ObjectMap.html" title="struct object::read::ObjectMap"><code>ObjectMap</code></a>.</dd><dt><a class="struct" href="struct.ObjectMapFile.html" title="struct object::read::ObjectMapFile">Object<wbr>MapFile</a></dt><dd>An object file name in an <a href="struct.ObjectMap.html" title="struct object::read::ObjectMap"><code>ObjectMap</code></a>.</dd><dt><a class="struct" href="struct.ReadCache.html" title="struct object::read::ReadCache">Read<wbr>Cache</a></dt><dd>An implementation of <a href="trait.ReadRef.html" title="trait object::read::ReadRef"><code>ReadRef</code></a> for data in a stream that implements
<code>Read + Seek</code>.</dd><dt><a class="struct" href="struct.ReadCacheRange.html" title="struct object::read::ReadCacheRange">Read<wbr>Cache<wbr>Range</a></dt><dd>An implementation of <a href="trait.ReadRef.html" title="trait object::read::ReadRef"><code>ReadRef</code></a> for a range of data in a stream that
implements <code>Read + Seek</code>.</dd><dt><a class="struct" href="struct.Relocation.html" title="struct object::read::Relocation">Relocation</a></dt><dd>A relocation entry.</dd><dt><a class="struct" href="struct.RelocationMap.html" title="struct object::read::RelocationMap">Relocation<wbr>Map</a></dt><dd>A map from section offsets to relocation information.</dd><dt><a class="struct" href="struct.Section.html" title="struct object::read::Section">Section</a></dt><dd>A section in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.SectionIndex.html" title="struct object::read::SectionIndex">Section<wbr>Index</a></dt><dd>The index used to identify a section in a file.</dd><dt><a class="struct" href="struct.SectionIterator.html" title="struct object::read::SectionIterator">Section<wbr>Iterator</a></dt><dd>An iterator for the sections in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.SectionRelocationIterator.html" title="struct object::read::SectionRelocationIterator">Section<wbr>Relocation<wbr>Iterator</a></dt><dd>An iterator for the relocation entries in a <a href="struct.Section.html" title="struct object::read::Section"><code>Section</code></a>.</dd><dt><a class="struct" href="struct.Segment.html" title="struct object::read::Segment">Segment</a></dt><dd>A loadable segment in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.SegmentIterator.html" title="struct object::read::SegmentIterator">Segment<wbr>Iterator</a></dt><dd>An iterator for the loadable segments in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd><dt><a class="struct" href="struct.StringTable.html" title="struct object::read::StringTable">String<wbr>Table</a></dt><dd>A table of zero-terminated strings.</dd><dt><a class="struct" href="struct.Symbol.html" title="struct object::read::Symbol">Symbol</a></dt><dd>An symbol in a <a href="struct.SymbolTable.html" title="struct object::read::SymbolTable"><code>SymbolTable</code></a>.</dd><dt><a class="struct" href="struct.SymbolIndex.html" title="struct object::read::SymbolIndex">Symbol<wbr>Index</a></dt><dd>The index used to identify a symbol in a symbol table.</dd><dt><a class="struct" href="struct.SymbolIterator.html" title="struct object::read::SymbolIterator">Symbol<wbr>Iterator</a></dt><dd>An iterator for the symbols in a <a href="struct.SymbolTable.html" title="struct object::read::SymbolTable"><code>SymbolTable</code></a>.</dd><dt><a class="struct" href="struct.SymbolMap.html" title="struct object::read::SymbolMap">Symbol<wbr>Map</a></dt><dd>A map from addresses to symbol information.</dd><dt><a class="struct" href="struct.SymbolMapName.html" title="struct object::read::SymbolMapName">Symbol<wbr>MapName</a></dt><dd>The type used for entries in a <a href="struct.SymbolMap.html" title="struct object::read::SymbolMap"><code>SymbolMap</code></a> that maps from addresses to names.</dd><dt><a class="struct" href="struct.SymbolTable.html" title="struct object::read::SymbolTable">Symbol<wbr>Table</a></dt><dd>A symbol table in a <a href="enum.File.html" title="enum object::read::File"><code>File</code></a>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AddressSize.html" title="enum object::read::AddressSize">Address<wbr>Size</a></dt><dd>The size of an address value for an architecture.</dd><dt><a class="enum" href="enum.Architecture.html" title="enum object::read::Architecture">Architecture</a></dt><dd>A CPU architecture.</dd><dt><a class="enum" href="enum.BinaryFormat.html" title="enum object::read::BinaryFormat">Binary<wbr>Format</a></dt><dd>A binary file format.</dd><dt><a class="enum" href="enum.ComdatKind.html" title="enum object::read::ComdatKind">Comdat<wbr>Kind</a></dt><dd>The selection kind for a COMDAT section group.</dd><dt><a class="enum" href="enum.CompressionFormat.html" title="enum object::read::CompressionFormat">Compression<wbr>Format</a></dt><dd>A data compression format.</dd><dt><a class="enum" href="enum.File.html" title="enum object::read::File">File</a></dt><dd>An object file that can be any supported file format.</dd><dt><a class="enum" href="enum.FileFlags.html" title="enum object::read::FileFlags">File<wbr>Flags</a></dt><dd>File flags that are specific to each file format.</dd><dt><a class="enum" href="enum.FileKind.html" title="enum object::read::FileKind">File<wbr>Kind</a></dt><dd>A file format kind.</dd><dt><a class="enum" href="enum.ObjectKind.html" title="enum object::read::ObjectKind">Object<wbr>Kind</a></dt><dd>An object kind.</dd><dt><a class="enum" href="enum.RelocationEncoding.html" title="enum object::read::RelocationEncoding">Relocation<wbr>Encoding</a></dt><dd>Information about how the result of the relocation operation is encoded in the place.</dd><dt><a class="enum" href="enum.RelocationFlags.html" title="enum object::read::RelocationFlags">Relocation<wbr>Flags</a></dt><dd>Relocation fields that are specific to each file format and architecture.</dd><dt><a class="enum" href="enum.RelocationKind.html" title="enum object::read::RelocationKind">Relocation<wbr>Kind</a></dt><dd>The operation used to calculate the result of the relocation.</dd><dt><a class="enum" href="enum.RelocationTarget.html" title="enum object::read::RelocationTarget">Relocation<wbr>Target</a></dt><dd>The target referenced by a <a href="struct.Relocation.html" title="struct object::read::Relocation"><code>Relocation</code></a>.</dd><dt><a class="enum" href="enum.SectionFlags.html" title="enum object::read::SectionFlags">Section<wbr>Flags</a></dt><dd>Section flags that are specific to each file format.</dd><dt><a class="enum" href="enum.SectionKind.html" title="enum object::read::SectionKind">Section<wbr>Kind</a></dt><dd>The kind of a section.</dd><dt><a class="enum" href="enum.SegmentFlags.html" title="enum object::read::SegmentFlags">Segment<wbr>Flags</a></dt><dd>Segment flags that are specific to each file format.</dd><dt><a class="enum" href="enum.SubArchitecture.html" title="enum object::read::SubArchitecture">SubArchitecture</a></dt><dd>A CPU sub-architecture.</dd><dt><a class="enum" href="enum.SymbolFlags.html" title="enum object::read::SymbolFlags">Symbol<wbr>Flags</a></dt><dd>Symbol flags that are specific to each file format.</dd><dt><a class="enum" href="enum.SymbolKind.html" title="enum object::read::SymbolKind">Symbol<wbr>Kind</a></dt><dd>The kind of a symbol.</dd><dt><a class="enum" href="enum.SymbolScope.html" title="enum object::read::SymbolScope">Symbol<wbr>Scope</a></dt><dd>A symbol scope.</dd><dt><a class="enum" href="enum.SymbolSection.html" title="enum object::read::SymbolSection">Symbol<wbr>Section</a></dt><dd>The section where an <a href="trait.ObjectSymbol.html" title="trait object::read::ObjectSymbol"><code>ObjectSymbol</code></a> is defined.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Object.html" title="trait object::read::Object">Object</a></dt><dd>An object file.</dd><dt><a class="trait" href="trait.ObjectComdat.html" title="trait object::read::ObjectComdat">Object<wbr>Comdat</a></dt><dd>A COMDAT section group in an <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a>.</dd><dt><a class="trait" href="trait.ObjectSection.html" title="trait object::read::ObjectSection">Object<wbr>Section</a></dt><dd>A section in an <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a>.</dd><dt><a class="trait" href="trait.ObjectSegment.html" title="trait object::read::ObjectSegment">Object<wbr>Segment</a></dt><dd>A loadable segment in an <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a>.</dd><dt><a class="trait" href="trait.ObjectSymbol.html" title="trait object::read::ObjectSymbol">Object<wbr>Symbol</a></dt><dd>A symbol table entry in an <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a>.</dd><dt><a class="trait" href="trait.ObjectSymbolTable.html" title="trait object::read::ObjectSymbolTable">Object<wbr>Symbol<wbr>Table</a></dt><dd>A symbol table in an <a href="trait.Object.html" title="trait object::read::Object"><code>Object</code></a>.</dd><dt><a class="trait" href="trait.ReadCacheOps.html" title="trait object::read::ReadCacheOps">Read<wbr>Cache<wbr>Ops</a></dt><dd>Operations required to implement <a href="struct.ReadCache.html" title="struct object::read::ReadCache"><code>ReadCache</code></a>.</dd><dt><a class="trait" href="trait.ReadRef.html" title="trait object::read::ReadRef">ReadRef</a></dt><dd>A trait for reading references to <a href="../pod/trait.Pod.html" title="trait object::pod::Pod"><code>Pod</code></a> types from a block of data.</dd><dt><a class="trait" href="trait.SymbolMapEntry.html" title="trait object::read::SymbolMapEntry">Symbol<wbr>MapEntry</a></dt><dd>An entry in a <a href="struct.SymbolMap.html" title="struct object::read::SymbolMap"><code>SymbolMap</code></a>.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.NativeFile.html" title="type object::read::NativeFile">Native<wbr>File</a></dt><dd>The native executable file for the target platform.</dd><dt><a class="type" href="type.Result.html" title="type object::read::Result">Result</a></dt><dd>The result type used within the read module.</dd></dl></section></div></main></body></html>