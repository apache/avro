searchState.loadedDescShard("miniz_oxide", 0, "A pure rust replacement for the miniz DEFLATE/zlib …\nNot implemented.\nBuffer-related error.\nError in inflation; see <code>inflate::stream::inflate()</code> for …\nHow compressed data is wrapped.\nContains the error value\nUnused\nAttempt to flush the remaining data and end the stream.\nSame as <code>Sync</code>, but resets the compression dictionary so …\nA list of miniz failed status codes.\nA list of flush types.\n<code>Result</code> alias for all miniz status codes both successful …\nA list of miniz successful status codes.\nUnused\nUnused\nDon’t force any flushing. Used when more input data is …\nContains the success value\nOperation succeeded.\nBad parameters.\nZlib partial flush. Currently treated as <code>Sync</code>.\nRaw DEFLATE.\nGeneral stream error.\nOperation succeeded and end of deflate stream was found.\nA structure containing the result of a call to the inflate …\nFinish compressing the currently buffered data, and output …\nUnused\nZlib wrapped but ignore and don’t compute the adler32 …\nWrapped using the zlib format.\nThe number of bytes consumed from the input slice.\nThe number of bytes written to the output slice.\nThis module contains functionality for compression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis module contains functionality for decompression.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an MZFlush value from an integer value.\nThe return status of the call.\nSlow/high compression. Do a lot of checks to try to find …\nFast compression. Uses a special compression routine that …\nHow much processing the compressor should do to compress …\nUse the default compression level.\nDefault compromise between speed and compression.\nDon’t do any compression, only output uncompressed …\nEven more checks, can be very slow.\nCompress the input data to a vector, using the specified …\nCompress the input data to a vector, using the specified …\nStreaming compression functionality.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nExtra streaming compression functionality.\nUsage error.\nCallback function and user used in <code>compress_to_output</code>.\nStrategy setting for compression.\nMain compression struct.\nDon’t use any of the special strategies.\nCompression succeeded and the deflate stream was ended.\nOnly use matches that are at least 5 bytes long.\nTry to flush everything and end the deflate stream.\nOnly use static/fixed blocks. (Blocks using the default …\nSame as <code>Sync</code>, but reset the dictionary so that the …\nDon’t look for matches, only huffman encode the literals.\nNormal operation.\nCompression succeeded normally.\nError putting data into output buffer.\nOnly look for matches with a distance of 1, i.e do …\nTry to flush all the current data and output an empty raw …\nA list of deflate flush types.\nReturn status of compression.\nGet the adler32 checksum of the currently encoded data.\nMain compression function. Tries to compress as much as …\nMain compression function. Callbacks output.\nCreate a set of compression flags using parameters used by …\nReturns whether the compressor is wrapping the data in a …\nInitialize the compressor with a level of 4, zlib wrapper …\nGet the raw compressor flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new <code>CompressorOxide</code> with the given flags.\nGet the return status of the previous <code>compress</code> call with …\nReset the state of the compressor, keeping the same …\nSet the compression level of the compressor.\nSet the compression level of the compressor using an …\nUpdate the compression settings of the compressor.\nShould we compute the adler32 checksum.\nOnly use matches that are at least 6 bytes long.\nForce the compressor to only output raw/uncompressed …\nForce the compressor to only output static blocks. (Blocks …\nShould we use greedy parsing (as opposed to lazy parsing …\nUsed in miniz to skip zero-initializing hash and dict. We …\nOnly look for matches with a distance of 0.\nWhether to use a zlib wrapper.\nTry to compress from input to output with the given …\nThe decompression went fine, but the adler32 checksum did …\nThe output buffer is an invalid size; consider the <code>flags</code> …\nStruct return when decompress_to_vec functions fail.\nFinished decompression without issues.\nFailed to decompress due to invalid data.\nMore input data was expected, but the caller indicated …\nThere is still pending data that didn’t fit in the …\nThe decompressor needs more input data to continue …\nReturn status codes.\nStreaming decompression functionality.\nDecompress one or more source slices from an iterator into …\nDecompress the deflate-encoded data in <code>input</code> to a vector.\nDecompress the deflate-encoded data in <code>input</code> to a vector.\nDecompress the deflate-encoded data (with a zlib wrapper) …\nDecompress the deflate-encoded data (with a zlib wrapper) …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe currently decompressed data if any.\nDecompressor status on failure. See TINFLStatus for …\nExtra streaming decompression functionality.\nMain decompression struct.\nReturns the adler32 checksum of the currently decompressed …\nReturns the adler32 that was read from the zlib header if …\nMain decompression function. Keeps decompressing data from …\nCreate a new tinfl_decompressor with all fields set to 0.\nReturns the argument unchanged.\nFlags to <code>decompress()</code> to control how inflation works.\nSet the current state to <code>Start</code>.\nCalls <code>U::from(self)</code>.\nCreate a new tinfl_decompressor with all fields set to 0.\nCalculate the adler32 checksum of the output data even if …\nThere will be more input that hasn’t been given to the …\nIgnore adler32 checksum even if we are inflating a zlib …\nShould we try to parse a zlib header?\nThe output buffer should not wrap around.\nFull reset of the state, including zeroing memory.\nA struct that compbines a decompressor with extra data for …\nResets state, without performing expensive ops (e.g. …\nTag that determines reset policy of InflateState\nResets state and zero memory, continuing to use the same …\nAccess the innner decompressor.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTry to decompress from <code>input</code> to <code>output</code> with the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn the status of the last call to <code>inflate</code> with this …\nCreate a new state.\nCreate a new state on the heap.\nCreate a new state using miniz/zlib style window bits …\nPerforms reset\nReset the decompressor without re-allocating memory, using …\nResets the state according to specified policy.")