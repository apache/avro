<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Avro C#: Namespace Avro.Reflect</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Avro C#
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Namespace Avro.Reflect</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> This namespace contains classes that implement <a class="el" href="namespaceAvro.html">Avro</a> serialization and deserialization for plain C# objects. The classes use .net reflection to implement the serializers. The interface is similar to the Generic and Specific serialization classes.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Serialization</h1>
<p>The approach starts with the schema and iterates both the schema and the dotnet type together in a depth first manner per the specification. Serialization is the same as the Generic serializer except where the serializer encounters:</p><ul>
<li><em>A fixed type</em>: if the corresponding dotnet object type is a byte[] of the correct length then the object is serialized, otherwise an exception is thrown.</li>
<li><em>A record type</em>: the serializer matches the schema property name to the dotnet object property name and then recursively serializes the schema property and the dotnet object property</li>
<li><em>An array type</em>: See array serialization/deserialization.</li>
</ul>
<p>Basic serialization is performed as in the following example:</p>
<div class="fragment"><div class="line">Schema schema; <span class="comment">// created previously</span></div>
<div class="line">T myObject; <span class="comment">// created previously</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">var avroWriter = <span class="keyword">new</span> ReflectWriter&lt;T&gt;(schema);</div>
<div class="line"><span class="keyword">using</span> (var stream = <span class="keyword">new</span> MemoryStream(256))</div>
<div class="line">{</div>
<div class="line">    avroWriter.Write(myObject, <span class="keyword">new</span> BinaryEncoder(stream));</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Deserialization</h1>
<p>Deserialization proceeds in much the same fashion as serialization. When required objects are created. By default this is with: </p><div class="fragment"><div class="line">Activator.CreateInstance(x);</div>
</div><!-- fragment --><p> however this can be overridden by setting the deserializer property RecordFactory. </p><div class="fragment"><div class="line"><span class="keyword">public</span> Func&lt;Type, object&gt; RecordFactory {<span class="keyword">get</span>;<span class="keyword">set</span>;}</div>
</div><!-- fragment --><p> You might want to do this if your class contains interfaces and/or if you use an IoC container.</p>
<p>See the section on Arrays. The ArrayHelper specifies the type of object created when an array is deserialized. The default is List&lt;T&gt;.</p>
<p>The type created for Map objects is specified by the Deserializer property MapType. <em>This must be a two (or more) parameter generic type where the first type parameter is string and the second is undefined</em> e.g. Dictionary&lt;string,&gt;. </p><div class="fragment"><div class="line"><span class="keyword">public</span> Type MapType { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
</div><!-- fragment --><p> By default the MapType is Dictionary&lt;string,&gt; </p><div class="fragment"><div class="line">Basic deserialization is performed as in the following example:</div>
</div><!-- fragment --><p> csharp Schema schema; // created previously</p>
<p>// using same writer and reader schema in this example. var avroReader = new ReflectReader&lt;T&gt;(schema, schema);</p>
<p>using (var stream = new MemoryStream(serialized)) { deserialized = avroReader.Read(null, new BinaryDecoder(stream)); } </p><div class="fragment"><div class="line">## Class cache</div>
<div class="line"> </div>
<div class="line">The dotnet reflection libraries can add an amount of performance overhead. Efforts are made to minimize this by supporting a cache of class details obtained by reflection (PropertyInfo objects) so that property value lookups can be performed quickly and with as little overhead as possible. </div>
<div class="line"> </div>
<div class="line">The class cache can be created separately from the serializer/deserializer and reused.</div>
</div><!-- fragment --><p> csharp var cache = new ClassCache(); var writer = new ReflectWriter&lt;MultiList&gt;(schema, cache); var reader = new ReflectReader&lt;MultiList&gt;(schema, schema, cache); </p><div class="fragment"><div class="line">The class cache is also used with default type conversions and with array serialization and deserialization.</div>
<div class="line"> </div>
<div class="line">## Converters</div>
<div class="line"> </div>
<div class="line">Converters are classes that convert to and from Avro primitive types and dotnet types. An example of where converters are used is to convert between dotnet DateTimeOffet object and the chosen Avro primitive. </div>
<div class="line"> </div>
<div class="line">Converters are implemented by inheriting from TypedFieldConverter&lt;byte[],GenericFixed&gt;, or creating an object of type FuncFieldConverter&lt;A,T&gt;.</div>
<div class="line"> </div>
<div class="line">_Example TypedFieldConverter_:</div>
</div><!-- fragment --><p> csharp public class GenericFixedConverter : TypedFieldConverter&lt;byte[],GenericFixed&gt; { public override GenericFixed From(byte[] o, Schema s) { return new GenericFixed(s as FixedSchema, o); }</p>
<p>public override byte[] To(GenericFixed o, Schema s) { return o.Value; } } </p><div class="fragment"><div class="line">### Specifying Converters in Attributes</div>
</div><!-- fragment --><p> csharp public class LogMessage { </p><pre class="fragment">[AvroField(typeof(DateTimeOffsetToLongConverter))]
public DateTimeOffset TimeStamp { get; set; }
</pre><p> } </p><div class="fragment"><div class="line">### Default Converters</div>
<div class="line"> </div>
<div class="line">Default converters are defined to convert between an Avro primitive and C# type without explicitly defining the converter for a field. Default converters are static and are registered with the class cache.</div>
</div><!-- fragment --><p> csharp ClassCache.AddDefaultConverter&lt;byte[], GenericFixed&gt;((a,s)=&gt;new GenericFixed(s as FixedSchema, a), (p,s)=&gt;p.Value); var writer = new ReflectWriter&lt;GenericFixedRec&gt;(schema); var reader = new ReflectReader&lt;GenericFixedRec&gt;(schema, schema);</p>
<div class="fragment"><div class="line">## Attributes</div>
<div class="line"> </div>
<div class="line">The AvroField attribute can be used to defined field converters or to change the name of the dotnet property (or both).</div>
</div><!-- fragment --><p> csharp public class LogMessage { [AvroField("message")] public string Message { get; set; }</p>
<p>[AvroField(typeof(DateTimeOffsetToLongConverter))] public DateTimeOffset TimeStamp { get; set; } } </p><div class="fragment"><div class="line">## Arrays</div>
<div class="line"> </div>
<div class="line">By default the reflect code will serialize and deserialized between Avro arrays and classes that implement IList. Classes that implement IEnumerable but do not implement IList can be handled by implementing an ArrayHelper class. The array helper provides a standard interface for a number of methods needed for serialization and deserialization but which are not supported by IEnumerable.</div>
<div class="line"> </div>
<div class="line">An additional metadata called &quot;helper&quot; is required in the schema. This acts like the name of a record type and is used to associate a helper with a particular schema array. </div>
<div class="line"> </div>
<div class="line">_Example_: ConcurrentQueue</div>
</div><!-- fragment --><p> csharp </p><pre class="fragment">public class ConcurrentQueueHelper&lt;T&gt; : ArrayHelper
{
    public override int Count()
    {
        ConcurrentQueue&lt;T&gt; e = (ConcurrentQueue&lt;T&gt;)Enumerable;
        return e.Count;
    }

    public override void Add(object o)
    {
        ConcurrentQueue&lt;T&gt; e = (ConcurrentQueue&lt;T&gt;)Enumerable;
        e.Enqueue((T)o);
    }

    public override void Clear()
    {
        ConcurrentQueue&lt;T&gt; e = (ConcurrentQueue&lt;T&gt;)Enumerable;
</pre><p> #if NET461 while (e.TryDequeue(out _)) { } #else e.Clear(); #endif }</p>
<p>public override Type ArrayType { get =&gt; typeof(ConcurrentQueue&lt;&gt;); }</p>
<p>public ConcurrentQueueHelper(IEnumerable enumerable) : base(enumerable) { Enumerable = enumerable; } }</p>
<p>string recordList = " { ""type"": ""array"", ""helper"": ""recordListQueue"", ""items"": ""string"" }"

    // using the helper

    var schema = Schema.Parse(recordList);
    var fixedRecWrite = new ConcurrentQueue&lt;string&gt;();

    var cache = new ClassCache();
    cache.AddArrayHelper("recordListQueue", typeof(ConcurrentQueueHelper&lt;string&gt;));

    var writer = new ReflectWriter&lt;ConcurrentQueue&lt;ConcurrentQueueRec&gt;&gt;(schema, cache);
    var reader = new ReflectReader&lt;ConcurrentQueue&lt;ConcurrentQueueRec&gt;&gt;(schema, schema, cache);

@icode 
## Unions

All union constructs are supported however record types that are first defined in unions may need manual type registration.

### Automatic Type Registration

Types associated with unions of this form can be automatically registered and no special handling is needed.

@endicode json
    ["null", { "type": "record", "name": "X"}]
@icode 

_Example_: 

@endicode csharp
    public class MyClass
    {
        public string A { get; set; }
        public double C { get; set; }
    }

    // ...

    var nullableSchema = @" [ ""null"", { ""type"" : ""record"", ""name"" : ""Dervied2"", ""fields"" : [ { ""name"" : ""A"", ""type"" : ""string""}, { ""name"" : ""C"", ""type"" : ""double""} ] },</p>
<p>] ";
    var schema = Schema.Parse(nullableSchema);
    var derived2write = new MyClass() { A = "derived2", C = 3.14 };

    var writer = new ReflectWriter&lt;MyClass&gt;(schema);
    var reader = new ReflectReader&lt;MyClass&gt;(schema, schema);

    // etc.
@icode 

### Manual Registration

Where a record type is defined inside a union and the union does not 
follow the "nullable construct" above, the CSharp type and schema need to be manually registered. Registration is done using the ClassCache method LoadClassCache.

@endicode csharp
    cache.LoadClassCache(typeof(MyClass), recordSchema);
@icode 

Note that the `recordSchema` used here is the schema corresponding to the `MyClass` type within the overall union schema. See the example below.

@endicode csharp
        public class BaseClass
        {
            public string A { get; set; }
        }

        public class Derived1 : BaseClass
        {
            public int B { get; set; }
        }

        public class Derived2 : BaseClass
        {
            public double C { get; set; }
        }

        public void SerializeExample()
        {
            var baseClassSchema = @" [ { ""type"" : ""record"", ""name"" : ""Dervied1"", ""fields"" : [ { ""name"" : ""A"", ""type"" : ""string""}, { ""name"" : ""B"", ""type"" : ""int""} ] }, { ""type"" : ""record"", ""name"" : ""Dervied2"", ""fields"" : [ { ""name"" : ""A"", ""type"" : ""string""}, { ""name"" : ""C"", ""type"" : ""double""} ] },</p>
<p>] ";

            var schema = Schema.Parse(baseClassSchema);
            var derived1write = new Derived1() { A = "derived1", B = 7 };
            var derived2write = new Derived2() { A = "derived2", C = 3.14 };</p>
<p>// union types (except for [null, type]) need to be manually registered var unionSchema = schema as UnionSchema; var cache = new ClassCache(); cache.LoadClassCache(typeof(Derived1), unionSchema[0]); cache.LoadClassCache(typeof(Derived2), unionSchema[1]); var x = schema as RecordSchema;</p>
<p>var writer = new ReflectWriter&lt;BaseClass&gt;(schema, cache); var reader = new ReflectReader&lt;BaseClass&gt;(schema, schema, cache);</p>
<p>using (var stream = new MemoryStream(256)) { var encoder = new BinaryEncoder(stream); writer.Write(derived1write, encoder); writer.Write(derived2write, encoder); stream.Seek(0, SeekOrigin.Begin);</p>
<p>var decoder = new BinaryDecoder(stream); var derived1read = (Derived1)reader.Read(decoder); var derived2read = (Derived2)reader.Read(decoder); } } ``` </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
