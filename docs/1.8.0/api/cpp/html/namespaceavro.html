<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Avro C++: avro Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">avro Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A bunch of templates and specializations for encoding and decoding specific types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceavro_1_1concepts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>
<tr class="memdesc:namespaceavro_1_1concepts"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node. ">NodeImpl</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits.html">codec_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec_traits tells avro how to encode and decode an object of given type.  <a href="structavro_1_1codec__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01bool_01_4.html">codec_traits&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro boolean.  <a href="structavro_1_1codec__traits_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01boost_1_1array_3_01uint8__t_00_01N_01_4_01_4.html">codec_traits&lt; boost::array&lt; uint8_t, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro fixed.  <a href="structavro_1_1codec__traits_3_01boost_1_1array_3_01uint8__t_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01double_01_4.html">codec_traits&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro double.  <a href="structavro_1_1codec__traits_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01float_01_4.html">codec_traits&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro float.  <a href="structavro_1_1codec__traits_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html">codec_traits&lt; GenericDatum &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for <a class="el" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type. ">GenericDatum</a>.  <a href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int32__t_01_4.html">codec_traits&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro int.  <a href="structavro_1_1codec__traits_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int64__t_01_4.html">codec_traits&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro long.  <a href="structavro_1_1codec__traits_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html">codec_traits&lt; std::map&lt; std::string, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro maps.  <a href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html">codec_traits&lt; std::pair&lt; ValidSchema, GenericDatum &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Generic datum along with its schema.  <a href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html">codec_traits&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro string.  <a href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html">codec_traits&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro arrays.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html">codec_traits&lt; std::vector&lt; uint8_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a> for Avro bytes.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReader.html">DataFileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of data file one after another.  <a href="classavro_1_1DataFileReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReaderBase.html">DataFileReaderBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type independent portion of rader.  <a href="classavro_1_1DataFileReaderBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriter.html">DataFileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Avro datafile that can store objects of type T.  <a href="classavro_1_1DataFileWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriterBase.html">DataFileWriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-independent portion of <a class="el" href="classavro_1_1DataFileWriter.html" title="An Avro datafile that can store objects of type T. ">DataFileWriter</a>.  <a href="classavro_1_1DataFileWriterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html">Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data. ">Decoder</a> is an interface implemented by every decoder capable of decoding Avro data.  <a href="classavro_1_1Decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Encoder.html">Encoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for all Avro encoders.  <a href="classavro_1_1Encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericArray.html">GenericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro arrays.  <a href="classavro_1_1GenericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericContainer.html">GenericContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all generic type for containers.  <a href="classavro_1_1GenericContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericDatum.html">GenericDatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic datum which can hold any Avro type.  <a href="classavro_1_1GenericDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericEnum.html">GenericEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro enum.  <a href="classavro_1_1GenericEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericFixed.html">GenericFixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro fixed.  <a href="classavro_1_1GenericFixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericMap.html">GenericMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro maps.  <a href="classavro_1_1GenericMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericReader.html">GenericReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to read generic datum from decoders.  <a href="classavro_1_1GenericReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericRecord.html">GenericRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro records.  <a href="classavro_1_1GenericRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericUnion.html">GenericUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for unions.  <a href="classavro_1_1GenericUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericWriter.html">GenericWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to write generic datum to encoders.  <a href="classavro_1_1GenericWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputStream.html">InputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy input stream.  <a href="classavro_1_1InputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Name.html">Name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees. ">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees. ">Node</a>.  <a href="classavro_1_1NodeImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">define a type to identify <a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions ">Null</a> in template functions  <a href="structavro_1_1Null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullValidator.html">NullValidator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputStream.html">OutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy output stream.  <a href="classavro_1_1OutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses from an avro encoding to the requested type.  <a href="classavro_1_1ReaderImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a> is derived from <a class="el" href="classavro_1_1Decoder.html">Decoder</a>, with an additional function to obtain the field ordering of fiedls within a record.  <a href="classavro_1_1ResolvingDecoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly. ">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a Writer or ValidatingWriter with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamReader.html">StreamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for reading from an <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a>.  <a href="structavro_1_1StreamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamWriter.html">StreamWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convinience class to write data into an <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a>.  <a href="structavro_1_1StreamWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolicSchema.html">SymbolicSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly. ">Schema</a> that has passed some minumum of sanity checks.  <a href="classavro_1_1ValidSchema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for writing avro data to a stream.  <a href="classavro_1_1WriterImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aee87abbccf24444198442e0ae2a9b01b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee87abbccf24444198442e0ae2a9b01b"></a>
typedef boost::array&lt; uint8_t, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aee87abbccf24444198442e0ae2a9b01b">DataFileSync</a></td></tr>
<tr class="memdesc:aee87abbccf24444198442e0ae2a9b01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sync value. <br /></td></tr>
<tr class="separator:aee87abbccf24444198442e0ae2a9b01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409dd1e501d982d3828c65ddf69b68b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a409dd1e501d982d3828c65ddf69b68b7"></a>
typedef boost::shared_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1Decoder.html">Decoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a></td></tr>
<tr class="memdesc:a409dd1e501d982d3828c65ddf69b68b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data. ">Decoder</a>. <br /></td></tr>
<tr class="separator:a409dd1e501d982d3828c65ddf69b68b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16ed8c1d8bb7c68f40d2cd753a0a1b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac16ed8c1d8bb7c68f40d2cd753a0a1b7"></a>
typedef boost::shared_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a></td></tr>
<tr class="memdesc:ac16ed8c1d8bb7c68f40d2cd753a0a1b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a>. <br /></td></tr>
<tr class="separator:ac16ed8c1d8bb7c68f40d2cd753a0a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74279cf96c71ffd8f18d005c32ab8073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74279cf96c71ffd8f18d005c32ab8073"></a>
typedef boost::shared_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1Encoder.html">Encoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a></td></tr>
<tr class="memdesc:a74279cf96c71ffd8f18d005c32ab8073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders. ">Encoder</a>. <br /></td></tr>
<tr class="separator:a74279cf96c71ffd8f18d005c32ab8073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c572cb71b20e20e429257209a42f91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c572cb71b20e20e429257209a42f91"></a>
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b></td></tr>
<tr class="separator:a53c572cb71b20e20e429257209a42f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8add0ad4d31ac7bd6baf95a10ea75254"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8add0ad4d31ac7bd6baf95a10ea75254"></a>
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak" />
&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoName</b></td></tr>
<tr class="separator:a8add0ad4d31ac7bd6baf95a10ea75254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610df85391dab7ced3d430c5cb3e8fee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610df85391dab7ced3d430c5cb3e8fee"></a>
typedef <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak" />
&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HasName</b></td></tr>
<tr class="separator:a610df85391dab7ced3d430c5cb3e8fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85148fbeb2b2e17c9ad5bc357f16aff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85148fbeb2b2e17c9ad5bc357f16aff"></a>
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak" />
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b></td></tr>
<tr class="separator:ac85148fbeb2b2e17c9ad5bc357f16aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf21198637dd41d9099615f32854c7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cf21198637dd41d9099615f32854c7"></a>
typedef <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak" />
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b></td></tr>
<tr class="separator:a71cf21198637dd41d9099615f32854c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd609b669d85b5209ccbc21cd8ef8945"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd609b669d85b5209ccbc21cd8ef8945"></a>
typedef <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak" />
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b></td></tr>
<tr class="separator:afd609b669d85b5209ccbc21cd8ef8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6da0159d149557988b1a7e40773d9b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6da0159d149557988b1a7e40773d9b"></a>
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak" />
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b></td></tr>
<tr class="separator:a5b6da0159d149557988b1a7e40773d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa436fd2c922cd09d74494180f669e034"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa436fd2c922cd09d74494180f669e034"></a>
typedef <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak" />
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b></td></tr>
<tr class="separator:aa436fd2c922cd09d74494180f669e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfce3e38687f7603287dd60dc271252"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfce3e38687f7603287dd60dc271252"></a>
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak" />
&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoSize</b></td></tr>
<tr class="separator:aecfce3e38687f7603287dd60dc271252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46fa86efe35f9ecda21bb1849da70f05"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fa86efe35f9ecda21bb1849da70f05"></a>
typedef <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HasSize</b></td></tr>
<tr class="separator:a46fa86efe35f9ecda21bb1849da70f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea022243932db4fd5cf9d387644bb6ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea022243932db4fd5cf9d387644bb6ce"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b></td></tr>
<tr class="separator:aea022243932db4fd5cf9d387644bb6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0020a7a6d3590c6e20305780e1f8105"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0020a7a6d3590c6e20305780e1f8105"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b></td></tr>
<tr class="separator:ae0020a7a6d3590c6e20305780e1f8105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095db2b00faf42c54eff9ddca916f664"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095db2b00faf42c54eff9ddca916f664"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b></td></tr>
<tr class="separator:a095db2b00faf42c54eff9ddca916f664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c214009072cd60af44ebc912d3c72b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c214009072cd60af44ebc912d3c72b"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b></td></tr>
<tr class="separator:a94c214009072cd60af44ebc912d3c72b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c70cd3863feee6699197aab1dac75"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c70cd3863feee6699197aab1dac75"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b></td></tr>
<tr class="separator:aa04c70cd3863feee6699197aab1dac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f276e8d8fd426534c06c8b351780e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f276e8d8fd426534c06c8b351780e7"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b></td></tr>
<tr class="separator:a88f276e8d8fd426534c06c8b351780e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4e7bbdf8250ea8481e5e6222e57918"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4e7bbdf8250ea8481e5e6222e57918"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b></td></tr>
<tr class="separator:a1c4e7bbdf8250ea8481e5e6222e57918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c3e3db25d7e71e41742bb70eaea2db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c3e3db25d7e71e41742bb70eaea2db"></a>
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak" />
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b></td></tr>
<tr class="separator:ad7c3e3db25d7e71e41742bb70eaea2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d357bce9a8329f8b4f52bb5b7e366"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace6d357bce9a8329f8b4f52bb5b7e366"></a>
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b></td></tr>
<tr class="separator:ace6d357bce9a8329f8b4f52bb5b7e366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20de889520d0e7006b1c83aad1fc929"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20de889520d0e7006b1c83aad1fc929"></a>
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingReader</b></td></tr>
<tr class="separator:ae20de889520d0e7006b1c83aad1fc929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a5fe95b057b10bdad444b383bf556b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a5fe95b057b10bdad444b383bf556b"></a>
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Writer</b></td></tr>
<tr class="separator:a50a5fe95b057b10bdad444b383bf556b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c844697fdbee2981c59c5c32acd054"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c844697fdbee2981c59c5c32acd054"></a>
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingWriter</b></td></tr>
<tr class="separator:a86c844697fdbee2981c59c5c32acd054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a348c1fae0c6b9d7524b00be30a2746b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a348c1fae0c6b9d7524b00be30a2746b2">Codec</a> { <b>NULL_CODEC</b>, 
<b>DEFLATE_CODEC</b>
 }</td></tr>
<tr class="memdesc:a348c1fae0c6b9d7524b00be30a2746b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify type of compression to use when writing data files.  <a href="namespaceavro.html#a348c1fae0c6b9d7524b00be30a2746b2">More...</a><br /></td></tr>
<tr class="separator:a348c1fae0c6b9d7524b00be30a2746b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17da92a723dce9b89e7c845749615b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br />
&#160;&#160;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br />
&#160;&#160;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br />
 }</td></tr>
<tr class="separator:ad17da92a723dce9b89e7c845749615b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e528c3fe1cb5660067a02721fae0b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> { <br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09">AVRO_BYTES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3">AVRO_INT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340">AVRO_LONG</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8">AVRO_FLOAT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">AVRO_DOUBLE</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2">AVRO_BOOL</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff">AVRO_NULL</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597">AVRO_ENUM</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb">AVRO_ARRAY</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c">AVRO_MAP</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9">AVRO_UNION</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7">AVRO_FIXED</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129">AVRO_SYMBOLIC</a> = AVRO_NUM_TYPES, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c">AVRO_UNKNOWN</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a29e528c3fe1cb5660067a02721fae0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "type" for the schema.  <a href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">More...</a><br /></td></tr>
<tr class="separator:a29e528c3fe1cb5660067a02721fae0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0180913cf37820fd8c10a35af371945c"><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:a0180913cf37820fd8c10a35af371945c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr class="memdesc:a0180913cf37820fd8c10a35af371945c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main parse entry point function.  <a href="#a0180913cf37820fd8c10a35af371945c">More...</a><br /></td></tr>
<tr class="separator:a0180913cf37820fd8c10a35af371945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d3c0e0c943565a98085d3e2d195196"><td class="memTemplParams" colspan="2"><a class="anchor" id="a71d3c0e0c943565a98085d3e2d195196"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71d3c0e0c943565a98085d3e2d195196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr class="separator:a71d3c0e0c943565a98085d3e2d195196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d738c814577420a7f84377be6912555"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d738c814577420a7f84377be6912555"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:a4d738c814577420a7f84377be6912555"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4d738c814577420a7f84377be6912555">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr class="memdesc:a4d738c814577420a7f84377be6912555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br /></td></tr>
<tr class="separator:a4d738c814577420a7f84377be6912555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576812f2f2731e4e6569df149a6c4a54"><td class="memTemplParams" colspan="2"><a class="anchor" id="a576812f2f2731e4e6569df149a6c4a54"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:a576812f2f2731e4e6569df149a6c4a54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr class="separator:a576812f2f2731e4e6569df149a6c4a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274e8f2e3a165ff45bf932a82127fc78"><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a274e8f2e3a165ff45bf932a82127fc78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a274e8f2e3a165ff45bf932a82127fc78">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr class="memdesc:a274e8f2e3a165ff45bf932a82127fc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main serializer entry point function.  <a href="#a274e8f2e3a165ff45bf932a82127fc78">More...</a><br /></td></tr>
<tr class="separator:a274e8f2e3a165ff45bf932a82127fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e711b20e43db4ee5051375680f2d5fb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e711b20e43db4ee5051375680f2d5fb"></a>
template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a5e711b20e43db4ee5051375680f2d5fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a5e711b20e43db4ee5051375680f2d5fb">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr class="memdesc:a5e711b20e43db4ee5051375680f2d5fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br /></td></tr>
<tr class="separator:a5e711b20e43db4ee5051375680f2d5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c14823127aff747cc83e6714de9e31"><td class="memItemLeft" align="right" valign="top">AVRO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a31c14823127aff747cc83e6714de9e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object.  <a href="#a31c14823127aff747cc83e6714de9e31">More...</a><br /></td></tr>
<tr class="separator:a31c14823127aff747cc83e6714de9e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb7c42622aad8310cffa013c022d14"><td class="memItemLeft" align="right" valign="top">AVRO_DECL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a23cb7c42622aad8310cffa013c022d14">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr class="memdesc:a23cb7c42622aad8310cffa013c022d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="#a23cb7c42622aad8310cffa013c022d14">More...</a><br /></td></tr>
<tr class="separator:a23cb7c42622aad8310cffa013c022d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1694b4608e27e3a3f82c41f943fc4be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1694b4608e27e3a3f82c41f943fc4be"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromStream</b> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;is)</td></tr>
<tr class="separator:ae1694b4608e27e3a3f82c41f943fc4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa891ce6908de70fac5b1a55d44b87c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa891ce6908de70fac5b1a55d44b87c"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromMemory</b> (const uint8_t *input, size_t len)</td></tr>
<tr class="separator:a7fa891ce6908de70fac5b1a55d44b87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b87e7e48b22ec268d67728c14db75c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b87e7e48b22ec268d67728c14db75c1"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const char *input)</td></tr>
<tr class="separator:a0b87e7e48b22ec268d67728c14db75c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100a903ab9c073eebe525f106862fdd7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a100a903ab9c073eebe525f106862fdd7"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const std::string &amp;input)</td></tr>
<tr class="separator:a100a903ab9c073eebe525f106862fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392c82f4e10896af45f64168590a3bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac392c82f4e10896af45f64168590a3bc"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromFile</b> (const char *filename)</td></tr>
<tr class="separator:ac392c82f4e10896af45f64168590a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f78e53cb84a0189b626e6a5726b148"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f78e53cb84a0189b626e6a5726b148"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">binaryDecoder</a> ()</td></tr>
<tr class="memdesc:a04f78e53cb84a0189b626e6a5726b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode binary Avro standard. <br /></td></tr>
<tr class="separator:a04f78e53cb84a0189b626e6a5726b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9408498d77f42a536074433cc541d8ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9408498d77f42a536074433cc541d8ae"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae">validatingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:a9408498d77f42a536074433cc541d8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data. ">Decoder</a> against the given schema. <br /></td></tr>
<tr class="separator:a9408498d77f42a536074433cc541d8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac8a9c93b0621227de3dcca383e36ff"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac8a9c93b0621227de3dcca383e36ff"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a7ac8a9c93b0621227de3dcca383e36ff">jsonDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a7ac8a9c93b0621227de3dcca383e36ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode Avro standard for JSON. <br /></td></tr>
<tr class="separator:a7ac8a9c93b0621227de3dcca383e36ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="memItemLeft" align="right" valign="top">AVRO_DECL <a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">resolvingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;writer, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;reader, const <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema.  <a href="#aeef8b583abe36b25a8d2094d7a3d4b96">More...</a><br /></td></tr>
<tr class="separator:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0158bd2fc76615b68db68d7e4f7c4f6"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">binaryEncoder</a> ()</td></tr>
<tr class="memdesc:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that can encode binary Avro standard. <br /></td></tr>
<tr class="separator:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba750d980390623baeae24bc24b286e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ba750d980390623baeae24bc24b286e"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e">validatingEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:a1ba750d980390623baeae24bc24b286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders. ">Encoder</a> against the given schema. <br /></td></tr>
<tr class="separator:a1ba750d980390623baeae24bc24b286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0847ef62f42f6f0d0af28da9f7c7cf15"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0847ef62f42f6f0d0af28da9f7c7cf15">jsonEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that can encode Avro standard for JSON. <br /></td></tr>
<tr class="separator:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793048d50960fa83ada15d4c5b9c58b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793048d50960fa83ada15d4c5b9c58b7"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classavro_1_1Name.html">Name</a> &amp;n)</td></tr>
<tr class="separator:a793048d50960fa83ada15d4c5b9c58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb0c98243cbfe723262a61c747e858b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb0c98243cbfe723262a61c747e858b"></a>
NodePtr&#160;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr class="separator:a1fb0c98243cbfe723262a61c747e858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cb2d5a007fb9634a3878af7b32c398"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58cb2d5a007fb9634a3878af7b32c398"></a>
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr class="separator:a58cb2d5a007fb9634a3878af7b32c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e8d0ef60e0b85451fccf401289492f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e8d0ef60e0b85451fccf401289492f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr class="separator:a95e8d0ef60e0b85451fccf401289492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f9441b454deb1dec9dfa6eebca935b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f9441b454deb1dec9dfa6eebca935b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr class="separator:a01f9441b454deb1dec9dfa6eebca935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21938e7ba64b1704e3233852846dfcf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21938e7ba64b1704e3233852846dfcf"></a>
<a class="el" href="classavro_1_1Resolver.html">Resolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;rwriterSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr class="separator:ab21938e7ba64b1704e3233852846dfcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068734327d24a1e80caeee07b70b367f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a068734327d24a1e80caeee07b70b367f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a068734327d24a1e80caeee07b70b367f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">encode</a> (<a class="el" href="classavro_1_1Encoder.html">Encoder</a> &amp;e, const T &amp;t)</td></tr>
<tr class="memdesc:a068734327d24a1e80caeee07b70b367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic encoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a>. <br /></td></tr>
<tr class="separator:a068734327d24a1e80caeee07b70b367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9893c6f7b0f264029261056da57fbd2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9893c6f7b0f264029261056da57fbd2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9893c6f7b0f264029261056da57fbd2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">decode</a> (<a class="el" href="classavro_1_1Decoder.html">Decoder</a> &amp;d, T &amp;t)</td></tr>
<tr class="memdesc:a9893c6f7b0f264029261056da57fbd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic decoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">codec_traits</a>. <br /></td></tr>
<tr class="separator:a9893c6f7b0f264029261056da57fbd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17924697cd3e7fed6b15e16f60bba607"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17924697cd3e7fed6b15e16f60bba607"></a>
AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607">memoryOutputStream</a> (size_t chunkSize=4 *1024)</td></tr>
<tr class="memdesc:a17924697cd3e7fed6b15e16f60bba607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a>, which grows in memory chunks of specified size. <br /></td></tr>
<tr class="separator:a17924697cd3e7fed6b15e16f60bba607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383a86da8c86de91708d6865293f10f6"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6">memoryInputStream</a> (const uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a383a86da8c86de91708d6865293f10f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a>, with the data from the given byte array.  <a href="#a383a86da8c86de91708d6865293f10f6">More...</a><br /></td></tr>
<tr class="separator:a383a86da8c86de91708d6865293f10f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccce9f2136f59050dd9b866130fb052"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0ccce9f2136f59050dd9b866130fb052">memoryInputStream</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr class="memdesc:a0ccce9f2136f59050dd9b866130fb052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> with the contents written into an outputstream.  <a href="#a0ccce9f2136f59050dd9b866130fb052">More...</a><br /></td></tr>
<tr class="separator:a0ccce9f2136f59050dd9b866130fb052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144188a9049059a08c3ec4c1d0d6c91a"><td class="memItemLeft" align="right" valign="top">AVRO_DECL boost::shared_ptr<br class="typebreak" />
&lt; std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a144188a9049059a08c3ec4c1d0d6c91a">snapshot</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr class="memdesc:a144188a9049059a08c3ec4c1d0d6c91a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents written so far into the output stream, which should be a memory output stream.  <a href="#a144188a9049059a08c3ec4c1d0d6c91a">More...</a><br /></td></tr>
<tr class="separator:a144188a9049059a08c3ec4c1d0d6c91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f045f7aa22d1b628aa0fec12f82332"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a49f045f7aa22d1b628aa0fec12f82332">fileOutputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:a49f045f7aa22d1b628aa0fec12f82332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a> whose contents would be stored in a file.  <a href="#a49f045f7aa22d1b628aa0fec12f82332">More...</a><br /></td></tr>
<tr class="separator:a49f045f7aa22d1b628aa0fec12f82332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65fd382f9f5f4b90b580861bf2f7f0c"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad65fd382f9f5f4b90b580861bf2f7f0c">fileInputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:ad65fd382f9f5f4b90b580861bf2f7f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> whose contents come from the given file.  <a href="#ad65fd382f9f5f4b90b580861bf2f7f0c">More...</a><br /></td></tr>
<tr class="separator:ad65fd382f9f5f4b90b580861bf2f7f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81fb803530d3b67946a48ec6ea9faf6"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aa81fb803530d3b67946a48ec6ea9faf6">ostreamOutputStream</a> (std::ostream &amp;os, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:aa81fb803530d3b67946a48ec6ea9faf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a> whose contents will be sent to the given std::ostream.  <a href="#aa81fb803530d3b67946a48ec6ea9faf6">More...</a><br /></td></tr>
<tr class="separator:aa81fb803530d3b67946a48ec6ea9faf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ace2f37da00282385a25d29900f6fb7"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak" />
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a6ace2f37da00282385a25d29900f6fb7">istreamInputStream</a> (std::istream &amp;in, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:a6ace2f37da00282385a25d29900f6fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> whose contents come from the given std::istream.  <a href="#a6ace2f37da00282385a25d29900f6fb7">More...</a><br /></td></tr>
<tr class="separator:a6ace2f37da00282385a25d29900f6fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeab3d9f5f2a4a4f96d3ffb8ba27e523"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#adeab3d9f5f2a4a4f96d3ffb8ba27e523">copy</a> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;in, <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;out)</td></tr>
<tr class="memdesc:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to copy all the contents of an input stream into an output stream. <br /></td></tr>
<tr class="separator:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ca7f599d09b940bd236e77aa508381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a83ca7f599d09b940bd236e77aa508381">isPrimitive</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr class="memdesc:a83ca7f599d09b940bd236e77aa508381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a primitive.  <a href="#a83ca7f599d09b940bd236e77aa508381">More...</a><br /></td></tr>
<tr class="separator:a83ca7f599d09b940bd236e77aa508381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183aa500a8985117239abdc5922d8602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a183aa500a8985117239abdc5922d8602">isCompound</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr class="memdesc:a183aa500a8985117239abdc5922d8602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a non primitive valid type.  <a href="#a183aa500a8985117239abdc5922d8602">More...</a><br /></td></tr>
<tr class="separator:a183aa500a8985117239abdc5922d8602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e596e801aaf532e26895ad9d7bfcdb1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e596e801aaf532e26895ad9d7bfcdb1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a5e596e801aaf532e26895ad9d7bfcdb1">isAvroType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr class="memdesc:a5e596e801aaf532e26895ad9d7bfcdb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a valid avro type. <br /></td></tr>
<tr class="separator:a5e596e801aaf532e26895ad9d7bfcdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66c7c7a5f5cdbacf66009aa4a8079ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66c7c7a5f5cdbacf66009aa4a8079ef"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ae66c7c7a5f5cdbacf66009aa4a8079ef">isAvroTypeOrPseudoType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr class="memdesc:ae66c7c7a5f5cdbacf66009aa4a8079ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is within the valid range of enumeration. <br /></td></tr>
<tr class="separator:ae66c7c7a5f5cdbacf66009aa4a8079ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb20ffcc3629ced067077fc4ab82653a"><td class="memItemLeft" align="right" valign="top">AVRO_DECL const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#abb20ffcc3629ced067077fc4ab82653a">toString</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> type)</td></tr>
<tr class="memdesc:abb20ffcc3629ced067077fc4ab82653a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given type into a string.  <a href="#abb20ffcc3629ced067077fc4ab82653a">More...</a><br /></td></tr>
<tr class="separator:abb20ffcc3629ced067077fc4ab82653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820da0b6f2cbab9f887f0663f1f2801"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac820da0b6f2cbab9f887f0663f1f2801"></a>
AVRO_DECL std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac820da0b6f2cbab9f887f0663f1f2801">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a> type)</td></tr>
<tr class="memdesc:ac820da0b6f2cbab9f887f0663f1f2801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string form of the given type into the given ostream. <br /></td></tr>
<tr class="separator:ac820da0b6f2cbab9f887f0663f1f2801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4ab8b3abddb0a14d47cbe76214488d7b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr class="memdesc:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes schema for null <code>null</code> type to <code>os</code>.  <a href="#a4ab8b3abddb0a14d47cbe76214488d7b">More...</a><br /></td></tr>
<tr class="separator:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8b5609576bc00f398f30363ed2a986"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8b5609576bc00f398f30363ed2a986"></a>
AVRO_DECL uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input)</td></tr>
<tr class="separator:a9e8b5609576bc00f398f30363ed2a986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e909a789ac2b2fbe8b416c90d39fb99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e909a789ac2b2fbe8b416c90d39fb99"></a>
AVRO_DECL int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input)</td></tr>
<tr class="separator:a1e909a789ac2b2fbe8b416c90d39fb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0553f3f786db4254c3518387d1575b0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0553f3f786db4254c3518387d1575b0e"></a>
AVRO_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input)</td></tr>
<tr class="separator:a0553f3f786db4254c3518387d1575b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf774f56a1909853388449ce639dc591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf774f56a1909853388449ce639dc591"></a>
AVRO_DECL int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input)</td></tr>
<tr class="separator:acf774f56a1909853388449ce639dc591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3c29b569928eace8b617d4cff845ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3c29b569928eace8b617d4cff845ce"></a>
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)</td></tr>
<tr class="separator:aaf3c29b569928eace8b617d4cff845ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54564bbdb2ead318181a3c04fde7d0da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54564bbdb2ead318181a3c04fde7d0da"></a>
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)</td></tr>
<tr class="separator:a54564bbdb2ead318181a3c04fde7d0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac3e38ba690e0685abb630b5093b2e7d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac3e38ba690e0685abb630b5093b2e7d1"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:ac3e38ba690e0685abb630b5093b2e7d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac3e38ba690e0685abb630b5093b2e7d1">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr class="memdesc:ac3e38ba690e0685abb630b5093b2e7d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br /></td></tr>
<tr class="separator:ac3e38ba690e0685abb630b5093b2e7d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7737443ffaa03bbb901299bcdaacace0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7737443ffaa03bbb901299bcdaacace0"></a>
template&lt;typename Reader &gt; </td></tr>
<tr class="memitem:a7737443ffaa03bbb901299bcdaacace0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr class="separator:a7737443ffaa03bbb901299bcdaacace0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0b554d35352db4cc84814c0d03f8a1"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd0b554d35352db4cc84814c0d03f8a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd0b554d35352db4cc84814c0d03f8a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr class="separator:acd0b554d35352db4cc84814c0d03f8a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3a93ede267b00ea138e35ac681724705"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a93ede267b00ea138e35ac681724705"></a>
template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a3a93ede267b00ea138e35ac681724705"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a3a93ede267b00ea138e35ac681724705">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, T val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr class="memdesc:a3a93ede267b00ea138e35ac681724705"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br /></td></tr>
<tr class="separator:a3a93ede267b00ea138e35ac681724705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd31869f16892b2ce5e15b4b87388d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a10bd31869f16892b2ce5e15b4b87388d"></a>
template&lt;typename Writer &gt; </td></tr>
<tr class="memitem:a10bd31869f16892b2ce5e15b4b87388d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr class="separator:a10bd31869f16892b2ce5e15b4b87388d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a47c9d8f1ab53aaf6cedb7f344d241ec5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c9d8f1ab53aaf6cedb7f344d241ec5"></a>
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>InputStream</b></td></tr>
<tr class="separator:a47c9d8f1ab53aaf6cedb7f344d241ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac45d280b253381efc5f489b86c641f"><td class="memItemLeft" align="right" valign="top">class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#afac45d280b253381efc5f489b86c641f">ValidSchema</a></td></tr>
<tr class="memdesc:afac45d280b253381efc5f489b86c641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement an avro spec parser using a flex/bison compiler.  <a href="#afac45d280b253381efc5f489b86c641f">More...</a><br /></td></tr>
<tr class="separator:afac45d280b253381efc5f489b86c641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69535672c36b355e52a501291bb3a1a2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69535672c36b355e52a501291bb3a1a2"></a>
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>Schema</b></td></tr>
<tr class="separator:a69535672c36b355e52a501291bb3a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A bunch of templates and specializations for encoding and decoding specific types. </p>
<p>Primitive AVRO types BOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING and BYTES get decoded to and encoded from C++ types bool, int32_t, int64_t, float, double, std::string and std::vector&lt;uint8_t&gt; respectively. In addition, std::vector&lt;T&gt; for aribtrary type T gets encoded as an Avro array of T. Similarly, std::map&lt;std::string, T&gt; for arbitrary type T gets encoded as an Avro map with value type T.</p>
<p>Users can have their custom types encoded/decoded by specializing <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type. ">avro::codec_traits</a> class for their types. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a348c1fae0c6b9d7524b00be30a2746b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#a348c1fae0c6b9d7524b00be30a2746b2">avro::Codec</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify type of compression to use when writing data files. </p>

</div>
</div>
<a class="anchor" id="ad17da92a723dce9b89e7c845749615b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a>RESOLVE_NO_MATCH&#160;</td><td class="fielddoc">
<p>The schemas definitely do not match. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a>RESOLVE_MATCH&#160;</td><td class="fielddoc">
<p>The schemas match at a cursory level. </p>
<p>For records and enums, this means the name is the same, but it does not necessarily mean that every symbol or field is an exact match. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a>RESOLVE_PROMOTABLE_TO_LONG&#160;</td><td class="fielddoc">
<p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The "type" for the schema. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f"></a>AVRO_STRING&#160;</td><td class="fielddoc">
<p>String </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09"></a>AVRO_BYTES&#160;</td><td class="fielddoc">
<p>Sequence of variable length bytes data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3"></a>AVRO_INT&#160;</td><td class="fielddoc">
<p>32-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340"></a>AVRO_LONG&#160;</td><td class="fielddoc">
<p>64-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8"></a>AVRO_FLOAT&#160;</td><td class="fielddoc">
<p>Floating point number </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800"></a>AVRO_DOUBLE&#160;</td><td class="fielddoc">
<p>Double precision floating point number </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2"></a>AVRO_BOOL&#160;</td><td class="fielddoc">
<p>Boolean value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff"></a>AVRO_NULL&#160;</td><td class="fielddoc">
<p><a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions ">Null</a> </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3"></a>AVRO_RECORD&#160;</td><td class="fielddoc">
<p>Record, a sequence of fields </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597"></a>AVRO_ENUM&#160;</td><td class="fielddoc">
<p>Enumeration </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb"></a>AVRO_ARRAY&#160;</td><td class="fielddoc">
<p>Homogeneous array of some specific type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c"></a>AVRO_MAP&#160;</td><td class="fielddoc">
<p>Homogeneous map from string to some specific type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9"></a>AVRO_UNION&#160;</td><td class="fielddoc">
<p>Union of one or more types </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7"></a>AVRO_FIXED&#160;</td><td class="fielddoc">
<p>Fixed number of bytes </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d"></a>AVRO_NUM_TYPES&#160;</td><td class="fielddoc">
<p>Marker </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129"></a>AVRO_SYMBOLIC&#160;</td><td class="fielddoc">
<p>User internally to avoid circular references. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c"></a>AVRO_UNKNOWN&#160;</td><td class="fielddoc">
<p>Used internally. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a31c14823127aff747cc83e6714de9e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL void avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a class="anchor" id="a23cb7c42622aad8310cffa013c022d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL bool avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="section return"><dt>Returns</dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a class="anchor" id="ad65fd382f9f5f4b90b580861bf2f7f0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::fileInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> whose contents come from the given file. </p>
<p>Data is read in chunks of given buffer size. </p>

</div>
</div>
<a class="anchor" id="a49f045f7aa22d1b628aa0fec12f82332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>&gt; avro::fileOutputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a> whose contents would be stored in a file. </p>
<p>Data is written in chunks of given buffer size.</p>
<p>If there is a file with the given name, it is truncated and overwritten. If there is no file with the given name, it is created. </p>

</div>
</div>
<a class="anchor" id="a183aa500a8985117239abdc5922d8602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool avro::isCompound </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given type is a non primitive valid type. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p>References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>.</p>

</div>
</div>
<a class="anchor" id="a83ca7f599d09b940bd236e77aa508381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool avro::isPrimitive </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given type is a primitive. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p>References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>.</p>

</div>
</div>
<a class="anchor" id="a6ace2f37da00282385a25d29900f6fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::istreamInputStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> whose contents come from the given std::istream. </p>
<p>The std::istream object should outlive the returned <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a>. </p>

</div>
</div>
<a class="anchor" id="a383a86da8c86de91708d6865293f10f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a>, with the data from the given byte array. </p>
<p>It does not copy the data, the byte array should remain valid until the <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> is used. </p>

</div>
</div>
<a class="anchor" id="a0ccce9f2136f59050dd9b866130fb052"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const OutputStream &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream. ">InputStream</a> with the contents written into an outputstream. </p>
<p>The output stream must have been returned by an earlier call to <a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size. ">memoryOutputStream()</a>. The contents for the new input stream are the snapshot of the outputstream. One can construct any number of memory input stream from a single memory output stream. </p>

</div>
</div>
<a class="anchor" id="a4ab8b3abddb0a14d47cbe76214488d7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; avro::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes schema for null <code>null</code> type to <code>os</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The ostream to write to. </td></tr>
    <tr><td class="paramname">null</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa81fb803530d3b67946a48ec6ea9faf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>&gt; avro::ostreamOutputStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a> whose contents will be sent to the given std::ostream. </p>
<p>The std::ostream object should outlive the returned <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream. ">OutputStream</a>. </p>

</div>
</div>
<a class="anchor" id="a0180913cf37820fd8c10a35af371945c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a class="anchor" id="aeef8b583abe36b25a8d2094d7a3d4b96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL <a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a> avro::resolvingDecoder </td>
          <td>(</td>
          <td class="paramtype">const ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecoderPtr &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema. </p>
<p>The client uses the decoder as if the data were written using readerSchema. // FIXME: Handle out of order fields. </p>

</div>
</div>
<a class="anchor" id="a274e8f2e3a165ff45bf932a82127fc78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::serialize </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
<a class="anchor" id="a144188a9049059a08c3ec4c1d0d6c91a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL boost::shared_ptr&lt;std::vector&lt;uint8_t&gt; &gt; avro::snapshot </td>
          <td>(</td>
          <td class="paramtype">const OutputStream &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents written so far into the output stream, which should be a memory output stream. </p>
<p>That is it must have been returned by a pervious call to <a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size. ">memoryOutputStream()</a>. </p>

</div>
</div>
<a class="anchor" id="abb20ffcc3629ced067077fc4ab82653a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL const std::string&amp; avro::toString </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts the given type into a string. </p>
<p>Useful for generating messages. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="afac45d280b253381efc5f489b86c641f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class is used to implement an avro spec parser using a flex/bison compiler. </p>
<p>In order for the lexer to be reentrant, this class provides a lexer object for each parse. The bison parser also uses this class to build up an avro parse tree as the avro spec is parsed. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 22 2016 14:47:09 for Avro C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
