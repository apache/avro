<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro::detail::Chunk Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceavro.html">avro</a>::<b>detail</b>::<a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a>
  </div>
</div>
<div class="contents">
<h1>avro::detail::Chunk Class Reference</h1><!-- doxytag: class="avro::detail::Chunk" -->
<p>A chunk is the building block for buffers.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BufferDetail_8hh_source.html">BufferDetail.hh</a>&gt;</code></p>

<p><a href="classavro_1_1detail_1_1Chunk-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a56b3bd3353d6ee1bd2f70b309f635d86"></a><!-- doxytag: member="avro::detail::Chunk::SharedPtr" ref="a56b3bd3353d6ee1bd2f70b309f635d86" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SharedPtr</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad011290a492c959a77e48d8423b7f06"></a><!-- doxytag: member="avro::detail::Chunk::Chunk" ref="aad011290a492c959a77e48d8423b7f06" args="(size_type size)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#aad011290a492c959a77e48d8423b7f06">Chunk</a> (size_type size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor, allocates a new underlying block for this chunk. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a2f7a69a42b5a98753fcd012d29b6e6cc">Chunk</a> (const data_type *data, size_type size, const free_func &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Foreign buffer constructor, uses the supplied data for this chunk, and only for reading.  <a href="#a2f7a69a42b5a98753fcd012d29b6e6cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a98deb2f5b11db8b5947fc69a99804e04">truncateFront</a> (size_type howMuch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove readable bytes from the front of the chunk by advancing the chunk start position.  <a href="#a98deb2f5b11db8b5947fc69a99804e04"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a43e4f2e11ceaeb1fbe584f3196095c55">truncateBack</a> (size_type howMuch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove readable bytes from the back of the chunk by moving the chunk cursor position.  <a href="#a43e4f2e11ceaeb1fbe584f3196095c55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f9c0a9e85f56f44fc578a074b7fddc3"></a><!-- doxytag: member="avro::detail::Chunk::tellWritePos" ref="a3f9c0a9e85f56f44fc578a074b7fddc3" args="() const " -->
data_type *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a3f9c0a9e85f56f44fc578a074b7fddc3">tellWritePos</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell the position the next byte may be written to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca7add250abcd0ab6e8c5da68044bfb"></a><!-- doxytag: member="avro::detail::Chunk::tellReadPos" ref="acca7add250abcd0ab6e8c5da68044bfb" args="() const " -->
const data_type *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#acca7add250abcd0ab6e8c5da68044bfb">tellReadPos</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell the position of the first byte containing valid data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fdce5e4abf475190c0c85e7b68e39c9"></a><!-- doxytag: member="avro::detail::Chunk::incrementCursor" ref="a1fdce5e4abf475190c0c85e7b68e39c9" args="(size_type howMuch)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a1fdce5e4abf475190c0c85e7b68e39c9">incrementCursor</a> (size_type howMuch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">After a write operation, increment the write position. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ad04f07604fe95fb98cac528cc831e9"></a><!-- doxytag: member="avro::detail::Chunk::dataSize" ref="a9ad04f07604fe95fb98cac528cc831e9" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a9ad04f07604fe95fb98cac528cc831e9">dataSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell how many bytes of data were written to this chunk. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba42c077d8a738636d12a0445cad5170"></a><!-- doxytag: member="avro::detail::Chunk::freeSize" ref="aba42c077d8a738636d12a0445cad5170" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#aba42c077d8a738636d12a0445cad5170">freeSize</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell how many bytes this chunk has available to write to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a79585b3d8645e2e8abd144e18e8b3f25"></a><!-- doxytag: member="avro::detail::Chunk::capacity" ref="a79585b3d8645e2e8abd144e18e8b3f25" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a79585b3d8645e2e8abd144e18e8b3f25">capacity</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tell how many bytes of data this chunk can hold (used and free). <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6242327167bb73c97664dd169ba21010"></a><!-- doxytag: member="avro::detail::Chunk::operator==" ref="a6242327167bb73c97664dd169ba21010" args="(const Chunk &amp;lhs, const Chunk &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a6242327167bb73c97664dd169ba21010">operator==</a> (const <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &amp;lhs, const <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare underlying buffers and return true if they are equal. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a39cf65cba17849f9fa32b7a933d943a9"></a><!-- doxytag: member="avro::detail::Chunk::operator!=" ref="a39cf65cba17849f9fa32b7a933d943a9" args="(const Chunk &amp;lhs, const Chunk &amp;rhs)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1Chunk.html#a39cf65cba17849f9fa32b7a933d943a9">operator!=</a> (const <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &amp;lhs, const <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &amp;rhs)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compare underlying buffers and return true if they are unequal. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A chunk is the building block for buffers. </p>
<p>A chunk is backed by a memory block, and internally it maintains information about which area of the block it may use, and the portion of this area that contains valid data. More than one chunk may share the same underlying block, but the areas should never overlap. <a class="el" href="classavro_1_1detail_1_1Chunk.html" title="A chunk is the building block for buffers.">Chunk</a> holds a shared pointer to an array of bytes so that shared blocks are reference counted.</p>
<p>When a chunk is copied, the copy shares the same underlying buffer, but the copy receives its own copies of the start/cursor/end pointers, so each copy can be manipulated independently. This allows different buffers to share the same non-overlapping parts of a chunk, or even overlapping parts of a chunk if the situation arises. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2f7a69a42b5a98753fcd012d29b6e6cc"></a><!-- doxytag: member="avro::detail::Chunk::Chunk" ref="a2f7a69a42b5a98753fcd012d29b6e6cc" args="(const data_type *data, size_type size, const free_func &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">avro::detail::Chunk::Chunk </td>
          <td>(</td>
          <td class="paramtype">const data_type *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const free_func &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Foreign buffer constructor, uses the supplied data for this chunk, and only for reading. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a43e4f2e11ceaeb1fbe584f3196095c55"></a><!-- doxytag: member="avro::detail::Chunk::truncateBack" ref="a43e4f2e11ceaeb1fbe584f3196095c55" args="(size_type howMuch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::Chunk::truncateBack </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>howMuch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove readable bytes from the back of the chunk by moving the chunk cursor position. </p>

</div>
</div>
<a class="anchor" id="a98deb2f5b11db8b5947fc69a99804e04"></a><!-- doxytag: member="avro::detail::Chunk::truncateFront" ref="a98deb2f5b11db8b5947fc69a99804e04" args="(size_type howMuch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::Chunk::truncateFront </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>howMuch</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove readable bytes from the front of the chunk by advancing the chunk start position. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cutting/src/avro/1.4.0-rc4/lang/c++/api/buffer/detail/<a class="el" href="BufferDetail_8hh_source.html">BufferDetail.hh</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Sep 2 18:40:54 2010 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
