<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro::detail::BufferImpl Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceavro.html">avro</a>::<b>detail</b>::<a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a>
  </div>
</div>
<div class="contents">
<h1>avro::detail::BufferImpl Class Reference</h1><!-- doxytag: class="avro::detail::BufferImpl" -->
<p>Implementation details for Buffer class.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="BufferDetail_8hh_source.html">BufferDetail.hh</a>&gt;</code></p>

<p><a href="classavro_1_1detail_1_1BufferImpl-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10b7aaa5f4401df6af08755242274068"></a><!-- doxytag: member="avro::detail::BufferImpl::ChunkList" ref="a10b7aaa5f4401df6af08755242274068" args="" -->
typedef std::deque&lt; <a class="el" href="classavro_1_1detail_1_1Chunk.html">Chunk</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ChunkList</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7d2fae5c6da6c8f7305942f5191f60d"></a><!-- doxytag: member="avro::detail::BufferImpl::SharedPtr" ref="ab7d2fae5c6da6c8f7305942f5191f60d" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SharedPtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b728178a3d9a7a9932217db5b82069f"></a><!-- doxytag: member="avro::detail::BufferImpl::ConstSharedPtr" ref="a4b728178a3d9a7a9932217db5b82069f" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; const <a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ConstSharedPtr</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c2888ba25ccbd1bab1a6f748274a468"></a><!-- doxytag: member="avro::detail::BufferImpl::BufferImpl" ref="a9c2888ba25ccbd1bab1a6f748274a468" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a9c2888ba25ccbd1bab1a6f748274a468">BufferImpl</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor, creates a buffer without any chunks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b6e259210c227e488d71867c85d9193"></a><!-- doxytag: member="avro::detail::BufferImpl::BufferImpl" ref="a6b6e259210c227e488d71867c85d9193" args="(const BufferImpl &amp;src)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a6b6e259210c227e488d71867c85d9193">BufferImpl</a> (const <a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor, gets a copy of all the chunks with data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7f2a7613f4e9541dae0f1c6ffadd123d"></a><!-- doxytag: member="avro::detail::BufferImpl::size" ref="a7f2a7613f4e9541dae0f1c6ffadd123d" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a7f2a7613f4e9541dae0f1c6ffadd123d">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Amount of data held in this buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35deb698bd19714a7a4065cdfff79c86"></a><!-- doxytag: member="avro::detail::BufferImpl::freeSpace" ref="a35deb698bd19714a7a4065cdfff79c86" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a35deb698bd19714a7a4065cdfff79c86">freeSpace</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Capacity that may be written before the buffer must allocate more memory. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#aca7e5d0873229f0eb143606a46bc8048">reserveFreeSpace</a> (size_type reserveSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add enough free chunks to make the reservation size available.  <a href="#aca7e5d0873229f0eb143606a46bc8048"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9c83b63fdc9b6c18dc5042e1f39b6ef"></a><!-- doxytag: member="avro::detail::BufferImpl::beginRead" ref="af9c83b63fdc9b6c18dc5042e1f39b6ef" args="() const " -->
ChunkList::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#af9c83b63fdc9b6c18dc5042e1f39b6ef">beginRead</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the chunk avro's begin iterator for reading. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f55fd425846d8600110875cdacba0b8"></a><!-- doxytag: member="avro::detail::BufferImpl::endRead" ref="a5f55fd425846d8600110875cdacba0b8" args="() const " -->
ChunkList::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a5f55fd425846d8600110875cdacba0b8">endRead</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the chunk avro's end iterator for reading. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a02707286421a7632580dd6b3730ee02b"></a><!-- doxytag: member="avro::detail::BufferImpl::beginWrite" ref="a02707286421a7632580dd6b3730ee02b" args="() const " -->
ChunkList::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a02707286421a7632580dd6b3730ee02b">beginWrite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the chunk avro's begin iterator for writing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdd3ba6b3cc360d723f6193ae6b24b3a"></a><!-- doxytag: member="avro::detail::BufferImpl::endWrite" ref="abdd3ba6b3cc360d723f6193ae6b24b3a" args="() const " -->
ChunkList::const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#abdd3ba6b3cc360d723f6193ae6b24b3a">endWrite</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the chunk avro's end iterator for writing. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="adc8099443bdface1dd87bf5f09ed1138"></a><!-- doxytag: member="avro::detail::BufferImpl::writeTo" ref="adc8099443bdface1dd87bf5f09ed1138" args="(T val, const boost::true_type &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#adc8099443bdface1dd87bf5f09ed1138">writeTo</a> (T val, const boost::true_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a single value to buffer, add a new chunk if necessary. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#aa7e8c901d35748757c036c7134102b88">writeTo</a> (T val, const boost::false_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An uninstantiable function, this is if boost::is_fundamental check fails, and will compile-time assert.  <a href="#aa7e8c901d35748757c036c7134102b88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97ba995ac0e1b98c64d07bc147a3c407"></a><!-- doxytag: member="avro::detail::BufferImpl::writeTo" ref="a97ba995ac0e1b98c64d07bc147a3c407" args="(const data_type *data, size_type size)" -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a97ba995ac0e1b98c64d07bc147a3c407">writeTo</a> (const data_type *data, size_type size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a block of data to the buffer, adding new chunks if necessary. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21e6e10ad0be8ee765d6c6a15d443d64"></a><!-- doxytag: member="avro::detail::BufferImpl::wroteTo" ref="a21e6e10ad0be8ee765d6c6a15d443d64" args="(size_type size)" -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a21e6e10ad0be8ee765d6c6a15d443d64">wroteTo</a> (size_type size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update internal status of chunks after data is written using iterator. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace78fc9ee75ac88a8014ca984389aa4d"></a><!-- doxytag: member="avro::detail::BufferImpl::append" ref="ace78fc9ee75ac88a8014ca984389aa4d" args="(const BufferImpl &amp;src)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#ace78fc9ee75ac88a8014ca984389aa4d">append</a> (const <a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;src)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Append the chunks that have data in src to this buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e808183d2c006ac9d7bb50a28c54fa4"></a><!-- doxytag: member="avro::detail::BufferImpl::discardData" ref="a5e808183d2c006ac9d7bb50a28c54fa4" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a5e808183d2c006ac9d7bb50a28c54fa4">discardData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all the chunks that contain data from this buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb99580c158809894e7b435182060d9e"></a><!-- doxytag: member="avro::detail::BufferImpl::discardData" ref="afb99580c158809894e7b435182060d9e" args="(size_type bytes)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#afb99580c158809894e7b435182060d9e">discardData</a> (size_type bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the specified amount of data from the chunks, starting at the front. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5bffd1a6bba2304e47ad3a2f6cfcd571"></a><!-- doxytag: member="avro::detail::BufferImpl::extractData" ref="a5bffd1a6bba2304e47ad3a2f6cfcd571" args="(BufferImpl &amp;dest, size_type bytes)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a5bffd1a6bba2304e47ad3a2f6cfcd571">extractData</a> (<a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;dest, size_type bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove the specified amount of data from the chunks, moving the data to dest's chunks. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a99c7e2f716a1e0faec105ce4c3e48e8f"></a><!-- doxytag: member="avro::detail::BufferImpl::extractData" ref="a99c7e2f716a1e0faec105ce4c3e48e8f" args="(BufferImpl &amp;dest)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a99c7e2f716a1e0faec105ce4c3e48e8f">extractData</a> (<a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;dest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move data from this to the destination, leaving this buffer without data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#ab8f672ed3f05c740c23131258df57755">copyData</a> (<a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;dest, ChunkList::const_iterator iter, size_type offset, size_type bytes) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy data to a different buffer by copying the chunks.  <a href="#ab8f672ed3f05c740c23131258df57755"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a149a26821a3047e9ae6bf0a87107cff5"></a><!-- doxytag: member="avro::detail::BufferImpl::numDataChunks" ref="a149a26821a3047e9ae6bf0a87107cff5" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#a149a26821a3047e9ae6bf0a87107cff5">numDataChunks</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of chunks containing data. Used for debugging. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#aa3b2f5a03786fbbdb8d10e89138b7bce">numFreeChunks</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of chunks containing free space (note that an entire chunk may not be free).  <a href="#aa3b2f5a03786fbbdb8d10e89138b7bce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html#ae84e04a18afc94f78ada9812f4e252a2">appendForeignData</a> (const data_type *data, size_type size, const free_func &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add unmanaged data to the buffer.  <a href="#ae84e04a18afc94f78ada9812f4e252a2"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation details for Buffer class. </p>
<p>Internally, <a class="el" href="classavro_1_1detail_1_1BufferImpl.html" title="Implementation details for Buffer class.">BufferImpl</a> keeps two lists of chunks, one list consists entirely of chunks containing data, and one list which contains chunks with free space. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae84e04a18afc94f78ada9812f4e252a2"></a><!-- doxytag: member="avro::detail::BufferImpl::appendForeignData" ref="ae84e04a18afc94f78ada9812f4e252a2" args="(const data_type *data, size_type size, const free_func &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::BufferImpl::appendForeignData </td>
          <td>(</td>
          <td class="paramtype">const data_type *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const free_func &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add unmanaged data to the buffer. </p>
<p>The buffer will not automatically free the data, but it will call the supplied function when the data is no longer referenced by the buffer (or copies of the buffer). </p>

</div>
</div>
<a class="anchor" id="ab8f672ed3f05c740c23131258df57755"></a><!-- doxytag: member="avro::detail::BufferImpl::copyData" ref="ab8f672ed3f05c740c23131258df57755" args="(BufferImpl &amp;dest, ChunkList::const_iterator iter, size_type offset, size_type bytes) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::BufferImpl::copyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classavro_1_1detail_1_1BufferImpl.html">BufferImpl</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChunkList::const_iterator&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy data to a different buffer by copying the chunks. </p>
<p>It's a bit like extract, but without modifying the source buffer. </p>

</div>
</div>
<a class="anchor" id="aa3b2f5a03786fbbdb8d10e89138b7bce"></a><!-- doxytag: member="avro::detail::BufferImpl::numFreeChunks" ref="aa3b2f5a03786fbbdb8d10e89138b7bce" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int avro::detail::BufferImpl::numFreeChunks </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of chunks containing free space (note that an entire chunk may not be free). </p>
<p>Used for debugging. </p>

</div>
</div>
<a class="anchor" id="aca7e5d0873229f0eb143606a46bc8048"></a><!-- doxytag: member="avro::detail::BufferImpl::reserveFreeSpace" ref="aca7e5d0873229f0eb143606a46bc8048" args="(size_type reserveSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::BufferImpl::reserveFreeSpace </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>reserveSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add enough free chunks to make the reservation size available. </p>
<p>Actual amount may be more (rounded up to next chunk). </p>

</div>
</div>
<a class="anchor" id="aa7e8c901d35748757c036c7134102b88"></a><!-- doxytag: member="avro::detail::BufferImpl::writeTo" ref="aa7e8c901d35748757c036c7134102b88" args="(T val, const boost::false_type &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::detail::BufferImpl::writeTo </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boost::false_type &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>An uninstantiable function, this is if boost::is_fundamental check fails, and will compile-time assert. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cutting/src/avro/1.4.0-rc4/lang/c++/api/buffer/detail/<a class="el" href="BufferDetail_8hh_source.html">BufferDetail.hh</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Thu Sep 2 18:40:54 2010 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
