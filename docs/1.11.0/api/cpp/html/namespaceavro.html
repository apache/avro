<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Avro C++: avro Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">avro Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A bunch of templates and specializations for encoding and decoding specific types.  
<a href="namespaceavro.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceavro_1_1concepts"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>
<tr class="memdesc:namespaceavro_1_1concepts"><td class="mdescLeft">&#160;</td><td class="mdescRight">The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node.">NodeImpl</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits.html">codec_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec_traits tells avro how to encode and decode an object of given type.  <a href="structavro_1_1codec__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01avro_1_1null_01_4.html">codec_traits&lt; avro::null &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro null.  <a href="structavro_1_1codec__traits_3_01avro_1_1null_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01bool_01_4.html">codec_traits&lt; bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro boolean.  <a href="structavro_1_1codec__traits_3_01bool_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01double_01_4.html">codec_traits&lt; double &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro double.  <a href="structavro_1_1codec__traits_3_01double_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01float_01_4.html">codec_traits&lt; float &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro float.  <a href="structavro_1_1codec__traits_3_01float_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html">codec_traits&lt; GenericDatum &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for <a class="el" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type.">GenericDatum</a>.  <a href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int32__t_01_4.html">codec_traits&lt; int32_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro int.  <a href="structavro_1_1codec__traits_3_01int32__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int64__t_01_4.html">codec_traits&lt; int64_t &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro long.  <a href="structavro_1_1codec__traits_3_01int64__t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1array_3_01uint8__t_00_01N_01_4_01_4.html">codec_traits&lt; std::array&lt; uint8_t, N &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro fixed.  <a href="structavro_1_1codec__traits_3_01std_1_1array_3_01uint8__t_00_01N_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1conditional_3_01avro_1_1is__not__defined_3_01bool__codec_ff37ba08cb2504ad1efb9929401153b7.html">codec_traits&lt; std::conditional&lt; avro::is_not_defined&lt; bool_codec_traits &gt;::value, std::vector&lt; bool &gt;::const_reference, void &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html">codec_traits&lt; std::map&lt; std::string, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro maps.  <a href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html">codec_traits&lt; std::pair&lt; ValidSchema, GenericDatum &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Generic datum along with its schema.  <a href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html">codec_traits&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro string.  <a href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html">codec_traits&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro arrays.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html">codec_traits&lt; std::vector&lt; uint8_t &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro bytes.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReader.html">DataFileReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of data file one after another.  <a href="classavro_1_1DataFileReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReaderBase.html">DataFileReaderBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type independent portion of reader.  <a href="classavro_1_1DataFileReaderBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriter.html">DataFileWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An Avro datafile that can store objects of type T.  <a href="classavro_1_1DataFileWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriterBase.html">DataFileWriterBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-independent portion of <a class="el" href="classavro_1_1DataFileWriter.html" title="An Avro datafile that can store objects of type T.">DataFileWriter</a>.  <a href="classavro_1_1DataFileWriterBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html">Decoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> is an interface implemented by every decoder capable of decoding Avro data.  <a href="classavro_1_1Decoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Encoder.html">Encoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for all Avro encoders.  <a href="classavro_1_1Encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericArray.html">GenericArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro arrays.  <a href="classavro_1_1GenericArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericContainer.html">GenericContainer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all generic type for containers.  <a href="classavro_1_1GenericContainer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericDatum.html">GenericDatum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic datum which can hold any Avro type.  <a href="classavro_1_1GenericDatum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericEnum.html">GenericEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro enum.  <a href="classavro_1_1GenericEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericFixed.html">GenericFixed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro fixed.  <a href="classavro_1_1GenericFixed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericMap.html">GenericMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro maps.  <a href="classavro_1_1GenericMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericReader.html">GenericReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to read generic datum from decoders.  <a href="classavro_1_1GenericReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericRecord.html">GenericRecord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro records.  <a href="classavro_1_1GenericRecord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericUnion.html">GenericUnion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for unions.  <a href="classavro_1_1GenericUnion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericWriter.html">GenericWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to write generic datum to encoders.  <a href="classavro_1_1GenericWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputStream.html">InputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy input stream.  <a href="classavro_1_1InputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__defined.html">is_defined</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a <code>T</code> is a complete type i.e.  <a href="structavro_1_1is__defined.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__not__defined.html">is_not_defined</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="structavro_1_1is__defined.html" title="Check if a T is a complete type i.e.">is_defined</a>, but used to check if T is not defined.  <a href="structavro_1_1is__not__defined.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define an <a class="el" href="structavro_1_1is__serializable.html" title="Define an is_serializable trait for types we can serialize natively.">is_serializable</a> trait for types we can serialize natively.  <a href="structavro_1_1is__serializable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LogicalType.html">LogicalType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Name.html">Name</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a>.  <a href="classavro_1_1NodeImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">define a type to represent Avro <a class="el" href="structavro_1_1Null.html" title="define a type to represent Avro Null in template functions">Null</a> in template functions  <a href="structavro_1_1Null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullValidator.html">NullValidator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputStream.html">OutputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy output stream.  <a href="classavro_1_1OutputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses from an avro encoding to the requested type.  <a href="classavro_1_1ReaderImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a> is derived from <a class="el" href="classavro_1_1Decoder.html">Decoder</a>, with an additional function to obtain the field ordering of fields within a record.  <a href="classavro_1_1ResolvingDecoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SeekableInputStream.html">SeekableInputStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> which also supports seeking to a specific offset.  <a href="classavro_1_1SeekableInputStream.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a Writer or ValidatingWriter with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamReader.html">StreamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for reading from an <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>.  <a href="structavro_1_1StreamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamWriter.html">StreamWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class to write data into an <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>.  <a href="structavro_1_1StreamWriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolicSchema.html">SymbolicSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minimum of sanity checks.">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> that has passed some minimum of sanity checks.  <a href="classavro_1_1ValidSchema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for writing avro data to a stream.  <a href="classavro_1_1WriterImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a43f382a7652211425e91bdf186b00f95"><td class="memItemLeft" align="right" valign="top"><a id="a43f382a7652211425e91bdf186b00f95"></a>
typedef std::array&lt; uint8_t, SyncSize &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a43f382a7652211425e91bdf186b00f95">DataFileSync</a></td></tr>
<tr class="memdesc:a43f382a7652211425e91bdf186b00f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sync value. <br /></td></tr>
<tr class="separator:a43f382a7652211425e91bdf186b00f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e61ab3fbdffc13d2a20efd80c5811b1"><td class="memItemLeft" align="right" valign="top"><a id="a2e61ab3fbdffc13d2a20efd80c5811b1"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a> = std::shared_ptr&lt; <a class="el" href="classavro_1_1Decoder.html">Decoder</a> &gt;</td></tr>
<tr class="memdesc:a2e61ab3fbdffc13d2a20efd80c5811b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a>. <br /></td></tr>
<tr class="separator:a2e61ab3fbdffc13d2a20efd80c5811b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac198aa7cfb3f53cfe4fa993f52fad2d7"><td class="memItemLeft" align="right" valign="top"><a id="ac198aa7cfb3f53cfe4fa993f52fad2d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac198aa7cfb3f53cfe4fa993f52fad2d7">ResolvingDecoderPtr</a> = std::shared_ptr&lt; <a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a> &gt;</td></tr>
<tr class="memdesc:ac198aa7cfb3f53cfe4fa993f52fad2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a>. <br /></td></tr>
<tr class="separator:ac198aa7cfb3f53cfe4fa993f52fad2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf627d2676075c8eeaf6a25103b5d5e"><td class="memItemLeft" align="right" valign="top"><a id="a2bf627d2676075c8eeaf6a25103b5d5e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a> = std::shared_ptr&lt; <a class="el" href="classavro_1_1Encoder.html">Encoder</a> &gt;</td></tr>
<tr class="memdesc:a2bf627d2676075c8eeaf6a25103b5d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders.">Encoder</a>. <br /></td></tr>
<tr class="separator:a2bf627d2676075c8eeaf6a25103b5d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1592d238b1d5345b04feb00a7bb2ce10"><td class="memItemLeft" align="right" valign="top"><a id="a1592d238b1d5345b04feb00a7bb2ce10"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b> = std::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;</td></tr>
<tr class="separator:a1592d238b1d5345b04feb00a7bb2ce10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5558df435e0017b3688e49519929c24d"><td class="memItemLeft" align="right" valign="top"><a id="a5558df435e0017b3688e49519929c24d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NoName</b> = <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a>&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;</td></tr>
<tr class="separator:a5558df435e0017b3688e49519929c24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee77ea4738457adb26927fc15cb9fe0a"><td class="memItemLeft" align="right" valign="top"><a id="aee77ea4738457adb26927fc15cb9fe0a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HasName</b> = <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;</td></tr>
<tr class="separator:aee77ea4738457adb26927fc15cb9fe0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa184a722ea7de63776172a12f16c4a66"><td class="memItemLeft" align="right" valign="top"><a id="aa184a722ea7de63776172a12f16c4a66"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HasDoc</b> = <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; std::string &gt;</td></tr>
<tr class="separator:aa184a722ea7de63776172a12f16c4a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b49889c72859e38479ac29304ede2"><td class="memItemLeft" align="right" valign="top"><a id="af58b49889c72859e38479ac29304ede2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b> = <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a>&lt; NodePtr &gt;</td></tr>
<tr class="separator:af58b49889c72859e38479ac29304ede2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad8cefcd755fba62c91e1f476e39492"><td class="memItemLeft" align="right" valign="top"><a id="a9ad8cefcd755fba62c91e1f476e39492"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b> = <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; NodePtr &gt;</td></tr>
<tr class="separator:a9ad8cefcd755fba62c91e1f476e39492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6642884a35e9e88e2ee4e6e44074e9d8"><td class="memItemLeft" align="right" valign="top"><a id="a6642884a35e9e88e2ee4e6e44074e9d8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b> = <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a>&lt; NodePtr &gt;</td></tr>
<tr class="separator:a6642884a35e9e88e2ee4e6e44074e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232aa5ada982ae8bb4b391a402b70688"><td class="memItemLeft" align="right" valign="top"><a id="a232aa5ada982ae8bb4b391a402b70688"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b> = <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a>&lt; std::string &gt;</td></tr>
<tr class="separator:a232aa5ada982ae8bb4b391a402b70688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ef4dc1f832dbca4882b2cbe05ee39"><td class="memItemLeft" align="right" valign="top"><a id="a417ef4dc1f832dbca4882b2cbe05ee39"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b> = <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a>&lt; std::string &gt;</td></tr>
<tr class="separator:a417ef4dc1f832dbca4882b2cbe05ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bb82c2485dcccfca5ed057ecd28104"><td class="memItemLeft" align="right" valign="top"><a id="a37bb82c2485dcccfca5ed057ecd28104"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NoSize</b> = <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a>&lt; int &gt;</td></tr>
<tr class="separator:a37bb82c2485dcccfca5ed057ecd28104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdcffc74a5f554b53b1f11335339b1a"><td class="memItemLeft" align="right" valign="top"><a id="a5bdcffc74a5f554b53b1f11335339b1a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>HasSize</b> = <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;</td></tr>
<tr class="separator:a5bdcffc74a5f554b53b1f11335339b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a29a723b806ca6da2a13b26b2746146"><td class="memItemLeft" align="right" valign="top"><a id="a1a29a723b806ca6da2a13b26b2746146"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:a1a29a723b806ca6da2a13b26b2746146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c588514365671c13f2c251ee2a6a955"><td class="memItemLeft" align="right" valign="top"><a id="a2c588514365671c13f2c251ee2a6a955"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:a2c588514365671c13f2c251ee2a6a955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f8b5c8f9aef940b06f1001907e659b"><td class="memItemLeft" align="right" valign="top"><a id="ab6f8b5c8f9aef940b06f1001907e659b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:ab6f8b5c8f9aef940b06f1001907e659b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34125935f933873383e7acdcd9a3284"><td class="memItemLeft" align="right" valign="top"><a id="ae34125935f933873383e7acdcd9a3284"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:ae34125935f933873383e7acdcd9a3284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469ea5fc04462c08c4a1b3a3f68aa24"><td class="memItemLeft" align="right" valign="top"><a id="ae469ea5fc04462c08c4a1b3a3f68aa24"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:ae469ea5fc04462c08c4a1b3a3f68aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a38188faf9be30da6bc3b78cbfa3e5"><td class="memItemLeft" align="right" valign="top"><a id="a35a38188faf9be30da6bc3b78cbfa3e5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:a35a38188faf9be30da6bc3b78cbfa3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe2c0c99d50bb6522844e68515b41c4"><td class="memItemLeft" align="right" valign="top"><a id="a1fe2c0c99d50bb6522844e68515b41c4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;</td></tr>
<tr class="separator:a1fe2c0c99d50bb6522844e68515b41c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a5ce71bab8e04863849f443ba7f06"><td class="memItemLeft" align="right" valign="top"><a id="a562a5ce71bab8e04863849f443ba7f06"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b> = <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;</td></tr>
<tr class="separator:a562a5ce71bab8e04863849f443ba7f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a64deb7b0215f0a5e06005a0d2dc0c"><td class="memItemLeft" align="right" valign="top"><a id="a13a64deb7b0215f0a5e06005a0d2dc0c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b> = <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;</td></tr>
<tr class="separator:a13a64deb7b0215f0a5e06005a0d2dc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b993f6ce4867e9364300d4706e66a04"><td class="memItemLeft" align="right" valign="top"><a id="a2b993f6ce4867e9364300d4706e66a04"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingReader</b> = <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;</td></tr>
<tr class="separator:a2b993f6ce4867e9364300d4706e66a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca818212e3d2b0ea32c14a13f50e351"><td class="memItemLeft" align="right" valign="top"><a id="a8ca818212e3d2b0ea32c14a13f50e351"></a>
typedef boost::blank&#160;</td><td class="memItemRight" valign="bottom"><b>null</b></td></tr>
<tr class="separator:a8ca818212e3d2b0ea32c14a13f50e351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09b75ac77ed4707b0aa2d6bb2baa2aa"><td class="memItemLeft" align="right" valign="top"><a id="ad09b75ac77ed4707b0aa2d6bb2baa2aa"></a>
typedef <a class="el" href="structavro_1_1codec__traits.html">codec_traits</a>&lt; std::vector&lt; bool &gt;::const_reference &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>bool_codec_traits</b></td></tr>
<tr class="separator:ad09b75ac77ed4707b0aa2d6bb2baa2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5308030a73ac5e77d137c85da998a1f"><td class="memItemLeft" align="right" valign="top"><a id="aa5308030a73ac5e77d137c85da998a1f"></a>
typedef std::unique_ptr&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InputStreamPtr</b></td></tr>
<tr class="separator:aa5308030a73ac5e77d137c85da998a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fac02b889333b5cce2ad64f4726d879"><td class="memItemLeft" align="right" valign="top"><a id="a5fac02b889333b5cce2ad64f4726d879"></a>
typedef std::unique_ptr&lt; <a class="el" href="classavro_1_1SeekableInputStream.html">SeekableInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SeekableInputStreamPtr</b></td></tr>
<tr class="separator:a5fac02b889333b5cce2ad64f4726d879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15caddf44fc86120fb3da035f046c6a9"><td class="memItemLeft" align="right" valign="top"><a id="a15caddf44fc86120fb3da035f046c6a9"></a>
typedef std::unique_ptr&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OutputStreamPtr</b></td></tr>
<tr class="separator:a15caddf44fc86120fb3da035f046c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3925017523fc12297106fba86521f7a9"><td class="memItemLeft" align="right" valign="top"><a id="a3925017523fc12297106fba86521f7a9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Writer</b> = <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;</td></tr>
<tr class="separator:a3925017523fc12297106fba86521f7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921b0284b8dd2a512adec57964122f9a"><td class="memItemLeft" align="right" valign="top"><a id="a921b0284b8dd2a512adec57964122f9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingWriter</b> = <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;</td></tr>
<tr class="separator:a921b0284b8dd2a512adec57964122f9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a348c1fae0c6b9d7524b00be30a2746b2"><td class="memItemLeft" align="right" valign="top"><a id="a348c1fae0c6b9d7524b00be30a2746b2"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a348c1fae0c6b9d7524b00be30a2746b2">Codec</a> { <b>NULL_CODEC</b>, 
<b>DEFLATE_CODEC</b>
 }</td></tr>
<tr class="memdesc:a348c1fae0c6b9d7524b00be30a2746b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify type of compression to use when writing data files. <br /></td></tr>
<tr class="separator:a348c1fae0c6b9d7524b00be30a2746b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17da92a723dce9b89e7c845749615b3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br />
&#160;&#160;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br />
&#160;&#160;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br />
 }</td></tr>
<tr class="separator:ad17da92a723dce9b89e7c845749615b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e528c3fe1cb5660067a02721fae0b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> { <br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09">AVRO_BYTES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3">AVRO_INT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340">AVRO_LONG</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8">AVRO_FLOAT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">AVRO_DOUBLE</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2">AVRO_BOOL</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff">AVRO_NULL</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597">AVRO_ENUM</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb">AVRO_ARRAY</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c">AVRO_MAP</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9">AVRO_UNION</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7">AVRO_FIXED</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129">AVRO_SYMBOLIC</a> = AVRO_NUM_TYPES, 
<br />
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c">AVRO_UNKNOWN</a> = -1
<br />
 }</td></tr>
<tr class="memdesc:a29e528c3fe1cb5660067a02721fae0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "type" for the schema.  <a href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">More...</a><br /></td></tr>
<tr class="separator:a29e528c3fe1cb5660067a02721fae0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0180913cf37820fd8c10a35af371945c"><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:a0180913cf37820fd8c10a35af371945c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr class="memdesc:a0180913cf37820fd8c10a35af371945c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main parse entry point function.  <a href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">More...</a><br /></td></tr>
<tr class="separator:a0180913cf37820fd8c10a35af371945c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d3c0e0c943565a98085d3e2d195196"><td class="memTemplParams" colspan="2"><a id="a71d3c0e0c943565a98085d3e2d195196"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a71d3c0e0c943565a98085d3e2d195196"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr class="separator:a71d3c0e0c943565a98085d3e2d195196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8df2d01eb8b8e90eb02638c40196383"><td class="memTemplParams" colspan="2"><a id="ab8df2d01eb8b8e90eb02638c40196383"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:ab8df2d01eb8b8e90eb02638c40196383"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ab8df2d01eb8b8e90eb02638c40196383">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const std::false_type &amp;)</td></tr>
<tr class="memdesc:ab8df2d01eb8b8e90eb02638c40196383"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html" title="Define an is_serializable trait for types we can serialize natively.">is_serializable</a> in otherwise force the compiler to complain. <br /></td></tr>
<tr class="separator:ab8df2d01eb8b8e90eb02638c40196383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308e118932b6e287d53cf2743af2c921"><td class="memTemplParams" colspan="2"><a id="a308e118932b6e287d53cf2743af2c921"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:a308e118932b6e287d53cf2743af2c921"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const std::false_type &amp;)</td></tr>
<tr class="separator:a308e118932b6e287d53cf2743af2c921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca91abb1b91493bf8dd4c3cff2b786"><td class="memTemplParams" colspan="2"><a id="aa7ca91abb1b91493bf8dd4c3cff2b786"></a>
template&lt;typename Reader , typename T &gt; </td></tr>
<tr class="memitem:aa7ca91abb1b91493bf8dd4c3cff2b786"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aa7ca91abb1b91493bf8dd4c3cff2b786">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const std::true_type &amp;)</td></tr>
<tr class="memdesc:aa7ca91abb1b91493bf8dd4c3cff2b786"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br /></td></tr>
<tr class="separator:aa7ca91abb1b91493bf8dd4c3cff2b786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf666b403b5d9046fc0945bdc6044a58"><td class="memTemplParams" colspan="2"><a id="acf666b403b5d9046fc0945bdc6044a58"></a>
template&lt;typename Reader &gt; </td></tr>
<tr class="memitem:acf666b403b5d9046fc0945bdc6044a58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const std::true_type &amp;)</td></tr>
<tr class="separator:acf666b403b5d9046fc0945bdc6044a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2eb96e5042ef4ec95c2431a84324e9"><td class="memTemplParams" colspan="2"><a id="adf2eb96e5042ef4ec95c2431a84324e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adf2eb96e5042ef4ec95c2431a84324e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const std::true_type &amp;)</td></tr>
<tr class="separator:adf2eb96e5042ef4ec95c2431a84324e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274e8f2e3a165ff45bf932a82127fc78"><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a274e8f2e3a165ff45bf932a82127fc78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a274e8f2e3a165ff45bf932a82127fc78">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr class="memdesc:a274e8f2e3a165ff45bf932a82127fc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main serializer entry point function.  <a href="namespaceavro.html#a274e8f2e3a165ff45bf932a82127fc78">More...</a><br /></td></tr>
<tr class="separator:a274e8f2e3a165ff45bf932a82127fc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b402438828aa0fb5fa9af70c550fa4c"><td class="memTemplParams" colspan="2"><a id="a5b402438828aa0fb5fa9af70c550fa4c"></a>
template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a5b402438828aa0fb5fa9af70c550fa4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a5b402438828aa0fb5fa9af70c550fa4c">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val, const std::false_type &amp;)</td></tr>
<tr class="memdesc:a5b402438828aa0fb5fa9af70c550fa4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html" title="Define an is_serializable trait for types we can serialize natively.">is_serializable</a> in otherwise force the compiler to complain. <br /></td></tr>
<tr class="separator:a5b402438828aa0fb5fa9af70c550fa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccf69b17032cab4d5aa953b046e929f"><td class="memTemplParams" colspan="2"><a id="a2ccf69b17032cab4d5aa953b046e929f"></a>
template&lt;typename Writer , typename T &gt; </td></tr>
<tr class="memitem:a2ccf69b17032cab4d5aa953b046e929f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a2ccf69b17032cab4d5aa953b046e929f">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, T val, const std::true_type &amp;)</td></tr>
<tr class="memdesc:a2ccf69b17032cab4d5aa953b046e929f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br /></td></tr>
<tr class="separator:a2ccf69b17032cab4d5aa953b046e929f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b74cc2152c88c3957d893a2b6d4662e"><td class="memTemplParams" colspan="2"><a id="a4b74cc2152c88c3957d893a2b6d4662e"></a>
template&lt;typename Writer &gt; </td></tr>
<tr class="memitem:a4b74cc2152c88c3957d893a2b6d4662e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const std::true_type &amp;)</td></tr>
<tr class="separator:a4b74cc2152c88c3957d893a2b6d4662e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c14823127aff747cc83e6714de9e31"><td class="memItemLeft" align="right" valign="top">AVRO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a31c14823127aff747cc83e6714de9e31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a stream containing a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minimum of sanity checks.">ValidSchema</a> object.  <a href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">More...</a><br /></td></tr>
<tr class="separator:a31c14823127aff747cc83e6714de9e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cb7c42622aad8310cffa013c022d14"><td class="memItemLeft" align="right" valign="top">AVRO_DECL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a23cb7c42622aad8310cffa013c022d14">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr class="memdesc:a23cb7c42622aad8310cffa013c022d14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="namespaceavro.html#a23cb7c42622aad8310cffa013c022d14">More...</a><br /></td></tr>
<tr class="separator:a23cb7c42622aad8310cffa013c022d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1694b4608e27e3a3f82c41f943fc4be"><td class="memItemLeft" align="right" valign="top"><a id="ae1694b4608e27e3a3f82c41f943fc4be"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromStream</b> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;is)</td></tr>
<tr class="separator:ae1694b4608e27e3a3f82c41f943fc4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa891ce6908de70fac5b1a55d44b87c"><td class="memItemLeft" align="right" valign="top"><a id="a7fa891ce6908de70fac5b1a55d44b87c"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromMemory</b> (const uint8_t *input, size_t len)</td></tr>
<tr class="separator:a7fa891ce6908de70fac5b1a55d44b87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b87e7e48b22ec268d67728c14db75c1"><td class="memItemLeft" align="right" valign="top"><a id="a0b87e7e48b22ec268d67728c14db75c1"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const char *input)</td></tr>
<tr class="separator:a0b87e7e48b22ec268d67728c14db75c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100a903ab9c073eebe525f106862fdd7"><td class="memItemLeft" align="right" valign="top"><a id="a100a903ab9c073eebe525f106862fdd7"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const std::string &amp;input)</td></tr>
<tr class="separator:a100a903ab9c073eebe525f106862fdd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac392c82f4e10896af45f64168590a3bc"><td class="memItemLeft" align="right" valign="top"><a id="ac392c82f4e10896af45f64168590a3bc"></a>
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromFile</b> (const char *filename)</td></tr>
<tr class="separator:ac392c82f4e10896af45f64168590a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f78e53cb84a0189b626e6a5726b148"><td class="memItemLeft" align="right" valign="top"><a id="a04f78e53cb84a0189b626e6a5726b148"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">binaryDecoder</a> ()</td></tr>
<tr class="memdesc:a04f78e53cb84a0189b626e6a5726b148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode binary Avro standard. <br /></td></tr>
<tr class="separator:a04f78e53cb84a0189b626e6a5726b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9408498d77f42a536074433cc541d8ae"><td class="memItemLeft" align="right" valign="top"><a id="a9408498d77f42a536074433cc541d8ae"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae">validatingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:a9408498d77f42a536074433cc541d8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> against the given schema. <br /></td></tr>
<tr class="separator:a9408498d77f42a536074433cc541d8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac8a9c93b0621227de3dcca383e36ff"><td class="memItemLeft" align="right" valign="top"><a id="a7ac8a9c93b0621227de3dcca383e36ff"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a7ac8a9c93b0621227de3dcca383e36ff">jsonDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a7ac8a9c93b0621227de3dcca383e36ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode Avro standard for JSON. <br /></td></tr>
<tr class="separator:a7ac8a9c93b0621227de3dcca383e36ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="memItemLeft" align="right" valign="top">AVRO_DECL <a class="el" href="namespaceavro.html#ac198aa7cfb3f53cfe4fa993f52fad2d7">ResolvingDecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">resolvingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;writer, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;reader, const <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema.  <a href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">More...</a><br /></td></tr>
<tr class="separator:aeef8b583abe36b25a8d2094d7a3d4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="memItemLeft" align="right" valign="top"><a id="ad0158bd2fc76615b68db68d7e4f7c4f6"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">binaryEncoder</a> ()</td></tr>
<tr class="memdesc:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that can encode binary Avro standard. <br /></td></tr>
<tr class="separator:ad0158bd2fc76615b68db68d7e4f7c4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba750d980390623baeae24bc24b286e"><td class="memItemLeft" align="right" valign="top"><a id="a1ba750d980390623baeae24bc24b286e"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e">validatingEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a> &amp;base)</td></tr>
<tr class="memdesc:a1ba750d980390623baeae24bc24b286e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders.">Encoder</a> against the given schema. <br /></td></tr>
<tr class="separator:a1ba750d980390623baeae24bc24b286e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="memItemLeft" align="right" valign="top"><a id="a0847ef62f42f6f0d0af28da9f7c7cf15"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0847ef62f42f6f0d0af28da9f7c7cf15">jsonEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that encodes Avro standard for JSON. <br /></td></tr>
<tr class="separator:a0847ef62f42f6f0d0af28da9f7c7cf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6028342a629213643d27da4a0aba5d"><td class="memItemLeft" align="right" valign="top"><a id="aaa6028342a629213643d27da4a0aba5d"></a>
AVRO_DECL <a class="el" href="namespaceavro.html#a2bf627d2676075c8eeaf6a25103b5d5e">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aaa6028342a629213643d27da4a0aba5d">jsonPrettyEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr class="memdesc:aaa6028342a629213643d27da4a0aba5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that encodes Avro standard for pretty printed JSON. <br /></td></tr>
<tr class="separator:aaa6028342a629213643d27da4a0aba5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793048d50960fa83ada15d4c5b9c58b7"><td class="memItemLeft" align="right" valign="top"><a id="a793048d50960fa83ada15d4c5b9c58b7"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classavro_1_1Name.html">Name</a> &amp;n)</td></tr>
<tr class="separator:a793048d50960fa83ada15d4c5b9c58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb0c98243cbfe723262a61c747e858b"><td class="memItemLeft" align="right" valign="top"><a id="a1fb0c98243cbfe723262a61c747e858b"></a>
NodePtr&#160;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr class="separator:a1fb0c98243cbfe723262a61c747e858b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1746bbb2a64e52f5055f1a0dec9082"><td class="memTemplParams" colspan="2"><a id="aea1746bbb2a64e52f5055f1a0dec9082"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea1746bbb2a64e52f5055f1a0dec9082"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>intToHex</b> (T i)</td></tr>
<tr class="separator:aea1746bbb2a64e52f5055f1a0dec9082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cb2d5a007fb9634a3878af7b32c398"><td class="memItemLeft" align="right" valign="top"><a id="a58cb2d5a007fb9634a3878af7b32c398"></a>
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr class="separator:a58cb2d5a007fb9634a3878af7b32c398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e8d0ef60e0b85451fccf401289492f"><td class="memItemLeft" align="right" valign="top"><a id="a95e8d0ef60e0b85451fccf401289492f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr class="separator:a95e8d0ef60e0b85451fccf401289492f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f9441b454deb1dec9dfa6eebca935b"><td class="memItemLeft" align="right" valign="top"><a id="a01f9441b454deb1dec9dfa6eebca935b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr class="separator:a01f9441b454deb1dec9dfa6eebca935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b81a0a32f4e2f7e93d93c0c5df6eaf"><td class="memItemLeft" align="right" valign="top"><a id="a82b81a0a32f4e2f7e93d93c0c5df6eaf"></a>
std::unique_ptr&lt; <a class="el" href="classavro_1_1Resolver.html">Resolver</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;writerSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr class="separator:a82b81a0a32f4e2f7e93d93c0c5df6eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068734327d24a1e80caeee07b70b367f"><td class="memTemplParams" colspan="2"><a id="a068734327d24a1e80caeee07b70b367f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a068734327d24a1e80caeee07b70b367f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">encode</a> (<a class="el" href="classavro_1_1Encoder.html">Encoder</a> &amp;e, const T &amp;t)</td></tr>
<tr class="memdesc:a068734327d24a1e80caeee07b70b367f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic encoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a>. <br /></td></tr>
<tr class="separator:a068734327d24a1e80caeee07b70b367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9893c6f7b0f264029261056da57fbd2d"><td class="memTemplParams" colspan="2"><a id="a9893c6f7b0f264029261056da57fbd2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9893c6f7b0f264029261056da57fbd2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">decode</a> (<a class="el" href="classavro_1_1Decoder.html">Decoder</a> &amp;d, T &amp;t)</td></tr>
<tr class="memdesc:a9893c6f7b0f264029261056da57fbd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic decoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a>. <br /></td></tr>
<tr class="separator:a9893c6f7b0f264029261056da57fbd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e961740e43d3f800220f03de11654e8"><td class="memItemLeft" align="right" valign="top"><a id="a0e961740e43d3f800220f03de11654e8"></a>
AVRO_DECL OutputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8">memoryOutputStream</a> (size_t chunkSize=4 *1024)</td></tr>
<tr class="memdesc:a0e961740e43d3f800220f03de11654e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>, which grows in memory chunks of specified size. <br /></td></tr>
<tr class="separator:a0e961740e43d3f800220f03de11654e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98b7a8baaef11e477db89699ab27359b"><td class="memItemLeft" align="right" valign="top">AVRO_DECL InputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">memoryInputStream</a> (const uint8_t *data, size_t len)</td></tr>
<tr class="memdesc:a98b7a8baaef11e477db89699ab27359b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>, with the data from the given byte array.  <a href="namespaceavro.html#a98b7a8baaef11e477db89699ab27359b">More...</a><br /></td></tr>
<tr class="separator:a98b7a8baaef11e477db89699ab27359b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68150c4e26a7cbf54f9a053c7de6dad9"><td class="memItemLeft" align="right" valign="top">AVRO_DECL InputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a68150c4e26a7cbf54f9a053c7de6dad9">memoryInputStream</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr class="memdesc:a68150c4e26a7cbf54f9a053c7de6dad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> with the contents written into an <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>.  <a href="namespaceavro.html#a68150c4e26a7cbf54f9a053c7de6dad9">More...</a><br /></td></tr>
<tr class="separator:a68150c4e26a7cbf54f9a053c7de6dad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d938bbd6332e4c247e5a975ca066647"><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::shared_ptr&lt; std::vector&lt; uint8_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a1d938bbd6332e4c247e5a975ca066647">snapshot</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr class="memdesc:a1d938bbd6332e4c247e5a975ca066647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the contents written so far into the output stream, which should be a memory output stream.  <a href="namespaceavro.html#a1d938bbd6332e4c247e5a975ca066647">More...</a><br /></td></tr>
<tr class="separator:a1d938bbd6332e4c247e5a975ca066647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164e34d709ba33d2464c295e7874f784"><td class="memItemLeft" align="right" valign="top">AVRO_DECL OutputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a164e34d709ba33d2464c295e7874f784">fileOutputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:a164e34d709ba33d2464c295e7874f784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents would be stored in a file.  <a href="namespaceavro.html#a164e34d709ba33d2464c295e7874f784">More...</a><br /></td></tr>
<tr class="separator:a164e34d709ba33d2464c295e7874f784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5251d2ad9581e353399c1bac90c9fb"><td class="memItemLeft" align="right" valign="top">AVRO_DECL InputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a1e5251d2ad9581e353399c1bac90c9fb">fileInputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:a1e5251d2ad9581e353399c1bac90c9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given file.  <a href="namespaceavro.html#a1e5251d2ad9581e353399c1bac90c9fb">More...</a><br /></td></tr>
<tr class="separator:a1e5251d2ad9581e353399c1bac90c9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d796ffb35058e3e39877b5a2639d21d"><td class="memItemLeft" align="right" valign="top"><a id="a3d796ffb35058e3e39877b5a2639d21d"></a>
AVRO_DECL SeekableInputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><b>fileSeekableInputStream</b> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr class="separator:a3d796ffb35058e3e39877b5a2639d21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2ea7a6b8a82014ce7d76abcc171812"><td class="memItemLeft" align="right" valign="top">AVRO_DECL OutputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#acb2ea7a6b8a82014ce7d76abcc171812">ostreamOutputStream</a> (std::ostream &amp;os, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:acb2ea7a6b8a82014ce7d76abcc171812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents will be sent to the given std::ostream.  <a href="namespaceavro.html#acb2ea7a6b8a82014ce7d76abcc171812">More...</a><br /></td></tr>
<tr class="separator:acb2ea7a6b8a82014ce7d76abcc171812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff15582cf7ee211e1b2e0968a0edbd7e"><td class="memItemLeft" align="right" valign="top">AVRO_DECL InputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aff15582cf7ee211e1b2e0968a0edbd7e">istreamInputStream</a> (std::istream &amp;in, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:aff15582cf7ee211e1b2e0968a0edbd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream.  <a href="namespaceavro.html#aff15582cf7ee211e1b2e0968a0edbd7e">More...</a><br /></td></tr>
<tr class="separator:aff15582cf7ee211e1b2e0968a0edbd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9033beeae2950b3e73d99482d3936929"><td class="memItemLeft" align="right" valign="top">AVRO_DECL InputStreamPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9033beeae2950b3e73d99482d3936929">nonSeekableIstreamInputStream</a> (std::istream &amp;is, size_t bufferSize=8 *1024)</td></tr>
<tr class="memdesc:a9033beeae2950b3e73d99482d3936929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream.  <a href="namespaceavro.html#a9033beeae2950b3e73d99482d3936929">More...</a><br /></td></tr>
<tr class="separator:a9033beeae2950b3e73d99482d3936929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="memItemLeft" align="right" valign="top"><a id="adeab3d9f5f2a4a4f96d3ffb8ba27e523"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#adeab3d9f5f2a4a4f96d3ffb8ba27e523">copy</a> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;in, <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;out)</td></tr>
<tr class="memdesc:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to copy all the contents of an input stream into an output stream. <br /></td></tr>
<tr class="separator:adeab3d9f5f2a4a4f96d3ffb8ba27e523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d74486d53ce80da712fdcc7d4b7a23b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9d74486d53ce80da712fdcc7d4b7a23b">isPrimitive</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t) noexcept</td></tr>
<tr class="memdesc:a9d74486d53ce80da712fdcc7d4b7a23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a primitive.  <a href="namespaceavro.html#a9d74486d53ce80da712fdcc7d4b7a23b">More...</a><br /></td></tr>
<tr class="separator:a9d74486d53ce80da712fdcc7d4b7a23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8f675115ecd69b17ad03b2ce22c3b8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a6b8f675115ecd69b17ad03b2ce22c3b8">isCompound</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t) noexcept</td></tr>
<tr class="memdesc:a6b8f675115ecd69b17ad03b2ce22c3b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a non primitive valid type.  <a href="namespaceavro.html#a6b8f675115ecd69b17ad03b2ce22c3b8">More...</a><br /></td></tr>
<tr class="separator:a6b8f675115ecd69b17ad03b2ce22c3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7179752d715f9555a5ddb48891051a17"><td class="memItemLeft" align="right" valign="top"><a id="a7179752d715f9555a5ddb48891051a17"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a7179752d715f9555a5ddb48891051a17">isAvroType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t) noexcept</td></tr>
<tr class="memdesc:a7179752d715f9555a5ddb48891051a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a valid avro type. <br /></td></tr>
<tr class="separator:a7179752d715f9555a5ddb48891051a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0f628fbb99fb8e314d01dd379310b9"><td class="memItemLeft" align="right" valign="top"><a id="afc0f628fbb99fb8e314d01dd379310b9"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#afc0f628fbb99fb8e314d01dd379310b9">isAvroTypeOrPseudoType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t) noexcept</td></tr>
<tr class="memdesc:afc0f628fbb99fb8e314d01dd379310b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is within the valid range of enumeration. <br /></td></tr>
<tr class="separator:afc0f628fbb99fb8e314d01dd379310b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa805931c9209b16346ed073e2494568"><td class="memItemLeft" align="right" valign="top">const AVRO_DECL std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#afa805931c9209b16346ed073e2494568">toString</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> type) noexcept</td></tr>
<tr class="memdesc:afa805931c9209b16346ed073e2494568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given type into a string.  <a href="namespaceavro.html#afa805931c9209b16346ed073e2494568">More...</a><br /></td></tr>
<tr class="separator:afa805931c9209b16346ed073e2494568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac820da0b6f2cbab9f887f0663f1f2801"><td class="memItemLeft" align="right" valign="top"><a id="ac820da0b6f2cbab9f887f0663f1f2801"></a>
AVRO_DECL std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac820da0b6f2cbab9f887f0663f1f2801">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a> type)</td></tr>
<tr class="memdesc:ac820da0b6f2cbab9f887f0663f1f2801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string form of the given type into the given ostream. <br /></td></tr>
<tr class="separator:ac820da0b6f2cbab9f887f0663f1f2801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4ab8b3abddb0a14d47cbe76214488d7b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr class="memdesc:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes schema for null <code>null</code> type to <code>os</code>.  <a href="namespaceavro.html#a4ab8b3abddb0a14d47cbe76214488d7b">More...</a><br /></td></tr>
<tr class="separator:a4ab8b3abddb0a14d47cbe76214488d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dd3c28c104a4260610aa9806b2ad47"><td class="memItemLeft" align="right" valign="top"><a id="a10dd3c28c104a4260610aa9806b2ad47"></a>
constexpr AVRO_DECL uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input) noexcept</td></tr>
<tr class="separator:a10dd3c28c104a4260610aa9806b2ad47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09b3370bdb96176f306e5ae118ca678"><td class="memItemLeft" align="right" valign="top"><a id="ab09b3370bdb96176f306e5ae118ca678"></a>
constexpr AVRO_DECL int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input) noexcept</td></tr>
<tr class="separator:ab09b3370bdb96176f306e5ae118ca678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd04a5115838fc48651746000eb8a16"><td class="memItemLeft" align="right" valign="top"><a id="affd04a5115838fc48651746000eb8a16"></a>
constexpr AVRO_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input) noexcept</td></tr>
<tr class="separator:affd04a5115838fc48651746000eb8a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6939e29ebed9c5463c3de77221c0e45f"><td class="memItemLeft" align="right" valign="top"><a id="a6939e29ebed9c5463c3de77221c0e45f"></a>
constexpr AVRO_DECL int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input) noexcept</td></tr>
<tr class="separator:a6939e29ebed9c5463c3de77221c0e45f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5efe38df82bb6380b749cee9661969"><td class="memItemLeft" align="right" valign="top"><a id="a8b5efe38df82bb6380b749cee9661969"></a>
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, std::array&lt; uint8_t, 5 &gt; &amp;output) noexcept</td></tr>
<tr class="separator:a8b5efe38df82bb6380b749cee9661969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8374662418d7973b23ecc48cced46f2"><td class="memItemLeft" align="right" valign="top"><a id="ae8374662418d7973b23ecc48cced46f2"></a>
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, std::array&lt; uint8_t, 10 &gt; &amp;output) noexcept</td></tr>
<tr class="separator:ae8374662418d7973b23ecc48cced46f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a47c9d8f1ab53aaf6cedb7f344d241ec5"><td class="memItemLeft" align="right" valign="top"><a id="a47c9d8f1ab53aaf6cedb7f344d241ec5"></a>
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>InputStream</b></td></tr>
<tr class="separator:a47c9d8f1ab53aaf6cedb7f344d241ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac45d280b253381efc5f489b86c641f"><td class="memItemLeft" align="right" valign="top">class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#afac45d280b253381efc5f489b86c641f">ValidSchema</a></td></tr>
<tr class="memdesc:afac45d280b253381efc5f489b86c641f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement an avro spec parser using a flex/bison compiler.  <a href="namespaceavro.html#afac45d280b253381efc5f489b86c641f">More...</a><br /></td></tr>
<tr class="separator:afac45d280b253381efc5f489b86c641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e207790bf9955af289e7875742ba5c"><td class="memItemLeft" align="right" valign="top"><a id="ae6e207790bf9955af289e7875742ba5c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>SyncSize</b> = 16</td></tr>
<tr class="separator:ae6e207790bf9955af289e7875742ba5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69535672c36b355e52a501291bb3a1a2"><td class="memItemLeft" align="right" valign="top"><a id="a69535672c36b355e52a501291bb3a1a2"></a>
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>Schema</b></td></tr>
<tr class="separator:a69535672c36b355e52a501291bb3a1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A bunch of templates and specializations for encoding and decoding specific types. </p>
<p>Primitive AVRO types BOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING and BYTES get decoded to and encoded from C++ types bool, int32_t, int64_t, float, double, std::string and std::vector&lt;uint8_t&gt; respectively. In addition, std::vector&lt;T&gt; for arbitrary type T gets encoded as an Avro array of T. Similarly, std::map&lt;std::string, T&gt; for arbitrary type T gets encoded as an Avro map with value type T.</p>
<p>Users can have their custom types encoded/decoded by specializing <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">avro::codec_traits</a> class for their types. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ad17da92a723dce9b89e7c845749615b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17da92a723dce9b89e7c845749615b3">&#9670;&nbsp;</a></span>SchemaResolution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a>RESOLVE_NO_MATCH&#160;</td><td class="fielddoc"><p>The schemas definitely do not match. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a>RESOLVE_MATCH&#160;</td><td class="fielddoc"><p>The schemas match at a cursory level. </p>
<pre class="fragment">For records and enums, this means the name is the same, but it does not
necessarily mean that every symbol or field is an exact match. 
</pre> </td></tr>
<tr><td class="fieldname"><a id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a>RESOLVE_PROMOTABLE_TO_LONG&#160;</td><td class="fielddoc"><p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>

</div>
</div>
<a id="a29e528c3fe1cb5660067a02721fae0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e528c3fe1cb5660067a02721fae0b7">&#9670;&nbsp;</a></span>Type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The "type" for the schema. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f"></a>AVRO_STRING&#160;</td><td class="fielddoc"><p>String </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09"></a>AVRO_BYTES&#160;</td><td class="fielddoc"><p>Sequence of variable length bytes data </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3"></a>AVRO_INT&#160;</td><td class="fielddoc"><p>32-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340"></a>AVRO_LONG&#160;</td><td class="fielddoc"><p>64-bit integer </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8"></a>AVRO_FLOAT&#160;</td><td class="fielddoc"><p>Floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800"></a>AVRO_DOUBLE&#160;</td><td class="fielddoc"><p>Double precision floating point number </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2"></a>AVRO_BOOL&#160;</td><td class="fielddoc"><p>Boolean value </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff"></a>AVRO_NULL&#160;</td><td class="fielddoc"><p><a class="el" href="structavro_1_1Null.html" title="define a type to represent Avro Null in template functions">Null</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3"></a>AVRO_RECORD&#160;</td><td class="fielddoc"><p>Record, a sequence of fields </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597"></a>AVRO_ENUM&#160;</td><td class="fielddoc"><p>Enumeration </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb"></a>AVRO_ARRAY&#160;</td><td class="fielddoc"><p>Homogeneous array of some specific type </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c"></a>AVRO_MAP&#160;</td><td class="fielddoc"><p>Homogeneous map from string to some specific type </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9"></a>AVRO_UNION&#160;</td><td class="fielddoc"><p>Union of one or more types </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7"></a>AVRO_FIXED&#160;</td><td class="fielddoc"><p>Fixed number of bytes </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d"></a>AVRO_NUM_TYPES&#160;</td><td class="fielddoc"><p>Marker </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129"></a>AVRO_SYMBOLIC&#160;</td><td class="fielddoc"><p>User internally to avoid circular references. </p>
</td></tr>
<tr><td class="fieldname"><a id="a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c"></a>AVRO_UNKNOWN&#160;</td><td class="fielddoc"><p>Used internally. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a31c14823127aff747cc83e6714de9e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c14823127aff747cc83e6714de9e31">&#9670;&nbsp;</a></span>compileJsonSchema() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL void avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a stream containing a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minimum of sanity checks.">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a id="a23cb7c42622aad8310cffa013c022d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cb7c42622aad8310cffa013c022d14">&#9670;&nbsp;</a></span>compileJsonSchema() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL bool avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="section return"><dt>Returns</dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a id="a1e5251d2ad9581e353399c1bac90c9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5251d2ad9581e353399c1bac90c9fb">&#9670;&nbsp;</a></span>fileInputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL InputStreamPtr avro::fileInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given file. </p>
<p>Data is read in chunks of given buffer size. </p>

</div>
</div>
<a id="a164e34d709ba33d2464c295e7874f784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164e34d709ba33d2464c295e7874f784">&#9670;&nbsp;</a></span>fileOutputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL OutputStreamPtr avro::fileOutputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents would be stored in a file. </p>
<p>Data is written in chunks of given buffer size.</p>
<p>If there is a file with the given name, it is truncated and overwritten. If there is no file with the given name, it is created. </p>

</div>
</div>
<a id="a6b8f675115ecd69b17ad03b2ce22c3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8f675115ecd69b17ad03b2ce22c3b8">&#9670;&nbsp;</a></span>isCompound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool avro::isCompound </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given type is a non primitive valid type. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p class="reference">References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>.</p>

</div>
</div>
<a id="a9d74486d53ce80da712fdcc7d4b7a23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d74486d53ce80da712fdcc7d4b7a23b">&#9670;&nbsp;</a></span>isPrimitive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool avro::isPrimitive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if and only if the given type is a primitive. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p class="reference">References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>.</p>

</div>
</div>
<a id="aff15582cf7ee211e1b2e0968a0edbd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff15582cf7ee211e1b2e0968a0edbd7e">&#9670;&nbsp;</a></span>istreamInputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL InputStreamPtr avro::istreamInputStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream. </p>
<p>The std::istream object should outlive the returned <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>. </p>

</div>
</div>
<a id="a68150c4e26a7cbf54f9a053c7de6dad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68150c4e26a7cbf54f9a053c7de6dad9">&#9670;&nbsp;</a></span>memoryInputStream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL InputStreamPtr avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> with the contents written into an <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>. </p>
<p>The output stream must have been returned by an earlier call to <a class="el" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8" title="Returns a new OutputStream, which grows in memory chunks of specified size.">memoryOutputStream()</a>. The contents for the new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> are the snapshot of the output stream. One can construct any number of memory input stream from a single memory output stream. </p>

</div>
</div>
<a id="a98b7a8baaef11e477db89699ab27359b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98b7a8baaef11e477db89699ab27359b">&#9670;&nbsp;</a></span>memoryInputStream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL InputStreamPtr avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>, with the data from the given byte array. </p>
<p>It does not copy the data, the byte array should remain valid until the <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> is used. </p>

</div>
</div>
<a id="a9033beeae2950b3e73d99482d3936929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9033beeae2950b3e73d99482d3936929">&#9670;&nbsp;</a></span>nonSeekableIstreamInputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL InputStreamPtr avro::nonSeekableIstreamInputStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream. </p>
<p>Use this instead of istreamInputStream if the istream does not support seekg (e.g. compressed streams). The returned <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> would read off bytes instead of seeking. Of, course it has a performance penalty when reading instead of seeking; So, use this only when seekg does not work. The std::istream object should outlive the returned <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>. </p>

</div>
</div>
<a id="a4ab8b3abddb0a14d47cbe76214488d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab8b3abddb0a14d47cbe76214488d7b">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; avro::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes schema for null <code>null</code> type to <code>os</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The ostream to write to. </td></tr>
    <tr><td class="paramname">null</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb2ea7a6b8a82014ce7d76abcc171812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2ea7a6b8a82014ce7d76abcc171812">&#9670;&nbsp;</a></span>ostreamOutputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL OutputStreamPtr avro::ostreamOutputStream </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents will be sent to the given std::ostream. </p>
<p>The std::ostream object should outlive the returned <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>. </p>

</div>
</div>
<a id="a0180913cf37820fd8c10a35af371945c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0180913cf37820fd8c10a35af371945c">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a id="aeef8b583abe36b25a8d2094d7a3d4b96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef8b583abe36b25a8d2094d7a3d4b96">&#9670;&nbsp;</a></span>resolvingDecoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL <a class="el" href="namespaceavro.html#ac198aa7cfb3f53cfe4fa993f52fad2d7">ResolvingDecoderPtr</a> avro::resolvingDecoder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceavro.html#a2e61ab3fbdffc13d2a20efd80c5811b1">DecoderPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema. </p>
<p>The client uses the decoder as if the data were written using readerSchema. // FIXME: Handle out of order fields. </p>

</div>
</div>
<a id="a274e8f2e3a165ff45bf932a82127fc78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274e8f2e3a165ff45bf932a82127fc78">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::serialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
<a id="a1d938bbd6332e4c247e5a975ca066647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d938bbd6332e4c247e5a975ca066647">&#9670;&nbsp;</a></span>snapshot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::shared_ptr&lt;std::vector&lt;uint8_t&gt; &gt; avro::snapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the contents written so far into the output stream, which should be a memory output stream. </p>
<p>That is it must have been returned by a previous call to <a class="el" href="namespaceavro.html#a0e961740e43d3f800220f03de11654e8" title="Returns a new OutputStream, which grows in memory chunks of specified size.">memoryOutputStream()</a>. </p>

</div>
</div>
<a id="afa805931c9209b16346ed073e2494568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa805931c9209b16346ed073e2494568">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const AVRO_DECL std::string&amp; avro::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the given type into a string. </p>
<p>Useful for generating messages. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afac45d280b253381efc5f489b86c641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac45d280b253381efc5f489b86c641f">&#9670;&nbsp;</a></span>ValidSchema</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This class is used to implement an avro spec parser using a flex/bison compiler. </p>
<p>In order for the lexer to be reentrant, this class provides a lexer object for each parse. The bison parser also uses this class to build up an avro parse tree as the avro spec is parsed. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
