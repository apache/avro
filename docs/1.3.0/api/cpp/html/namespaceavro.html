<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>avro Namespace Reference</h1>
<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node.">NodeImpl</a>. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerContext.html">CompilerContext</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to implement an <a class="el" href="namespaceavro.html" title="Licensed to the Apache Software Foundation (ASF) under one or more contributor license...">avro</a> spec parser using a flex/bison compiler.  <a href="classavro_1_1CompilerContext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a generic "untyped" node that may store values for all possible attributes of Avro complex types.  <a href="classavro_1_1CompilerNode.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputStreamer.html">InputStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic object for reading inputs from a stream.  <a href="classavro_1_1InputStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IStreamer.html">IStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classavro_1_1InputStreamer.html" title="A generic object for reading inputs from a stream.">InputStreamer</a> that uses a std::istream for input.  <a href="classavro_1_1IStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a>.  <a href="classavro_1_1NodeImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputStreamer.html">OutputStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A generic object for outputing data to a stream.  <a href="classavro_1_1OutputStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ScreenStreamer.html">ScreenStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classavro_1_1OutputStreamer.html" title="A generic object for outputing data to a stream.">OutputStreamer</a> that writes bytes to screen in ascii representation of the hex digits, used for debugging.  <a href="classavro_1_1ScreenStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OStreamer.html">OStreamer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of <a class="el" href="classavro_1_1OutputStreamer.html" title="A generic object for outputing data to a stream.">OutputStreamer</a> that writes bytes to a std::ostream for output.  <a href="classavro_1_1OStreamer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Reader.html">Reader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses from an <a class="el" href="namespaceavro.html" title="Licensed to the Apache Software Foundation (ASF) under one or more contributor license...">avro</a> encoding to the requested type.  <a href="classavro_1_1Reader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a <a class="el" href="classavro_1_1Writer.html" title="Class for writing avro data to a stream.">Writer</a> or <a class="el" href="classavro_1_1ValidatingWriter.html" title="This class walks the parse tree as data is being serialized, and throws if attempt...">ValidatingWriter</a> with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolMap.html">SymbolMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Avro schemas can include types that were previously defined with names in the same <a class="el" href="namespaceavro.html" title="Licensed to the Apache Software Foundation (ASF) under one or more contributor license...">avro</a> schema.  <a href="classavro_1_1SymbolMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define a type to identify <a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions">Null</a> in template functions  <a href="structavro_1_1Null.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> that has passed some minumum of sanity checks.  <a href="classavro_1_1ValidSchema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidatingReader.html">ValidatingReader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">As an <a class="el" href="namespaceavro.html" title="Licensed to the Apache Software Foundation (ASF) under one or more contributor license...">avro</a> object is being parsed from binary data to its C++ representation, this parser will walk the parse tree and ensure that the correct type is being asked for.  <a href="classavro_1_1ValidatingReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidatingWriter.html">ValidatingWriter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class walks the parse tree as data is being serialized, and throws if attempt to serialize a data type does not match the type expected in the schema.  <a href="classavro_1_1ValidatingWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Writer.html">Writer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for writing <a class="el" href="namespaceavro.html" title="Licensed to the Apache Software Foundation (ASF) under one or more contributor license...">avro</a> data to a stream.  <a href="classavro_1_1Writer.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c572cb71b20e20e429257209a42f91"></a><!-- doxytag: member="avro::NodePtr" ref="a53c572cb71b20e20e429257209a42f91" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3dab217e1e37f983741ae7b04da7d7"></a><!-- doxytag: member="avro::NoName" ref="aeb3dab217e1e37f983741ae7b04da7d7" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8488eb7757ab103913c453edccd5c904"></a><!-- doxytag: member="avro::HasName" ref="a8488eb7757ab103913c453edccd5c904" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85148fbeb2b2e17c9ad5bc357f16aff"></a><!-- doxytag: member="avro::NoLeaves" ref="ac85148fbeb2b2e17c9ad5bc357f16aff" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cf21198637dd41d9099615f32854c7"></a><!-- doxytag: member="avro::SingleLeaf" ref="a71cf21198637dd41d9099615f32854c7" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd609b669d85b5209ccbc21cd8ef8945"></a><!-- doxytag: member="avro::MultiLeaves" ref="afd609b669d85b5209ccbc21cd8ef8945" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6da0159d149557988b1a7e40773d9b"></a><!-- doxytag: member="avro::NoLeafNames" ref="a5b6da0159d149557988b1a7e40773d9b" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa436fd2c922cd09d74494180f669e034"></a><!-- doxytag: member="avro::LeafNames" ref="aa436fd2c922cd09d74494180f669e034" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfce3e38687f7603287dd60dc271252"></a><!-- doxytag: member="avro::NoSize" ref="aecfce3e38687f7603287dd60dc271252" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fa86efe35f9ecda21bb1849da70f05"></a><!-- doxytag: member="avro::HasSize" ref="a46fa86efe35f9ecda21bb1849da70f05" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea022243932db4fd5cf9d387644bb6ce"></a><!-- doxytag: member="avro::NodeImplPrimitive" ref="aea022243932db4fd5cf9d387644bb6ce" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0020a7a6d3590c6e20305780e1f8105"></a><!-- doxytag: member="avro::NodeImplSymbolic" ref="ae0020a7a6d3590c6e20305780e1f8105" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095db2b00faf42c54eff9ddca916f664"></a><!-- doxytag: member="avro::NodeImplRecord" ref="a095db2b00faf42c54eff9ddca916f664" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c214009072cd60af44ebc912d3c72b"></a><!-- doxytag: member="avro::NodeImplEnum" ref="a94c214009072cd60af44ebc912d3c72b" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c70cd3863feee6699197aab1dac75"></a><!-- doxytag: member="avro::NodeImplArray" ref="aa04c70cd3863feee6699197aab1dac75" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f276e8d8fd426534c06c8b351780e7"></a><!-- doxytag: member="avro::NodeImplMap" ref="a88f276e8d8fd426534c06c8b351780e7" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4e7bbdf8250ea8481e5e6222e57918"></a><!-- doxytag: member="avro::NodeImplUnion" ref="a1c4e7bbdf8250ea8481e5e6222e57918" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c3e3db25d7e71e41742bb70eaea2db"></a><!-- doxytag: member="avro::NodeImplFixed" ref="ad7c3e3db25d7e71e41742bb70eaea2db" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br/>
&nbsp;&nbsp;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br/>
&nbsp;&nbsp;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <br/>
&nbsp;&nbsp;<b>AVRO_STRING</b>, 
<b>AVRO_BYTES</b>, 
<b>AVRO_INT</b>, 
<b>AVRO_LONG</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_FLOAT</b>, 
<b>AVRO_DOUBLE</b>, 
<b>AVRO_BOOL</b>, 
<b>AVRO_NULL</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_RECORD</b>, 
<b>AVRO_ENUM</b>, 
<b>AVRO_ARRAY</b>, 
<b>AVRO_MAP</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_UNION</b>, 
<b>AVRO_FIXED</b>, 
<b>AVRO_NUM_TYPES</b>, 
<b>AVRO_SYMBOLIC</b> =  AVRO_NUM_TYPES
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4b63a28bf43eaf3bab0cbe639ea1a5fe">parse</a> (<a class="el" href="classavro_1_1Reader.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main parse entry point function.  <a href="#a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c60c4bde54ec7db8e087420267eb5c3"></a><!-- doxytag: member="avro::parse" ref="a3c60c4bde54ec7db8e087420267eb5c3" args="(ResolvingReader &amp;p, T &amp;val)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5a699390b6a6222a730cd732cb7cfb9"></a><!-- doxytag: member="avro::translatingParse" ref="aa5a699390b6a6222a730cd732cb7cfb9" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1Reader.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#af8f98882bd10d711f84ff8759aed4132">serialize</a> (<a class="el" href="classavro_1_1Writer.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main serializer entry point function.  <a href="#af8f98882bd10d711f84ff8759aed4132"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a102d33293438774ae1f90cdff99a8a45"></a><!-- doxytag: member="avro::serialize" ref="a102d33293438774ae1f90cdff99a8a45" args="(Writer &amp;s, const T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a102d33293438774ae1f90cdff99a8a45">serialize</a> (<a class="el" href="classavro_1_1Writer.html">Writer</a> &amp;s, const T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac736c901800fa085e133118b238f6b46">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> object.  <a href="#ac736c901800fa085e133118b238f6b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac42e03a03cf7f4d975f8913f9e9188d7">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="#ac42e03a03cf7f4d975f8913f9e9188d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b81e6a83479456a1e67ef7c7414413"></a><!-- doxytag: member="avro::nodeFromCompilerNode" ref="af9b81e6a83479456a1e67ef7c7414413" args="(CompilerNode &amp;compilerNode)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>nodeFromCompilerNode</b> (<a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a> &amp;compilerNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb0c98243cbfe723262a61c747e858b"></a><!-- doxytag: member="avro::resolveSymbol" ref="a1fb0c98243cbfe723262a61c747e858b" args="(const NodePtr &amp;node)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58cb2d5a007fb9634a3878af7b32c398"></a><!-- doxytag: member="avro::nextType" ref="a58cb2d5a007fb9634a3878af7b32c398" args="(Parser&lt; ValidatingReader &gt; &amp;p)" -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ValidatingReader.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e8d0ef60e0b85451fccf401289492f"></a><!-- doxytag: member="avro::currentRecordName" ref="a95e8d0ef60e0b85451fccf401289492f" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ValidatingReader.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f9441b454deb1dec9dfa6eebca935b"></a><!-- doxytag: member="avro::nextFieldName" ref="a01f9441b454deb1dec9dfa6eebca935b" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ValidatingReader.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21938e7ba64b1704e3233852846dfcf"></a><!-- doxytag: member="avro::constructResolver" ref="ab21938e7ba64b1704e3233852846dfcf" args="(const ValidSchema &amp;rwriterSchema, const ValidSchema &amp;readerSchema, const Layout &amp;readerLayout)" -->
<a class="el" href="classavro_1_1Resolver.html">Resolver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;rwriterSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83ca7f599d09b940bd236e77aa508381"></a><!-- doxytag: member="avro::isPrimitive" ref="a83ca7f599d09b940bd236e77aa508381" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isPrimitive</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a183aa500a8985117239abdc5922d8602"></a><!-- doxytag: member="avro::isCompound" ref="a183aa500a8985117239abdc5922d8602" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isCompound</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e596e801aaf532e26895ad9d7bfcdb1"></a><!-- doxytag: member="avro::isAvroType" ref="a5e596e801aaf532e26895ad9d7bfcdb1" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66c7c7a5f5cdbacf66009aa4a8079ef"></a><!-- doxytag: member="avro::isAvroTypeOrPseudoType" ref="ae66c7c7a5f5cdbacf66009aa4a8079ef" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroTypeOrPseudoType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b087ab950b8385296b2800f47ba4a98"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4b087ab950b8385296b2800f47ba4a98" args="(std::ostream &amp;os, avro::Type type)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, avro::Type type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab8b3abddb0a14d47cbe76214488d7b"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4ab8b3abddb0a14d47cbe76214488d7b" args="(std::ostream &amp;os, const Null &amp;null)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6114e4d5179ae6ac739e71223a0714"></a><!-- doxytag: member="avro::encodeZigzag64" ref="afe6114e4d5179ae6ac739e71223a0714" args="(int64_t input)" -->
uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834bf573771265b5f919982aa13a9252"></a><!-- doxytag: member="avro::decodeZigzag64" ref="a834bf573771265b5f919982aa13a9252" args="(uint64_t input)" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8987f354cd4d0611c0630d8ab1671fa"></a><!-- doxytag: member="avro::encodeZigzag32" ref="ad8987f354cd4d0611c0630d8ab1671fa" args="(int32_t input)" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab741dd5f13c174cfbd5a328dc47ef9"></a><!-- doxytag: member="avro::decodeZigzag32" ref="a4ab741dd5f13c174cfbd5a328dc47ef9" args="(uint32_t input)" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc335f3d911f17263b1b3b8181f0e25"></a><!-- doxytag: member="avro::encodeInt32" ref="aabc335f3d911f17263b1b3b8181f0e25" args="(int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6194251ac5f7be7616666cebb2f7d0"></a><!-- doxytag: member="avro::encodeInt64" ref="afc6194251ac5f7be7616666cebb2f7d0" args="(int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
<br/><br/></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0136e9ae2b312d9f9642e491eceac67c">parse</a> (<a class="el" href="classavro_1_1Reader.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain.  <a href="#a0136e9ae2b312d9f9642e491eceac67c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7792d346a1a142279b846cb9fe0092f"></a><!-- doxytag: member="avro::parse" ref="ae7792d346a1a142279b846cb9fe0092f" args="(Reader &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Reader &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1Reader.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1c8ebfc19da2ecad1fd2e5ae21fe450"></a><!-- doxytag: member="avro::translatingParse" ref="ad1c8ebfc19da2ecad1fd2e5ae21fe450" args="(ResolvingReader &amp;p, T &amp;val, const boost::true_type &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3711f06e890ef4fd38031601143d4a75"></a><!-- doxytag: member="avro::serialize" ref="a3711f06e890ef4fd38031601143d4a75" args="(Writer &amp;s, T val, const boost::true_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a3711f06e890ef4fd38031601143d4a75">serialize</a> (<a class="el" href="classavro_1_1Writer.html">Writer</a> &amp;s, T val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a55afd164df3c36cb7c36323e5c2549ee"></a><!-- doxytag: member="avro::serialize" ref="a55afd164df3c36cb7c36323e5c2549ee" args="(Writer &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Writer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1Writer.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. </p>
<p>See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad17da92a723dce9b89e7c845749615b3"></a><!-- doxytag: member="avro::SchemaResolution" ref="ad17da92a723dce9b89e7c845749615b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a><!-- doxytag: member="RESOLVE_NO_MATCH" ref="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175" args="" -->RESOLVE_NO_MATCH</em>&nbsp;</td><td>
<p>The schemas definitely do not match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a><!-- doxytag: member="RESOLVE_MATCH" ref="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d" args="" -->RESOLVE_MATCH</em>&nbsp;</td><td>
<p>The schemas match at a cursory level. </p>
<p>For records and enums, this means the name is the same, but it does not necessarily mean that every symbol or field is an exact match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a><!-- doxytag: member="RESOLVE_PROMOTABLE_TO_LONG" ref="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74" args="" -->RESOLVE_PROMOTABLE_TO_LONG</em>&nbsp;</td><td>
<p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac42e03a03cf7f4d975f8913f9e9188d7"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac42e03a03cf7f4d975f8913f9e9188d7" args="(std::istream &amp;is, ValidSchema &amp;schema, std::string &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a class="anchor" id="ac736c901800fa085e133118b238f6b46"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac736c901800fa085e133118b238f6b46" args="(std::istream &amp;is, ValidSchema &amp;schema)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a class="anchor" id="a0136e9ae2b312d9f9642e491eceac67c"></a><!-- doxytag: member="avro::parse" ref="a0136e9ae2b312d9f9642e491eceac67c" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. </p>
<p>The remainder of the file includes default implementations for serializable types. </p>

</div>
</div>
<a class="anchor" id="a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><!-- doxytag: member="avro::parse" ref="a4b63a28bf43eaf3bab0cbe639ea1a5fe" args="(Reader &amp;p, T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a class="anchor" id="af8f98882bd10d711f84ff8759aed4132"></a><!-- doxytag: member="avro::serialize" ref="af8f98882bd10d711f84ff8759aed4132" args="(Writer &amp;s, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::serialize </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Tue Feb 23 15:31:29 2010 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
