<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>avro Namespace Reference</h1>
<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  
<a href="#_details">More...</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node.">NodeImpl</a>. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerContext.html">CompilerContext</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to implement an avro spec parser using a flex/bison compiler.  <a href="classavro_1_1CompilerContext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a generic "untyped" node that may store values for all possible attributes of Avro complex types.  <a href="classavro_1_1CompilerNode.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a>.  <a href="classavro_1_1NodeImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses from an avro encoding to the requested type.  <a href="classavro_1_1ReaderImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a Writer or ValidatingWriter with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolMap.html">SymbolMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Avro schemas can include types that were previously defined with names in the same avro schema.  <a href="classavro_1_1SymbolMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define a type to identify <a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions">Null</a> in template functions  <a href="structavro_1_1Null.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> that has passed some minumum of sanity checks.  <a href="classavro_1_1ValidSchema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullValidator.html">NullValidator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for writing avro data to a stream.  <a href="classavro_1_1WriterImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ostreambuf.html">ostreambuf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of streambuf for use by the Buffer's ostream.  <a href="classavro_1_1ostreambuf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1istreambuf.html">istreambuf</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of streambuf for use by the Buffer's istream.  <a href="classavro_1_1istreambuf.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ostream.html">ostream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom ostream class for writing to an <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a>.  <a href="classavro_1_1ostream.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1istream.html">istream</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Custom istream class for reading from an <a class="el" href="classavro_1_1InputBuffer.html" title="The InputBuffer (read-only buffer).">InputBuffer</a>.  <a href="classavro_1_1istream.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html">OutputBuffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a> (write-only buffer).  <a href="classavro_1_1OutputBuffer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputBuffer.html">InputBuffer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classavro_1_1InputBuffer.html" title="The InputBuffer (read-only buffer).">InputBuffer</a> (read-only buffer).  <a href="classavro_1_1InputBuffer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BufferReader.html">BufferReader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper class for reading bytes from buffer without worrying about chunk boundaries.  <a href="classavro_1_1BufferReader.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c572cb71b20e20e429257209a42f91"></a><!-- doxytag: member="avro::NodePtr" ref="a53c572cb71b20e20e429257209a42f91" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3dab217e1e37f983741ae7b04da7d7"></a><!-- doxytag: member="avro::NoName" ref="aeb3dab217e1e37f983741ae7b04da7d7" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8488eb7757ab103913c453edccd5c904"></a><!-- doxytag: member="avro::HasName" ref="a8488eb7757ab103913c453edccd5c904" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85148fbeb2b2e17c9ad5bc357f16aff"></a><!-- doxytag: member="avro::NoLeaves" ref="ac85148fbeb2b2e17c9ad5bc357f16aff" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cf21198637dd41d9099615f32854c7"></a><!-- doxytag: member="avro::SingleLeaf" ref="a71cf21198637dd41d9099615f32854c7" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd609b669d85b5209ccbc21cd8ef8945"></a><!-- doxytag: member="avro::MultiLeaves" ref="afd609b669d85b5209ccbc21cd8ef8945" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6da0159d149557988b1a7e40773d9b"></a><!-- doxytag: member="avro::NoLeafNames" ref="a5b6da0159d149557988b1a7e40773d9b" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa436fd2c922cd09d74494180f669e034"></a><!-- doxytag: member="avro::LeafNames" ref="aa436fd2c922cd09d74494180f669e034" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfce3e38687f7603287dd60dc271252"></a><!-- doxytag: member="avro::NoSize" ref="aecfce3e38687f7603287dd60dc271252" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fa86efe35f9ecda21bb1849da70f05"></a><!-- doxytag: member="avro::HasSize" ref="a46fa86efe35f9ecda21bb1849da70f05" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea022243932db4fd5cf9d387644bb6ce"></a><!-- doxytag: member="avro::NodeImplPrimitive" ref="aea022243932db4fd5cf9d387644bb6ce" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0020a7a6d3590c6e20305780e1f8105"></a><!-- doxytag: member="avro::NodeImplSymbolic" ref="ae0020a7a6d3590c6e20305780e1f8105" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095db2b00faf42c54eff9ddca916f664"></a><!-- doxytag: member="avro::NodeImplRecord" ref="a095db2b00faf42c54eff9ddca916f664" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c214009072cd60af44ebc912d3c72b"></a><!-- doxytag: member="avro::NodeImplEnum" ref="a94c214009072cd60af44ebc912d3c72b" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c70cd3863feee6699197aab1dac75"></a><!-- doxytag: member="avro::NodeImplArray" ref="aa04c70cd3863feee6699197aab1dac75" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f276e8d8fd426534c06c8b351780e7"></a><!-- doxytag: member="avro::NodeImplMap" ref="a88f276e8d8fd426534c06c8b351780e7" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4e7bbdf8250ea8481e5e6222e57918"></a><!-- doxytag: member="avro::NodeImplUnion" ref="a1c4e7bbdf8250ea8481e5e6222e57918" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c3e3db25d7e71e41742bb70eaea2db"></a><!-- doxytag: member="avro::NodeImplFixed" ref="ad7c3e3db25d7e71e41742bb70eaea2db" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace6d357bce9a8329f8b4f52bb5b7e366"></a><!-- doxytag: member="avro::Reader" ref="ace6d357bce9a8329f8b4f52bb5b7e366" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Reader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20de889520d0e7006b1c83aad1fc929"></a><!-- doxytag: member="avro::ValidatingReader" ref="ae20de889520d0e7006b1c83aad1fc929" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValidatingReader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a5fe95b057b10bdad444b383bf556b"></a><!-- doxytag: member="avro::Writer" ref="a50a5fe95b057b10bdad444b383bf556b" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Writer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c844697fdbee2981c59c5c32acd054"></a><!-- doxytag: member="avro::ValidatingWriter" ref="a86c844697fdbee2981c59c5c32acd054" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValidatingWriter</b></td></tr>
<tr><td colspan="2"><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br/>
&nbsp;&nbsp;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br/>
&nbsp;&nbsp;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <br/>
&nbsp;&nbsp;<b>AVRO_STRING</b>, 
<b>AVRO_BYTES</b>, 
<b>AVRO_INT</b>, 
<b>AVRO_LONG</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_FLOAT</b>, 
<b>AVRO_DOUBLE</b>, 
<b>AVRO_BOOL</b>, 
<b>AVRO_NULL</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_RECORD</b>, 
<b>AVRO_ENUM</b>, 
<b>AVRO_ARRAY</b>, 
<b>AVRO_MAP</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_UNION</b>, 
<b>AVRO_FIXED</b>, 
<b>AVRO_NUM_TYPES</b>, 
<b>AVRO_SYMBOLIC</b> =  AVRO_NUM_TYPES, 
<br/>
&nbsp;&nbsp;<b>AVRO_UNKNOWN</b> =  -1
<br/>
 }</td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4b63a28bf43eaf3bab0cbe639ea1a5fe">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main parse entry point function.  <a href="#a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c60c4bde54ec7db8e087420267eb5c3"></a><!-- doxytag: member="avro::parse" ref="a3c60c4bde54ec7db8e087420267eb5c3" args="(ResolvingReader &amp;p, T &amp;val)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a0136e9ae2b312d9f9642e491eceac67c"></a><!-- doxytag: member="avro::parse" ref="a0136e9ae2b312d9f9642e491eceac67c" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0136e9ae2b312d9f9642e491eceac67c">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const boost::false_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5a699390b6a6222a730cd732cb7cfb9"></a><!-- doxytag: member="avro::translatingParse" ref="aa5a699390b6a6222a730cd732cb7cfb9" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const boost::false_type &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#af8f98882bd10d711f84ff8759aed4132">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main serializer entry point function.  <a href="#af8f98882bd10d711f84ff8759aed4132"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a102d33293438774ae1f90cdff99a8a45"></a><!-- doxytag: member="avro::serialize" ref="a102d33293438774ae1f90cdff99a8a45" args="(Writer &amp;s, const T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a102d33293438774ae1f90cdff99a8a45">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val, const boost::false_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac736c901800fa085e133118b238f6b46">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> object.  <a href="#ac736c901800fa085e133118b238f6b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac42e03a03cf7f4d975f8913f9e9188d7">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="#ac42e03a03cf7f4d975f8913f9e9188d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b81e6a83479456a1e67ef7c7414413"></a><!-- doxytag: member="avro::nodeFromCompilerNode" ref="af9b81e6a83479456a1e67ef7c7414413" args="(CompilerNode &amp;compilerNode)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>nodeFromCompilerNode</b> (<a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a> &amp;compilerNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb0c98243cbfe723262a61c747e858b"></a><!-- doxytag: member="avro::resolveSymbol" ref="a1fb0c98243cbfe723262a61c747e858b" args="(const NodePtr &amp;node)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58cb2d5a007fb9634a3878af7b32c398"></a><!-- doxytag: member="avro::nextType" ref="a58cb2d5a007fb9634a3878af7b32c398" args="(Parser&lt; ValidatingReader &gt; &amp;p)" -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e8d0ef60e0b85451fccf401289492f"></a><!-- doxytag: member="avro::currentRecordName" ref="a95e8d0ef60e0b85451fccf401289492f" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f9441b454deb1dec9dfa6eebca935b"></a><!-- doxytag: member="avro::nextFieldName" ref="a01f9441b454deb1dec9dfa6eebca935b" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21938e7ba64b1704e3233852846dfcf"></a><!-- doxytag: member="avro::constructResolver" ref="ab21938e7ba64b1704e3233852846dfcf" args="(const ValidSchema &amp;rwriterSchema, const ValidSchema &amp;readerSchema, const Layout &amp;readerLayout)" -->
<a class="el" href="classavro_1_1Resolver.html">Resolver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;rwriterSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83ca7f599d09b940bd236e77aa508381"></a><!-- doxytag: member="avro::isPrimitive" ref="a83ca7f599d09b940bd236e77aa508381" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isPrimitive</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a183aa500a8985117239abdc5922d8602"></a><!-- doxytag: member="avro::isCompound" ref="a183aa500a8985117239abdc5922d8602" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isCompound</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e596e801aaf532e26895ad9d7bfcdb1"></a><!-- doxytag: member="avro::isAvroType" ref="a5e596e801aaf532e26895ad9d7bfcdb1" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66c7c7a5f5cdbacf66009aa4a8079ef"></a><!-- doxytag: member="avro::isAvroTypeOrPseudoType" ref="ae66c7c7a5f5cdbacf66009aa4a8079ef" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroTypeOrPseudoType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b087ab950b8385296b2800f47ba4a98"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4b087ab950b8385296b2800f47ba4a98" args="(std::ostream &amp;os, avro::Type type)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, avro::Type type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab8b3abddb0a14d47cbe76214488d7b"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4ab8b3abddb0a14d47cbe76214488d7b" args="(std::ostream &amp;os, const Null &amp;null)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6114e4d5179ae6ac739e71223a0714"></a><!-- doxytag: member="avro::encodeZigzag64" ref="afe6114e4d5179ae6ac739e71223a0714" args="(int64_t input)" -->
uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834bf573771265b5f919982aa13a9252"></a><!-- doxytag: member="avro::decodeZigzag64" ref="a834bf573771265b5f919982aa13a9252" args="(uint64_t input)" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8987f354cd4d0611c0630d8ab1671fa"></a><!-- doxytag: member="avro::encodeZigzag32" ref="ad8987f354cd4d0611c0630d8ab1671fa" args="(int32_t input)" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab741dd5f13c174cfbd5a328dc47ef9"></a><!-- doxytag: member="avro::decodeZigzag32" ref="a4ab741dd5f13c174cfbd5a328dc47ef9" args="(uint32_t input)" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc335f3d911f17263b1b3b8181f0e25"></a><!-- doxytag: member="avro::encodeInt32" ref="aabc335f3d911f17263b1b3b8181f0e25" args="(int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6194251ac5f7be7616666cebb2f7d0"></a><!-- doxytag: member="avro::encodeInt64" ref="afc6194251ac5f7be7616666cebb2f7d0" args="(int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BufferType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a8ad7f20bacf8a5dc4371f6975774bf53">toIovec</a> (BufferType &amp;buf, std::vector&lt; struct iovec &gt; &amp;iov)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array of iovec structures from the buffer.  <a href="#a8ad7f20bacf8a5dc4371f6975774bf53"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a36e406ce0e3e5d1e4793ee061e04b897"></a><!-- doxytag: member="avro::parse" ref="a36e406ce0e3e5d1e4793ee061e04b897" args="(Reader &amp;p, T &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a36e406ce0e3e5d1e4793ee061e04b897">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const boost::true_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7792d346a1a142279b846cb9fe0092f"></a><!-- doxytag: member="avro::parse" ref="ae7792d346a1a142279b846cb9fe0092f" args="(Reader &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Reader &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1c8ebfc19da2ecad1fd2e5ae21fe450"></a><!-- doxytag: member="avro::translatingParse" ref="ad1c8ebfc19da2ecad1fd2e5ae21fe450" args="(ResolvingReader &amp;p, T &amp;val, const boost::true_type &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const boost::true_type &amp;)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3711f06e890ef4fd38031601143d4a75"></a><!-- doxytag: member="avro::serialize" ref="a3711f06e890ef4fd38031601143d4a75" args="(Writer &amp;s, T val, const boost::true_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a3711f06e890ef4fd38031601143d4a75">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, T val, const boost::true_type &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a55afd164df3c36cb7c36323e5c2549ee"></a><!-- doxytag: member="avro::serialize" ref="a55afd164df3c36cb7c36323e5c2549ee" args="(Writer &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Writer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. </p>
<p>See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad17da92a723dce9b89e7c845749615b3"></a><!-- doxytag: member="avro::SchemaResolution" ref="ad17da92a723dce9b89e7c845749615b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a><!-- doxytag: member="RESOLVE_NO_MATCH" ref="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175" args="" -->RESOLVE_NO_MATCH</em>&nbsp;</td><td>
<p>The schemas definitely do not match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a><!-- doxytag: member="RESOLVE_MATCH" ref="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d" args="" -->RESOLVE_MATCH</em>&nbsp;</td><td>
<p>The schemas match at a cursory level. </p>
<p>For records and enums, this means the name is the same, but it does not necessarily mean that every symbol or field is an exact match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a><!-- doxytag: member="RESOLVE_PROMOTABLE_TO_LONG" ref="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74" args="" -->RESOLVE_PROMOTABLE_TO_LONG</em>&nbsp;</td><td>
<p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac42e03a03cf7f4d975f8913f9e9188d7"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac42e03a03cf7f4d975f8913f9e9188d7" args="(std::istream &amp;is, ValidSchema &amp;schema, std::string &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a class="anchor" id="ac736c901800fa085e133118b238f6b46"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac736c901800fa085e133118b238f6b46" args="(std::istream &amp;is, ValidSchema &amp;schema)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity...">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a class="anchor" id="a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><!-- doxytag: member="avro::parse" ref="a4b63a28bf43eaf3bab0cbe639ea1a5fe" args="(Reader &amp;p, T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a class="anchor" id="af8f98882bd10d711f84ff8759aed4132"></a><!-- doxytag: member="avro::serialize" ref="af8f98882bd10d711f84ff8759aed4132" args="(Writer &amp;s, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::serialize </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
<a class="anchor" id="a8ad7f20bacf8a5dc4371f6975774bf53"></a><!-- doxytag: member="avro::toIovec" ref="a8ad7f20bacf8a5dc4371f6975774bf53" args="(BufferType &amp;buf, std::vector&lt; struct iovec &gt; &amp;iov)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BufferType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::toIovec </td>
          <td>(</td>
          <td class="paramtype">BufferType &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; struct iovec &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iov</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create an array of iovec structures from the buffer. </p>
<p>This utility is used to support writev and readv function calls. The caller should ensure the buffer object is not deleted while using the iovec vector.</p>
<p>If the BufferType is an <a class="el" href="classavro_1_1InputBuffer.html" title="The InputBuffer (read-only buffer).">InputBuffer</a>, the iovec will point to the data that already exists in the buffer, for reading.</p>
<p>If the BufferType is an <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a>, the iovec will point to the free space, which may be written to. Before writing, the caller should call <a class="el" href="classavro_1_1OutputBuffer.html#a17f9b58f68ef201d6a85fe931eec4d65" title="Reserve enough space for a wroteTo() operation.">OutputBuffer::reserve()</a> to create enough room for the desired write (which can be verified by calling <a class="el" href="classavro_1_1OutputBuffer.html#a8f3d3641b187c6f3aa525851baae2b20" title="Returns the current free space that is available to write to in the buffer, in bytes...">OutputBuffer::freeSpace()</a>), and after writing, they MUST call <a class="el" href="classavro_1_1OutputBuffer.html#aee949a8e2f5e88266f5c15412efa6423" title="Update the state of the buffer after writing through the iterator interface.">OutputBuffer::wroteTo()</a>, otherwise the buffer will not know the space is not free anymore. </p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Oct 8 14:36:18 2010 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
