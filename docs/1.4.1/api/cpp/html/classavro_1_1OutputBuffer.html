<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro::OutputBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceavro.html">avro</a>::<a class="el" href="classavro_1_1OutputBuffer.html">OutputBuffer</a>
  </div>
</div>
<div class="contents">
<h1>avro::OutputBuffer Class Reference</h1><!-- doxytag: class="avro::OutputBuffer" -->
<p>The <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a> (write-only buffer).  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Buffer_8hh_source.html">Buffer.hh</a>&gt;</code></p>

<p><a href="classavro_1_1OutputBuffer-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6e741df867e68f808e8b55ecb74e6d0"></a><!-- doxytag: member="avro::OutputBuffer::size_type" ref="ae6e741df867e68f808e8b55ecb74e6d0" args="" -->
typedef detail::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5379d01a62a7012c8cbd95c017b212a7"></a><!-- doxytag: member="avro::OutputBuffer::data_type" ref="a5379d01a62a7012c8cbd95c017b212a7" args="" -->
typedef detail::data_type&nbsp;</td><td class="memItemRight" valign="bottom"><b>data_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="classavro_1_1detail_1_1BufferIterator.html">detail::OutputBufferIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#ae67c361fc5b6f268fd12d85a55b86a64">const_iterator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The asio library expects a const_iterator (the const-ness refers to the fact that the underlying avro of buffers will not be modified, even though the data in those buffers is being modified).  <a href="#ae67c361fc5b6f268fd12d85a55b86a64"></a><br/></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a99b1279b6bbd3e531b71dfa79d71d074">OutputBuffer</a> (size_type reserveSize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor.  <a href="#a99b1279b6bbd3e531b71dfa79d71d074"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a17f9b58f68ef201d6a85fe931eec4d65">reserve</a> (size_type reserveSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reserve enough space for a <a class="el" href="classavro_1_1OutputBuffer.html#aee949a8e2f5e88266f5c15412efa6423" title="Update the state of the buffer after writing through the iterator interface.">wroteTo()</a> operation.  <a href="#a17f9b58f68ef201d6a85fe931eec4d65"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#ade76beaf218ebccdc9e7ec189b092728">writeTo</a> (const data_type *data, size_type size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a block of data to the buffer.  <a href="#ade76beaf218ebccdc9e7ec189b092728"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#ad564f0e3e833d93368447635a53871cd">writeTo</a> (T val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a single value to the buffer.  <a href="#ad564f0e3e833d93368447635a53871cd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#aee949a8e2f5e88266f5c15412efa6423">wroteTo</a> (size_type size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Update the state of the buffer after writing through the iterator interface.  <a href="#aee949a8e2f5e88266f5c15412efa6423"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9399f105de6f35bdde384ceb96c88b"></a><!-- doxytag: member="avro::OutputBuffer::empty" ref="aeb9399f105de6f35bdde384ceb96c88b" args="() const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#aeb9399f105de6f35bdde384ceb96c88b">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does the buffer have any data? <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aada0bd56bed5196a37d366baa20f34ed"></a><!-- doxytag: member="avro::OutputBuffer::size" ref="aada0bd56bed5196a37d366baa20f34ed" args="() const " -->
size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#aada0bd56bed5196a37d366baa20f34ed">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the size of the buffer, in bytes. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a8f3d3641b187c6f3aa525851baae2b20">freeSpace</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the current free space that is available to write to in the buffer, in bytes.  <a href="#a8f3d3641b187c6f3aa525851baae2b20"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BufferType &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a02aa3adf2d5f0ca56776dc636ffc9cef">append</a> (const BufferType &amp;buf)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Appends the data in the argument to the end of this buffer.  <a href="#a02aa3adf2d5f0ca56776dc636ffc9cef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04fcee45f1da6eb44e918501a10a80c9"></a><!-- doxytag: member="avro::OutputBuffer::begin" ref="a04fcee45f1da6eb44e918501a10a80c9" args="() const " -->
<a class="el" href="classavro_1_1detail_1_1BufferIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a04fcee45f1da6eb44e918501a10a80c9">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return an iterator pointing to the first data chunk of this buffer that may be written to. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2754e66672a37a681ba4994d86713d74"></a><!-- doxytag: member="avro::OutputBuffer::end" ref="a2754e66672a37a681ba4994d86713d74" args="() const " -->
<a class="el" href="classavro_1_1detail_1_1BufferIterator.html">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a2754e66672a37a681ba4994d86713d74">end</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the end iterator for writing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a053280750f03b1f4b8a1d5fe0d3bfc49"></a><!-- doxytag: member="avro::OutputBuffer::discardData" ref="a053280750f03b1f4b8a1d5fe0d3bfc49" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a053280750f03b1f4b8a1d5fe0d3bfc49">discardData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard any data in this buffer. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a69b42aea801dc308737003fdff7fc97d">discardData</a> (size_t bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Discard the specified number of bytes from this data, starting at the beginning.  <a href="#a69b42aea801dc308737003fdff7fc97d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavro_1_1InputBuffer.html">InputBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a8fbe9fc9167c6df43601f01d49b80bab">extractData</a> (size_type bytes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove bytes from this buffer, starting from the beginning, and place them into a new buffer.  <a href="#a8fbe9fc9167c6df43601f01d49b80bab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classavro_1_1InputBuffer.html">InputBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a9505cdad23cf1fe6d17bb98fb3bc2cc6">extractData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove all bytes from this buffer, returning them in a new buffer.  <a href="#a9505cdad23cf1fe6d17bb98fb3bc2cc6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e7e55053504852314c499637122a630"></a><!-- doxytag: member="avro::OutputBuffer::clone" ref="a2e7e55053504852314c499637122a630" args="() const " -->
<a class="el" href="classavro_1_1OutputBuffer.html">OutputBuffer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a2e7e55053504852314c499637122a630">clone</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clone this buffer, creating a copy that contains the same data. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#afa42d78b0d86e2783ce273a1e16f6b26">appendForeignData</a> (const data_type *data, size_type size, const detail::free_func &amp;func)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add unmanaged data to the buffer.  <a href="#afa42d78b0d86e2783ce273a1e16f6b26"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc97f1d6ccfdb85030604f4a4962c44a"></a><!-- doxytag: member="avro::OutputBuffer::numChunks" ref="adc97f1d6ccfdb85030604f4a4962c44a" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#adc97f1d6ccfdb85030604f4a4962c44a">numChunks</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of chunks that contain free space. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a295597196c670d53029718aac6ea4638"></a><!-- doxytag: member="avro::OutputBuffer::numDataChunks" ref="a295597196c670d53029718aac6ea4638" args="() const " -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputBuffer.html#a295597196c670d53029718aac6ea4638">numDataChunks</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of chunks that contain data. <br/></td></tr>
<tr><td colspan="2"><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83a4a38314ec4a45eb0a74b10c86040c"></a><!-- doxytag: member="avro::OutputBuffer::InputBuffer" ref="a83a4a38314ec4a45eb0a74b10c86040c" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>InputBuffer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa436af30f45f3443c1e080a78601915"></a><!-- doxytag: member="avro::OutputBuffer::BufferReader" ref="aaa436af30f45f3443c1e080a78601915" args="" -->
class&nbsp;</td><td class="memItemRight" valign="bottom"><b>BufferReader</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>The <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a> (write-only buffer). </p>
<p>Use cases for <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a></p>
<ul>
<li>write message to buffer using ostream class or directly</li>
<li>append messages to headers</li>
<li>building up streams of messages via append</li>
<li>converting to read-only buffers for sending</li>
<li>extracting parts of the messages into read-only buffers</li>
</ul>
<ol type="1">
<li>ASIO access:<ul>
<li>write to a buffer(s) by asio using iterator</li>
<li>convert to read buffer for deserializing</li>
</ul>
</li>
</ol>
<p><a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a> is assignable and copy-constructable. On copy or assignment, only a pointer is copied, so the two resulting copies are identical, so modifying one will modify both. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae67c361fc5b6f268fd12d85a55b86a64"></a><!-- doxytag: member="avro::OutputBuffer::const_iterator" ref="ae67c361fc5b6f268fd12d85a55b86a64" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classavro_1_1detail_1_1BufferIterator.html">detail::OutputBufferIterator</a> <a class="el" href="classavro_1_1detail_1_1BufferIterator.html">avro::OutputBuffer::const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The asio library expects a const_iterator (the const-ness refers to the fact that the underlying avro of buffers will not be modified, even though the data in those buffers is being modified). </p>
<p>The iterator provides the list of addresses an operation can write to. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a99b1279b6bbd3e531b71dfa79d71d074"></a><!-- doxytag: member="avro::OutputBuffer::OutputBuffer" ref="a99b1279b6bbd3e531b71dfa79d71d074" args="(size_type reserveSize=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">avro::OutputBuffer::OutputBuffer </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>reserveSize</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Will pre-allocate at least the requested size, but can grow larger on demand.</p>
<p>Destructor uses the default, which resets a shared pointer, deleting the underlying data if no other copies of exist.</p>
<p>Copy and assignment operators are not explicitly provided because the default ones work fine. The default makes only a shallow copy, so the copies will refer to the same memory. This is required by asio functions, which will implicitly make copies for asynchronous operations. Therefore, the user must be careful that if they create multiple copies of the same <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a>, only one is being modified otherwise undefined behavior may occur. </p>

<p>References <a class="el" href="Buffer_8hh_source.html#l00112">reserve()</a>.</p>

<p>Referenced by <a class="el" href="Buffer_8hh_source.html#l00268">clone()</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a02aa3adf2d5f0ca56776dc636ffc9cef"></a><!-- doxytag: member="avro::OutputBuffer::append" ref="a02aa3adf2d5f0ca56776dc636ffc9cef" args="(const BufferType &amp;buf)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BufferType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::OutputBuffer::append </td>
          <td>(</td>
          <td class="paramtype">const BufferType &amp;&nbsp;</td>
          <td class="paramname"> <em>buf</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends the data in the argument to the end of this buffer. </p>
<p>The argument can be either an <a class="el" href="classavro_1_1InputBuffer.html" title="The InputBuffer (read-only buffer).">InputBuffer</a> or <a class="el" href="classavro_1_1OutputBuffer.html" title="The OutputBuffer (write-only buffer).">OutputBuffer</a>. </p>

</div>
</div>
<a class="anchor" id="afa42d78b0d86e2783ce273a1e16f6b26"></a><!-- doxytag: member="avro::OutputBuffer::appendForeignData" ref="afa42d78b0d86e2783ce273a1e16f6b26" args="(const data_type *data, size_type size, const detail::free_func &amp;func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::OutputBuffer::appendForeignData </td>
          <td>(</td>
          <td class="paramtype">const data_type *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const detail::free_func &amp;&nbsp;</td>
          <td class="paramname"> <em>func</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add unmanaged data to the buffer. </p>
<p>The buffer will not automatically free the data, but it will call the supplied function when the data is no longer referenced by the buffer (or copies of the buffer). </p>

</div>
</div>
<a class="anchor" id="a69b42aea801dc308737003fdff7fc97d"></a><!-- doxytag: member="avro::OutputBuffer::discardData" ref="a69b42aea801dc308737003fdff7fc97d" args="(size_t bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::OutputBuffer::discardData </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Discard the specified number of bytes from this data, starting at the beginning. </p>
<p>Throws if the size is greater than the number of bytes. </p>

<p>References <a class="el" href="Buffer_8hh_source.html#l00174">size()</a>.</p>

</div>
</div>
<a class="anchor" id="a9505cdad23cf1fe6d17bb98fb3bc2cc6"></a><!-- doxytag: member="avro::OutputBuffer::extractData" ref="a9505cdad23cf1fe6d17bb98fb3bc2cc6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavro_1_1InputBuffer.html">InputBuffer</a> avro::OutputBuffer::extractData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove all bytes from this buffer, returning them in a new buffer. </p>
<p>After removing data, some freeSpace may remain in this buffer. </p>

</div>
</div>
<a class="anchor" id="a8fbe9fc9167c6df43601f01d49b80bab"></a><!-- doxytag: member="avro::OutputBuffer::extractData" ref="a8fbe9fc9167c6df43601f01d49b80bab" args="(size_type bytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classavro_1_1InputBuffer.html">InputBuffer</a> avro::OutputBuffer::extractData </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>bytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove bytes from this buffer, starting from the beginning, and place them into a new buffer. </p>
<p>Throws if the number of requested bytes exceeds the size of the buffer. Data and freeSpace in the buffer after bytes remains in this buffer. </p>

<p>References <a class="el" href="Buffer_8hh_source.html#l00174">size()</a>.</p>

</div>
</div>
<a class="anchor" id="a8f3d3641b187c6f3aa525851baae2b20"></a><!-- doxytag: member="avro::OutputBuffer::freeSpace" ref="a8f3d3641b187c6f3aa525851baae2b20" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type avro::OutputBuffer::freeSpace </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the current free space that is available to write to in the buffer, in bytes. </p>
<p>This is not a strict limit in size, as <a class="el" href="classavro_1_1OutputBuffer.html#ade76beaf218ebccdc9e7ec189b092728" title="Write a block of data to the buffer.">writeTo()</a> can automatically increase capacity if necessary. </p>

<p>Referenced by <a class="el" href="Buffer_8hh_source.html#l00150">wroteTo()</a>.</p>

</div>
</div>
<a class="anchor" id="a17f9b58f68ef201d6a85fe931eec4d65"></a><!-- doxytag: member="avro::OutputBuffer::reserve" ref="a17f9b58f68ef201d6a85fe931eec4d65" args="(size_type reserveSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::OutputBuffer::reserve </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>reserveSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reserve enough space for a <a class="el" href="classavro_1_1OutputBuffer.html#aee949a8e2f5e88266f5c15412efa6423" title="Update the state of the buffer after writing through the iterator interface.">wroteTo()</a> operation. </p>
<p>When using <a class="el" href="classavro_1_1OutputBuffer.html#ade76beaf218ebccdc9e7ec189b092728" title="Write a block of data to the buffer.">writeTo()</a>, the buffer will grow dynamically as needed. But when using the iterator to write (followed by <a class="el" href="classavro_1_1OutputBuffer.html#aee949a8e2f5e88266f5c15412efa6423" title="Update the state of the buffer after writing through the iterator interface.">wroteTo()</a>), data may only be written to the space available, so this ensures there is enough room in the buffer before the write operation. </p>

<p>Referenced by <a class="el" href="Buffer_8hh_source.html#l00096">OutputBuffer()</a>.</p>

</div>
</div>
<a class="anchor" id="ad564f0e3e833d93368447635a53871cd"></a><!-- doxytag: member="avro::OutputBuffer::writeTo" ref="ad564f0e3e833d93368447635a53871cd" args="(T val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::OutputBuffer::writeTo </td>
          <td>(</td>
          <td class="paramtype">T&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a single value to the buffer. </p>
<p>The buffer size will automatically grow if there is not room for the byte. The value must be a "fundamental" type, e.g. int, float, etc. (otherwise use the other writeTo tests). </p>

</div>
</div>
<a class="anchor" id="ade76beaf218ebccdc9e7ec189b092728"></a><!-- doxytag: member="avro::OutputBuffer::writeTo" ref="ade76beaf218ebccdc9e7ec189b092728" args="(const data_type *data, size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type avro::OutputBuffer::writeTo </td>
          <td>(</td>
          <td class="paramtype">const data_type *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write a block of data to the buffer. </p>
<p>The buffer size will automatically grow if the size is larger than what is currently free. </p>

<p>Referenced by <a class="el" href="BufferStreambuf_8hh_source.html#l00063">avro::ostreambuf::overflow()</a>, and <a class="el" href="BufferStreambuf_8hh_source.html#l00070">avro::ostreambuf::xsputn()</a>.</p>

</div>
</div>
<a class="anchor" id="aee949a8e2f5e88266f5c15412efa6423"></a><!-- doxytag: member="avro::OutputBuffer::wroteTo" ref="aee949a8e2f5e88266f5c15412efa6423" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_type avro::OutputBuffer::wroteTo </td>
          <td>(</td>
          <td class="paramtype">size_type&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Update the state of the buffer after writing through the iterator interface. </p>
<p>This function exists primarily for the boost:asio which writes directly to the buffer using its iterator. In this case, the internal state of the buffer does not reflect that the data was written This informs the buffer how much data was written.</p>
<p>The buffer does not automatically resize in this case, the bytes written cannot exceed the amount of free space. Attempting to write more will throw a std::length_error exception. </p>

<p>References <a class="el" href="Buffer_8hh_source.html#l00184">freeSpace()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/cutting/src/avro/avro-1.4.1-rc0/lang/c++/api/buffer/<a class="el" href="Buffer_8hh_source.html">Buffer.hh</a></li>
</ul>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Oct 8 14:36:19 2010 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
