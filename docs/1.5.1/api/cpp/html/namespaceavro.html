<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avro C++: avro Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>avro Namespace Reference</h1>  </div>
</div>
<div class="contents">

<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>

<p><tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node.">NodeImpl</a>. </p>
<br/></td></tr>
</p>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerContext.html">CompilerContext</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used to implement an avro spec parser using a flex/bison compiler.  <a href="classavro_1_1CompilerContext.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a generic "untyped" node that may store values for all possible attributes of Avro complex types.  <a href="classavro_1_1CompilerNode.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriterBase.html">DataFileWriterBase</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type-independent portion of <a class="el" href="classavro_1_1DataFileWriter.html" title="An Avro datafile that can store objects of type T.">DataFileWriter</a>.  <a href="classavro_1_1DataFileWriterBase.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriter.html">DataFileWriter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An Avro datafile that can store objects of type T.  <a href="classavro_1_1DataFileWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReaderBase.html">DataFileReaderBase</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReader.html">DataFileReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html">Decoder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Encoder.html">Encoder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericDatum.html">GenericDatum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericContainer.html">GenericContainer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericRecord.html">GenericRecord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericArray.html">GenericArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericMap.html">GenericMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericEnum.html">GenericEnum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericFixed.html">GenericFixed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericReader.html">GenericReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericWriter.html">GenericWriter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html">codec_traits&lt; std::pair&lt; ValidSchema, GenericDatum &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a>.  <a href="classavro_1_1NodeImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses from an avro encoding to the requested type.  <a href="classavro_1_1ReaderImpl.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class that wraps a Writer or ValidatingWriter with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits.html">codec_traits</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01bool_01_4.html">codec_traits&lt; bool &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int32__t_01_4.html">codec_traits&lt; int32_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int64__t_01_4.html">codec_traits&lt; int64_t &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01float_01_4.html">codec_traits&lt; float &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01double_01_4.html">codec_traits&lt; double &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html">codec_traits&lt; std::string &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html">codec_traits&lt; std::vector&lt; uint8_t &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01boost_1_1array_3_01uint8__t_00_01N_01_4_01_4.html">codec_traits&lt; boost::array&lt; uint8_t, N &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html">codec_traits&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html">codec_traits&lt; std::map&lt; std::string, T &gt; &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputStream.html">InputStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputStream.html">OutputStream</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamReader.html">StreamReader</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience class for reading from an <a class="el" href="classavro_1_1InputStream.html">InputStream</a>.  <a href="structavro_1_1StreamReader.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamWriter.html">StreamWriter</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convinience class to write data into an <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>.  <a href="structavro_1_1StreamWriter.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolMap.html">SymbolMap</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Avro schemas can include types that were previously defined with names in the same avro schema.  <a href="classavro_1_1SymbolMap.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">define a type to identify <a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions">Null</a> in template functions  <a href="structavro_1_1Null.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullValidator.html">NullValidator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> that has passed some minumum of sanity checks.  <a href="classavro_1_1ValidSchema.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for writing avro data to a stream.  <a href="classavro_1_1WriterImpl.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee87abbccf24444198442e0ae2a9b01b"></a><!-- doxytag: member="avro::DataFileSync" ref="aee87abbccf24444198442e0ae2a9b01b" args="" -->
typedef boost::array&lt; uint8_t, 16 &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>DataFileSync</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a409dd1e501d982d3828c65ddf69b68b7"></a><!-- doxytag: member="avro::DecoderPtr" ref="a409dd1e501d982d3828c65ddf69b68b7" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Decoder.html">Decoder</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>DecoderPtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac16ed8c1d8bb7c68f40d2cd753a0a1b7"></a><!-- doxytag: member="avro::ResolvingDecoderPtr" ref="ac16ed8c1d8bb7c68f40d2cd753a0a1b7" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ResolvingDecoderPtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74279cf96c71ffd8f18d005c32ab8073"></a><!-- doxytag: member="avro::EncoderPtr" ref="a74279cf96c71ffd8f18d005c32ab8073" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Encoder.html">Encoder</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>EncoderPtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c572cb71b20e20e429257209a42f91"></a><!-- doxytag: member="avro::NodePtr" ref="a53c572cb71b20e20e429257209a42f91" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb3dab217e1e37f983741ae7b04da7d7"></a><!-- doxytag: member="avro::NoName" ref="aeb3dab217e1e37f983741ae7b04da7d7" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8488eb7757ab103913c453edccd5c904"></a><!-- doxytag: member="avro::HasName" ref="a8488eb7757ab103913c453edccd5c904" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85148fbeb2b2e17c9ad5bc357f16aff"></a><!-- doxytag: member="avro::NoLeaves" ref="ac85148fbeb2b2e17c9ad5bc357f16aff" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cf21198637dd41d9099615f32854c7"></a><!-- doxytag: member="avro::SingleLeaf" ref="a71cf21198637dd41d9099615f32854c7" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd609b669d85b5209ccbc21cd8ef8945"></a><!-- doxytag: member="avro::MultiLeaves" ref="afd609b669d85b5209ccbc21cd8ef8945" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6da0159d149557988b1a7e40773d9b"></a><!-- doxytag: member="avro::NoLeafNames" ref="a5b6da0159d149557988b1a7e40773d9b" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa436fd2c922cd09d74494180f669e034"></a><!-- doxytag: member="avro::LeafNames" ref="aa436fd2c922cd09d74494180f669e034" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfce3e38687f7603287dd60dc271252"></a><!-- doxytag: member="avro::NoSize" ref="aecfce3e38687f7603287dd60dc271252" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NoSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fa86efe35f9ecda21bb1849da70f05"></a><!-- doxytag: member="avro::HasSize" ref="a46fa86efe35f9ecda21bb1849da70f05" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>HasSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea022243932db4fd5cf9d387644bb6ce"></a><!-- doxytag: member="avro::NodeImplPrimitive" ref="aea022243932db4fd5cf9d387644bb6ce" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0020a7a6d3590c6e20305780e1f8105"></a><!-- doxytag: member="avro::NodeImplSymbolic" ref="ae0020a7a6d3590c6e20305780e1f8105" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095db2b00faf42c54eff9ddca916f664"></a><!-- doxytag: member="avro::NodeImplRecord" ref="a095db2b00faf42c54eff9ddca916f664" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c214009072cd60af44ebc912d3c72b"></a><!-- doxytag: member="avro::NodeImplEnum" ref="a94c214009072cd60af44ebc912d3c72b" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c70cd3863feee6699197aab1dac75"></a><!-- doxytag: member="avro::NodeImplArray" ref="aa04c70cd3863feee6699197aab1dac75" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f276e8d8fd426534c06c8b351780e7"></a><!-- doxytag: member="avro::NodeImplMap" ref="a88f276e8d8fd426534c06c8b351780e7" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4e7bbdf8250ea8481e5e6222e57918"></a><!-- doxytag: member="avro::NodeImplUnion" ref="a1c4e7bbdf8250ea8481e5e6222e57918" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c3e3db25d7e71e41742bb70eaea2db"></a><!-- doxytag: member="avro::NodeImplFixed" ref="ad7c3e3db25d7e71e41742bb70eaea2db" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace6d357bce9a8329f8b4f52bb5b7e366"></a><!-- doxytag: member="avro::Reader" ref="ace6d357bce9a8329f8b4f52bb5b7e366" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Reader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20de889520d0e7006b1c83aad1fc929"></a><!-- doxytag: member="avro::ValidatingReader" ref="ae20de889520d0e7006b1c83aad1fc929" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValidatingReader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a5fe95b057b10bdad444b383bf556b"></a><!-- doxytag: member="avro::Writer" ref="a50a5fe95b057b10bdad444b383bf556b" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Writer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c844697fdbee2981c59c5c32acd054"></a><!-- doxytag: member="avro::ValidatingWriter" ref="a86c844697fdbee2981c59c5c32acd054" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>ValidatingWriter</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br/>
&nbsp;&nbsp;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br/>
&nbsp;&nbsp;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>Type</b> { <br/>
&nbsp;&nbsp;<b>AVRO_STRING</b>, 
<b>AVRO_BYTES</b>, 
<b>AVRO_INT</b>, 
<b>AVRO_LONG</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_FLOAT</b>, 
<b>AVRO_DOUBLE</b>, 
<b>AVRO_BOOL</b>, 
<b>AVRO_NULL</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_RECORD</b>, 
<b>AVRO_ENUM</b>, 
<b>AVRO_ARRAY</b>, 
<b>AVRO_MAP</b>, 
<br/>
&nbsp;&nbsp;<b>AVRO_UNION</b>, 
<b>AVRO_FIXED</b>, 
<b>AVRO_NUM_TYPES</b>, 
<b>AVRO_SYMBOLIC</b> =  AVRO_NUM_TYPES, 
<br/>
&nbsp;&nbsp;<b>AVRO_UNKNOWN</b> =  -1
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4b63a28bf43eaf3bab0cbe639ea1a5fe">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main parse entry point function.  <a href="#a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3c60c4bde54ec7db8e087420267eb5c3"></a><!-- doxytag: member="avro::parse" ref="a3c60c4bde54ec7db8e087420267eb5c3" args="(ResolvingReader &amp;p, T &amp;val)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa5a699390b6a6222a730cd732cb7cfb9"></a><!-- doxytag: member="avro::translatingParse" ref="aa5a699390b6a6222a730cd732cb7cfb9" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#af8f98882bd10d711f84ff8759aed4132">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main serializer entry point function.  <a href="#af8f98882bd10d711f84ff8759aed4132"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a102d33293438774ae1f90cdff99a8a45"></a><!-- doxytag: member="avro::serialize" ref="a102d33293438774ae1f90cdff99a8a45" args="(Writer &amp;s, const T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a102d33293438774ae1f90cdff99a8a45">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac736c901800fa085e133118b238f6b46">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object.  <a href="#ac736c901800fa085e133118b238f6b46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac42e03a03cf7f4d975f8913f9e9188d7">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="#ac42e03a03cf7f4d975f8913f9e9188d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9b81e6a83479456a1e67ef7c7414413"></a><!-- doxytag: member="avro::nodeFromCompilerNode" ref="af9b81e6a83479456a1e67ef7c7414413" args="(CompilerNode &amp;compilerNode)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>nodeFromCompilerNode</b> (<a class="el" href="classavro_1_1CompilerNode.html">CompilerNode</a> &amp;compilerNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834a481e97053183a152590ef398cf10"></a><!-- doxytag: member="avro::binaryDecoder" ref="a834a481e97053183a152590ef398cf10" args="()" -->
DecoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a834a481e97053183a152590ef398cf10">binaryDecoder</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an decoder that can decode binary Avro standard. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78619c4c3a973b45ef294634b4e33305"></a><!-- doxytag: member="avro::validatingDecoder" ref="a78619c4c3a973b45ef294634b4e33305" args="(const ValidSchema &amp;schema, const DecoderPtr &amp;base)" -->
DecoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a78619c4c3a973b45ef294634b4e33305">validatingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const DecoderPtr &amp;base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an decoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Decoder.html">Decoder</a> against the given schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a687670ed2e756515b4684a00b6432c42"></a><!-- doxytag: member="avro::jsonDecoder" ref="a687670ed2e756515b4684a00b6432c42" args="(const ValidSchema &amp;schema)" -->
DecoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a687670ed2e756515b4684a00b6432c42">jsonDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an decoder that can decode Avro standard for JSON. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">ResolvingDecoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a37a740598b3f23bd0f75b5d4f54bc71b">resolvingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;writer, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;reader, const DecoderPtr &amp;base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema.  <a href="#a37a740598b3f23bd0f75b5d4f54bc71b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a792c26d856a0b75f04d8e20e0c06cc7e"></a><!-- doxytag: member="avro::binaryEncoder" ref="a792c26d856a0b75f04d8e20e0c06cc7e" args="()" -->
EncoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a792c26d856a0b75f04d8e20e0c06cc7e">binaryEncoder</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an encoder that can encode binary Avro standard. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0716bebb7833f3d3cda65f76abc97a4e"></a><!-- doxytag: member="avro::validatingEncoder" ref="a0716bebb7833f3d3cda65f76abc97a4e" args="(const ValidSchema &amp;schema, const EncoderPtr &amp;base)" -->
EncoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0716bebb7833f3d3cda65f76abc97a4e">validatingEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const EncoderPtr &amp;base)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an encoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Encoder.html">Encoder</a> against the given schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4f51c03c4ea8d5018078c223658421d"></a><!-- doxytag: member="avro::jsonEncoder" ref="aa4f51c03c4ea8d5018078c223658421d" args="(const ValidSchema &amp;schema)" -->
EncoderPtr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aa4f51c03c4ea8d5018078c223658421d">jsonEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an encoder that can encode Avro standard for JSON. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb0c98243cbfe723262a61c747e858b"></a><!-- doxytag: member="avro::resolveSymbol" ref="a1fb0c98243cbfe723262a61c747e858b" args="(const NodePtr &amp;node)" -->
NodePtr&nbsp;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58cb2d5a007fb9634a3878af7b32c398"></a><!-- doxytag: member="avro::nextType" ref="a58cb2d5a007fb9634a3878af7b32c398" args="(Parser&lt; ValidatingReader &gt; &amp;p)" -->
Type&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e8d0ef60e0b85451fccf401289492f"></a><!-- doxytag: member="avro::currentRecordName" ref="a95e8d0ef60e0b85451fccf401289492f" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f9441b454deb1dec9dfa6eebca935b"></a><!-- doxytag: member="avro::nextFieldName" ref="a01f9441b454deb1dec9dfa6eebca935b" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21938e7ba64b1704e3233852846dfcf"></a><!-- doxytag: member="avro::constructResolver" ref="ab21938e7ba64b1704e3233852846dfcf" args="(const ValidSchema &amp;rwriterSchema, const ValidSchema &amp;readerSchema, const Layout &amp;readerLayout)" -->
<a class="el" href="classavro_1_1Resolver.html">Resolver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;rwriterSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a8e44cb53ff0282b0314937ac4a800121"></a><!-- doxytag: member="avro::encode" ref="a8e44cb53ff0282b0314937ac4a800121" args="(Encoder &amp;e, const T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>encode</b> (<a class="el" href="classavro_1_1Encoder.html">Encoder</a> &amp;e, const T &amp;t)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9553ee4df1fcafa1ae9ba8e621988d45"></a><!-- doxytag: member="avro::decode" ref="a9553ee4df1fcafa1ae9ba8e621988d45" args="(Decoder &amp;d, T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>decode</b> (<a class="el" href="classavro_1_1Decoder.html">Decoder</a> &amp;d, T &amp;t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9442a5ff1db1b9c36cd9b9af5de8015a"></a><!-- doxytag: member="avro::memoryOutputStream" ref="a9442a5ff1db1b9c36cd9b9af5de8015a" args="(size_t chunkSize=4 *1024)" -->
std::auto_ptr&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9442a5ff1db1b9c36cd9b9af5de8015a">memoryOutputStream</a> (size_t chunkSize=4 *1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>, which grows in memory chunks of specified size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0bac09f5dbc2da060eb8cb557153a1f5">memoryInputStream</a> (const uint8_t *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a>, with the data from the given byte array.  <a href="#a0bac09f5dbc2da060eb8cb557153a1f5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aa81da018991dfbfdfb2275939415e083">memoryInputStream</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a> with the contents written into an outputstream.  <a href="#aa81da018991dfbfdfb2275939415e083"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a260c6d9544188b7525f846adaa288414">fileOutputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> whose contents would be stored in a file.  <a href="#a260c6d9544188b7525f846adaa288414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::auto_ptr&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aca2c00fca3f01077b5ddd9d9759d2d0a">fileInputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a> whose contents come from the given file.  <a href="#aca2c00fca3f01077b5ddd9d9759d2d0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeab3d9f5f2a4a4f96d3ffb8ba27e523"></a><!-- doxytag: member="avro::copy" ref="adeab3d9f5f2a4a4f96d3ffb8ba27e523" args="(InputStream &amp;in, OutputStream &amp;out)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#adeab3d9f5f2a4a4f96d3ffb8ba27e523">copy</a> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;in, <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;out)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A convenience function to copy all the contents of an input stream into an output stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83ca7f599d09b940bd236e77aa508381"></a><!-- doxytag: member="avro::isPrimitive" ref="a83ca7f599d09b940bd236e77aa508381" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isPrimitive</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a183aa500a8985117239abdc5922d8602"></a><!-- doxytag: member="avro::isCompound" ref="a183aa500a8985117239abdc5922d8602" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isCompound</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e596e801aaf532e26895ad9d7bfcdb1"></a><!-- doxytag: member="avro::isAvroType" ref="a5e596e801aaf532e26895ad9d7bfcdb1" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66c7c7a5f5cdbacf66009aa4a8079ef"></a><!-- doxytag: member="avro::isAvroTypeOrPseudoType" ref="ae66c7c7a5f5cdbacf66009aa4a8079ef" args="(Type t)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>isAvroTypeOrPseudoType</b> (Type t)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a14d670e49d712b11b37cc320e56225c4"></a><!-- doxytag: member="avro::toString" ref="a14d670e49d712b11b37cc320e56225c4" args="(Type type)" -->
const std::string &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>toString</b> (Type type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b087ab950b8385296b2800f47ba4a98"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4b087ab950b8385296b2800f47ba4a98" args="(std::ostream &amp;os, avro::Type type)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, avro::Type type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab8b3abddb0a14d47cbe76214488d7b"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4ab8b3abddb0a14d47cbe76214488d7b" args="(std::ostream &amp;os, const Null &amp;null)" -->
std::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6114e4d5179ae6ac739e71223a0714"></a><!-- doxytag: member="avro::encodeZigzag64" ref="afe6114e4d5179ae6ac739e71223a0714" args="(int64_t input)" -->
uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a834bf573771265b5f919982aa13a9252"></a><!-- doxytag: member="avro::decodeZigzag64" ref="a834bf573771265b5f919982aa13a9252" args="(uint64_t input)" -->
int64_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8987f354cd4d0611c0630d8ab1671fa"></a><!-- doxytag: member="avro::encodeZigzag32" ref="ad8987f354cd4d0611c0630d8ab1671fa" args="(int32_t input)" -->
uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ab741dd5f13c174cfbd5a328dc47ef9"></a><!-- doxytag: member="avro::decodeZigzag32" ref="a4ab741dd5f13c174cfbd5a328dc47ef9" args="(uint32_t input)" -->
int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabc335f3d911f17263b1b3b8181f0e25"></a><!-- doxytag: member="avro::encodeInt32" ref="aabc335f3d911f17263b1b3b8181f0e25" args="(int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6194251ac5f7be7616666cebb2f7d0"></a><!-- doxytag: member="avro::encodeInt64" ref="afc6194251ac5f7be7616666cebb2f7d0" args="(int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)" -->
size_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0136e9ae2b312d9f9642e491eceac67c">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain.  <a href="#a0136e9ae2b312d9f9642e491eceac67c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ae7792d346a1a142279b846cb9fe0092f"></a><!-- doxytag: member="avro::parse" ref="ae7792d346a1a142279b846cb9fe0092f" args="(Reader &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Reader &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1c8ebfc19da2ecad1fd2e5ae21fe450"></a><!-- doxytag: member="avro::translatingParse" ref="ad1c8ebfc19da2ecad1fd2e5ae21fe450" args="(ResolvingReader &amp;p, T &amp;val, const boost::true_type &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpd41d8cd98f00b204e9800998ecf8427e"></a> </p>
</div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3711f06e890ef4fd38031601143d4a75"></a><!-- doxytag: member="avro::serialize" ref="a3711f06e890ef4fd38031601143d4a75" args="(Writer &amp;s, T val, const boost::true_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a3711f06e890ef4fd38031601143d4a75">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, T val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a55afd164df3c36cb7c36323e5c2549ee"></a><!-- doxytag: member="avro::serialize" ref="a55afd164df3c36cb7c36323e5c2549ee" args="(Writer &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Writer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. </p>
<p>See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A bunch of templates and specializations for encoding and decoding specific types.</p>
<p>Primitive AVRO types BOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING and BYTES get decoded to and encoded from C++ types bool, int32_t, int64_t, float, double, std::string and std::vector&lt;uint8_t&gt; respectively. In addition, std::vector&lt;T&gt; for aribtrary type T gets encoded as an Avro array of T. Similarly, std::map&lt;std::string, T&gt; for arbitrary type T gets encoded as an Avro map with value type T.</p>
<p>Users can have their custom types encoded/decoded by specializing <a class="el" href="structavro_1_1codec__traits.html">avro::codec_traits</a> class for their types. </p>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad17da92a723dce9b89e7c845749615b3"></a><!-- doxytag: member="avro::SchemaResolution" ref="ad17da92a723dce9b89e7c845749615b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a><!-- doxytag: member="RESOLVE_NO_MATCH" ref="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175" args="" -->RESOLVE_NO_MATCH</em>&nbsp;</td><td>
<p>The schemas definitely do not match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a><!-- doxytag: member="RESOLVE_MATCH" ref="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d" args="" -->RESOLVE_MATCH</em>&nbsp;</td><td>
<p>The schemas match at a cursory level. </p>
<p>For records and enums, this means the name is the same, but it does not necessarily mean that every symbol or field is an exact match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a><!-- doxytag: member="RESOLVE_PROMOTABLE_TO_LONG" ref="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74" args="" -->RESOLVE_PROMOTABLE_TO_LONG</em>&nbsp;</td><td>
<p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac736c901800fa085e133118b238f6b46"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac736c901800fa085e133118b238f6b46" args="(std::istream &amp;is, ValidSchema &amp;schema)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a class="anchor" id="ac42e03a03cf7f4d975f8913f9e9188d7"></a><!-- doxytag: member="avro::compileJsonSchema" ref="ac42e03a03cf7f4d975f8913f9e9188d7" args="(std::istream &amp;is, ValidSchema &amp;schema, std::string &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool avro::compileJsonSchema </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&nbsp;</td>
          <td class="paramname"> <em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>error</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a class="anchor" id="aca2c00fca3f01077b5ddd9d9759d2d0a"></a><!-- doxytag: member="avro::fileInputStream" ref="aca2c00fca3f01077b5ddd9d9759d2d0a" args="(const char *filename, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::fileInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em> = <code>8&nbsp;*1024</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a> whose contents come from the given file. </p>
<p>Data is read in chunks of given buffer size. </p>

</div>
</div>
<a class="anchor" id="a260c6d9544188b7525f846adaa288414"></a><!-- doxytag: member="avro::fileOutputStream" ref="a260c6d9544188b7525f846adaa288414" args="(const char *filename, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>&gt; avro::fileOutputStream </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em> = <code>8&nbsp;*1024</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> whose contents would be stored in a file. </p>
<p>Data is written in chunks of given buffer size.</p>
<p>If there is a file with the given name, it is truncated and overwritten. If there is no file with the given name, it is created. </p>

</div>
</div>
<a class="anchor" id="a0bac09f5dbc2da060eb8cb557153a1f5"></a><!-- doxytag: member="avro::memoryInputStream" ref="a0bac09f5dbc2da060eb8cb557153a1f5" args="(const uint8_t *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a>, with the data from the given byte array. </p>
<p>It does not copy the data, the byte array should remain valid until the <a class="el" href="classavro_1_1InputStream.html">InputStream</a> is used. </p>

</div>
</div>
<a class="anchor" id="aa81da018991dfbfdfb2275939415e083"></a><!-- doxytag: member="avro::memoryInputStream" ref="aa81da018991dfbfdfb2275939415e083" args="(const OutputStream &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; avro::memoryInputStream </td>
          <td>(</td>
          <td class="paramtype">const OutputStream &amp;&nbsp;</td>
          <td class="paramname"> <em>source</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html">InputStream</a> with the contents written into an outputstream. </p>
<p>The output stream must have been returned by an earlier call to <a class="el" href="namespaceavro.html#a9442a5ff1db1b9c36cd9b9af5de8015a" title="Returns a new OutputStream, which grows in memory chunks of specified size.">memoryOutputStream()</a>. The contents for the new input stream are the snapshot of the outputstream. One can construct any number of memory input stream from a single memory output stream. </p>

</div>
</div>
<a class="anchor" id="a0136e9ae2b312d9f9642e491eceac67c"></a><!-- doxytag: member="avro::parse" ref="a0136e9ae2b312d9f9642e491eceac67c" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. </p>
<p>The remainder of the file includes default implementations for serializable types. </p>

</div>
</div>
<a class="anchor" id="a4b63a28bf43eaf3bab0cbe639ea1a5fe"></a><!-- doxytag: member="avro::parse" ref="a4b63a28bf43eaf3bab0cbe639ea1a5fe" args="(Reader &amp;p, T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::parse </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a class="anchor" id="a37a740598b3f23bd0f75b5d4f54bc71b"></a><!-- doxytag: member="avro::resolvingDecoder" ref="a37a740598b3f23bd0f75b5d4f54bc71b" args="(const ValidSchema &amp;writer, const ValidSchema &amp;reader, const DecoderPtr &amp;base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ResolvingDecoderPtr avro::resolvingDecoder </td>
          <td>(</td>
          <td class="paramtype">const ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValidSchema &amp;&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecoderPtr &amp;&nbsp;</td>
          <td class="paramname"> <em>base</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema. </p>
<p>The client uses the decoder as if the data were written using readerSchema. // FIXME: Handle out of order fields. </p>

</div>
</div>
<a class="anchor" id="af8f98882bd10d711f84ff8759aed4132"></a><!-- doxytag: member="avro::serialize" ref="af8f98882bd10d711f84ff8759aed4132" args="(Writer &amp;s, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void avro::serialize </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 29 2011 15:43:30 for Avro C++ by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
