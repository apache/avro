<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Avro C++: Main Page</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Avro C++ Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Introduction to Avro C++</h2>
<p>Avro is a data serialization system. See <a href="http://hadoop.apache.org/avro/docs/current/">http://avro.apache.org/docs/current/</a> for background information. </p>
<p>Avro C++ is a C++ library which implementats parts of the <a href="http://avro.apache.org/docs/current/spec.html">Avro Specification</a>. The library includes the following functionality: </p>
<ul>
<li>
Assembling schemas programmatically. </li>
<li>
A schema parser, which can parse Avro schema (written in JSON) into a Schema object. </li>
<li>
Encoders and decoders to encode data into Avro format and decode it back using primitive functions. There are multiple implementations of encoders and decoders. <ul>
<li>
A binary encoder, which encodes into binary Avro data. </li>
<li>
A JSON encoder, which encodes into JSON Avro data. </li>
<li>
A validating encoder, an encoder proxy, which validates the call sequence to the encoder before sending the calls to another encoder. </li>
<li>
A binary decoder, which decodes binay Avro data. </li>
<li>
A JSON decoder, which decodes JSON Avro data. </li>
<li>
A validating decoder, a decoder proxy, which validates the call sequence to the decoder before sending the calls to another decoder. </li>
<li>
A resolving decoder, which accepts calls for according to a reader's schema but decodes data corresponding to a different (writer's) schema doing schema resolution according to resolution rules in the Avro specification. </li>
</ul>
</li>
<li>
Streams for storing and reading data, which Encoders and Decoders use. </li>
<li>
Support for Avro DataFile. </li>
<li>
A code generator, which generates C++ classes fnd functions to encode and decode them. The code generator produces a C++ header file from a given schema file. </li>
</ul>
<p>Presently there is no support for the following specified in Avro specification. </p>
<ul>
<li>
Avro RPC </li>
</ul>
<p><b>Note:</b> Prior to Avro release 1.5, some of the functionality mentioned above was avilable through a somewhat different API and set tools. They are partially incompatible to the present ones. They continue to be available but will be deprecated and discontinued sometime in the future. The documentation on that API can be found at <a href="http://avro.apache.org/docs/1.4.0/api/cpp/html/index.html">http://avro.apache.org/docs/1.4.0/api/cpp/html/index.html</a></p>
<h2>Installing Avro C++</h2>
<h3>Supported platforms and pre-requisites</h3>
<p>One should be able to build Avro C++ on (1) any UNIX flavor including cygwin for Windows and (2) natively on Windows using Visual Studio. We have tested it on (1) Linux systems (Ubuntu and RHEL) and Cygwin and Visual Studio 2010 Express edition.</p>
<p>In order to build Avro C++, one needs the following: </p>
<ul>
<li>
A C++ compiler and runtime libraries. </li>
<li>
Boost library version 1.38 or later. Apart from the header-only libraries of Boost, Avro C++ requires filesystem, system and program_options libraries. Please see <a href="http://www.boost.org/">http://www.boost.org</a> or your platform's documentation for details on how to set up Boost for your platform. </li>
<li>
CMake build tool version 2.6 or later. Please see <a href="http://www.cmake.org">http://www.cmake.org</a> or your platform's documentation for details on how to set up CMake for your system. </li>
<li>
Python. If not already present, please consult your platform-specific documentation on how to install Python on your system. </li>
</ul>
<p>For Ubuntu Linux, for example, you can have these by doing <code>apt-get install</code> for the following packages:  </p>
<ul>
<li>cmake </li>
<li>g++ </li>
<li>libboost-dev </li>
<li>libboost-filesystem-dev </li>
<li>libboost-system-dev </li>
<li>libboost-program-options-dev</li>
</ul>
<p>For Windows native builds, you need to install the following:  </p>
<ul>
<li>cmake </li>
<li>boost distribution from Boost consulting </li>
<li>Visual studio</li>
</ul>
<h3>Installing Avro C++</h3>
<ol>
<li>
Download the latest Avro distribution. Avro distribution is a compressed tarball. Please see the main documentation if you want to build anything more than Avro C++. </li>
</ol>
<h4>On Unix systems and on Cygwin</h4>
<ol>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Type <code>./build.sh test</code>. This builds Avro C++ and runs tests on it. </li>
<li>
Type <code>./build.sh install</code>. This installs Avro C++ under /usr/local on your system. </li>
</ol>
<h4>On native Windows</h4>
<ol>
<li>
Ensure that Cmake's bin directory and Boost's lib directory are in the path. </li>
<li>
Expand the tarball into a directory. </li>
<li>
Change to <code>lang/c++</code> subdirectory. </li>
<li>
Create a subdirectory, say, build.win, and change to that directory. </li>
<li>
Type <code>cmake -G "Visual Studio 10"</code>. It creates, among other things, Avro-cpp.sln file. </li>
<li>
Open the solution file using Visual Studio and build the projects from within the Visual Studio. </li>
<li>
To run all unit tests, build the special project named "RUN_TESTS". </li>
<li>
<p class="startli">After building all the projects, you can also execute the unit tests from command line. <code>ctest -C release</code> or <code>ctest -C debug</code>.</p>
<p class="endli"></p>
</li>
</ol>
<h2>Getting started with Avro C++</h2>
<p>Although Avro does not require use of code generation, that is the easiest way to get started with the Avro C++ library. The code generator reads a schema, and generates a C++ header file that defines one or more C++ <code>struct</code>s to represent the data for the schema and functions to encode and decode those <code>struct</code>s. Even if you wish to write custom code to encode and decode your objects using the core functionality of Avro C++, the generated code can serve as an example of how to use the code functionality.</p>
<p>Let's walk through an example, using a simple schema. Use the schema that represents an complex number:</p>
<p><b>File: cpx.json</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 {
<a name="l00002"></a>00002     <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;record&quot;</span>, 
<a name="l00003"></a>00003     <span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;cpx&quot;</span>,
<a name="l00004"></a>00004     <span class="stringliteral">&quot;fields&quot;</span> : [
<a name="l00005"></a>00005         {<span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;re&quot;</span>, <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;double&quot;</span>},    
<a name="l00006"></a>00006         {<span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;im&quot;</span>, <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;double&quot;</span>}
<a name="l00007"></a>00007     ]
<a name="l00008"></a>00008 }
</pre></div> <p><b>Note:</b> All the example code given here can be found under <code>examples</code> directory of the distribution.</p>
<p>Assume this JSON representation of the schema is stored in a file called <code>cpx.json</code>. To generate the code issue the command:. </p>
<pre>
avrogencpp -i cpx.json -o cpx.hh -n c
</pre><p> The <code>-i</code> flag specifies the input schema file and <code>-o</code> flag specifies the output header file to generate. The generated C++ code will be in the namespace specifed with <code>-n</code> flag.</p>
<p>The generated file, among other things will have the following:</p>
<pre></pre><pre>...
namespace c {
...</pre><pre>struct cpx {
    double re;
    double im;
};</pre><pre>...</pre><pre>}</pre><pre></pre><p> <code>cpx</code> is a C++ representation of the Avro schema <code>cpx</code>.</p>
<p>Now let's see how we can use the code generated to encode data into avro and decode it back.</p>
<p><b>File: generated.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &quot;cpx.hh&quot;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="keywordtype">int</span>
<a name="l00025"></a>00025 main()
<a name="l00026"></a>00026 {
<a name="l00027"></a>00027     std::auto_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream</a>();
<a name="l00028"></a>00028     <a class="code" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073" title="Shared pointer to Encoder.">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder</a>();
<a name="l00029"></a>00029     e-&gt;init(*out);
<a name="l00030"></a>00030     c::cpx c1;
<a name="l00031"></a>00031     c1.re = 1.0;
<a name="l00032"></a>00032     c1.im = 2.13;
<a name="l00033"></a>00033     <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(*e, c1);
<a name="l00034"></a>00034 
<a name="l00035"></a>00035     std::auto_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream</a>(*out);
<a name="l00036"></a>00036     <a class="code" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7" title="Shared pointer to Decoder.">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder</a>();
<a name="l00037"></a>00037     d-&gt;init(*in);
<a name="l00038"></a>00038 
<a name="l00039"></a>00039     c::cpx c2;
<a name="l00040"></a>00040     <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(*d, c2);
<a name="l00041"></a>00041     std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;
<a name="l00042"></a>00042     <span class="keywordflow">return</span> 0;
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 
</pre></div><p>In line 9, we construct a memory output stream. By this we indicate that we want to send the encoded Avro data into memory. In line 10, we construct a binary encoder, whereby we mean the output should be encoded using the Avro binary standard. In line 11, we attach the output stream to the encoder. At any given time an incoder can write to only one output stream. </p>
<p>In line 14, we write the contents of c1 into the output stream using the encoder. Now the output stream contains the binary representation of the object. The rest of the code verifies that the data is indeed in the stream. </p>
<p>In line 17, we construct a memory input stream from the contents of the output stream. Thus the input stream has the binary representation of the object. In line 18 and 19, we construct a binary decoder and attach the input stream to it. Line 22 decodes the contents of the stream into another object c2. Now c1 and c2 should have identical contents, which one can readily verify from the output of the program, which should be:</p>
<pre>
(1, 2.13)
</pre><p>Now, if you want to encode the data using Avro JSON encoding, you should use <a class="el" href="namespaceavro.html#a0847ef62f42f6f0d0af28da9f7c7cf15" title="Returns an encoder that can encode Avro standard for JSON.">avro::jsonEncoder()</a> instead of <a class="el" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder()</a> in line 10 and <a class="el" href="namespaceavro.html#a7ac8a9c93b0621227de3dcca383e36ff" title="Returns an decoder that can decode Avro standard for JSON.">avro::jsonDecoder()</a> instead of <a class="el" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder()</a> in line 18. </p>
<p>On the other hand, if you want to write the contents to a file instead of memory, you should use <a class="el" href="namespaceavro.html#a49f045f7aa22d1b628aa0fec12f82332" title="Returns a new OutputStream whose contents would be stored in a file.">avro::fileOutputStream()</a> instead of <a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream()</a> in ine 9 and <a class="el" href="namespaceavro.html#ad65fd382f9f5f4b90b580861bf2f7f0c" title="Returns a new InputStream whose contents come from the given file.">avro::fileInputStream()</a> instead of <a class="el" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream()</a> in line 17. </p>
<h2>Reading a JSON schema</h2>
<p>The section above demonstrated pretty much all that's needed to know to get started reading and writing objects using the Avro C++ code generator. The following sections will cover some more information. </p>
<p>The library provides some utilities to read a schema that is stored in a JSON file:</p>
<p><b>File: schemaload.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="keywordtype">int</span>
<a name="l00026"></a>00026 main()
<a name="l00027"></a>00027 {
<a name="l00028"></a>00028     std::ifstream in(<span class="stringliteral">&quot;cpx.json&quot;</span>);
<a name="l00029"></a>00029 
<a name="l00030"></a>00030     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> cpxSchema;
<a name="l00031"></a>00031     <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31" title="Given a stream comtaining a JSON schema, compiles the schema to a ValidSchema object.">avro::compileJsonSchema</a>(in, cpxSchema);
<a name="l00032"></a>00032 }
</pre></div><p>This reads the file, and parses the JSON schema into an in-meory schema object of type <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a>. If, for some reason, the schema is not valid, the <code>cpxSchema</code> object will not be set, and an exception will be thrown.  If you always use code Avro generator you don't really need the in-memory schema objects. But if you use custom objects and routines to encode or decode avro data, you will need the schema objects. Other uses of schema objects are generic data objects and schema resolution described in the following sections.</p>
<h2>Custom encoding and decoding</h2>
<p>Suppose you want to encode objects of type std::complex&lt;double&gt; from C++ standard library using the schema defined in cpx.json. Since std::complex&lt;double&gt; was not generated by Avro, it does't know how to encode or decode objects of that type. You have to tell Avro how to do that.</p>
<p>The recommended way to tell Avro how to encode or decode is to specialize Avro's codec_traits template. For std::complex&lt;double&gt;, here is what you'd do:</p>
<p><b>File: custom.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span>
<a name="l00024"></a>00024 
<a name="l00025"></a>00025 <span class="keyword">namespace </span>avro {
<a name="l00026"></a>00026 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00027"></a>00027 <span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt; &gt; {
<a name="l00028"></a>00028     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">encode</a>(Encoder&amp; e, <span class="keyword">const</span> std::complex&lt;T&gt;&amp; c) {
<a name="l00029"></a>00029         <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(e, std::real(c));
<a name="l00030"></a>00030         <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(e, std::imag(c));
<a name="l00031"></a>00031     }
<a name="l00032"></a>00032 
<a name="l00033"></a>00033     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">decode</a>(Decoder&amp; d, std::complex&lt;T&gt;&amp; c) {
<a name="l00034"></a>00034         T re, im;
<a name="l00035"></a>00035         <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(d, re);
<a name="l00036"></a>00036         <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(d, im);
<a name="l00037"></a>00037         c = std::complex&lt;T&gt;(re, im);
<a name="l00038"></a>00038     }
<a name="l00039"></a>00039 };
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 }
<a name="l00042"></a>00042 <span class="keywordtype">int</span>
<a name="l00043"></a>00043 main()
<a name="l00044"></a>00044 {
<a name="l00045"></a>00045     std::auto_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream</a>();
<a name="l00046"></a>00046     <a class="code" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073" title="Shared pointer to Encoder.">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder</a>();
<a name="l00047"></a>00047     e-&gt;init(*out);
<a name="l00048"></a>00048     std::complex&lt;double&gt; c1(1.0, 2.0);
<a name="l00049"></a>00049     <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(*e, c1);
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     std::auto_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream</a>(*out);
<a name="l00052"></a>00052     <a class="code" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7" title="Shared pointer to Decoder.">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder</a>();
<a name="l00053"></a>00053     d-&gt;init(*in);
<a name="l00054"></a>00054 
<a name="l00055"></a>00055     std::complex&lt;double&gt; c2;
<a name="l00056"></a>00056     <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(*d, c2);
<a name="l00057"></a>00057     std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;
<a name="l00058"></a>00058     <span class="keywordflow">return</span> 0;
<a name="l00059"></a>00059 }
</pre></div><p>Please notice that the main function is pretty much similar to that we used for the generated class. Once <code>codec_traits</code> for a specific type is supplied, you do not really need to do anything special for your custom types.</p>
<p>But wait, how does Avro know that complex&lt;double&gt; represents the data for the schema in <code>cpx.json</code>? It doesn't. In fact, if you have used <code>std::complex&lt;float&gt;</code> instead of <code>std::complex&lt;double&gt;</code> program would have worked. But the data in the memory would not have been corresponding to the schema in <code>cpx.json</code>.</p>
<p>In order to ensure that you indeed use the correct type, you can use the validating encoders and decoder. Here is how:</p>
<p><b>File: validating.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="keyword">namespace </span>avro {
<a name="l00028"></a>00028 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00029"></a>00029 <span class="keyword">struct </span>codec_traits&lt;std::complex&lt;T&gt; &gt; {
<a name="l00030"></a>00030     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">encode</a>(Encoder&amp; e, <span class="keyword">const</span> std::complex&lt;T&gt;&amp; c) {
<a name="l00031"></a>00031         <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(e, std::real(c));
<a name="l00032"></a>00032         <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(e, std::imag(c));
<a name="l00033"></a>00033     }
<a name="l00034"></a>00034 
<a name="l00035"></a>00035     <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">decode</a>(Decoder&amp; d, std::complex&lt;T&gt;&amp; c) {
<a name="l00036"></a>00036         T re, im;
<a name="l00037"></a>00037         <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(d, re);
<a name="l00038"></a>00038         <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(d, im);
<a name="l00039"></a>00039         c = std::complex&lt;T&gt;(re, im);
<a name="l00040"></a>00040     }
<a name="l00041"></a>00041 };
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 }
<a name="l00044"></a>00044 <span class="keywordtype">int</span>
<a name="l00045"></a>00045 main()
<a name="l00046"></a>00046 {
<a name="l00047"></a>00047     std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);
<a name="l00048"></a>00048 
<a name="l00049"></a>00049     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> cpxSchema;
<a name="l00050"></a>00050     <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31" title="Given a stream comtaining a JSON schema, compiles the schema to a ValidSchema object.">avro::compileJsonSchema</a>(ifs, cpxSchema);
<a name="l00051"></a>00051 
<a name="l00052"></a>00052     std::auto_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream</a>();
<a name="l00053"></a>00053     <a class="code" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073" title="Shared pointer to Encoder.">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e" title="Returns an encoder that validates sequence of calls to an underlying Encoder against the given schema...">avro::validatingEncoder</a>(cpxSchema,
<a name="l00054"></a>00054         <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder</a>());
<a name="l00055"></a>00055     e-&gt;init(*out);
<a name="l00056"></a>00056     std::complex&lt;double&gt; c1(1.0, 2.0);
<a name="l00057"></a>00057     <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(*e, c1);
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     std::auto_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream</a>(*out);
<a name="l00060"></a>00060     <a class="code" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7" title="Shared pointer to Decoder.">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae" title="Returns an decoder that validates sequence of calls to an underlying Decoder against the given schema...">avro::validatingDecoder</a>(cpxSchema,
<a name="l00061"></a>00061         <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder</a>());
<a name="l00062"></a>00062     d-&gt;init(*in);
<a name="l00063"></a>00063 
<a name="l00064"></a>00064     std::complex&lt;double&gt; c2;
<a name="l00065"></a>00065     <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(*d, c2);
<a name="l00066"></a>00066     std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; std::real(c2) &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; std::imag(c2) &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;
<a name="l00067"></a>00067     <span class="keywordflow">return</span> 0;
<a name="l00068"></a>00068 }
</pre></div><p>Here, instead of using the plain binary encoder, you use a validating encoder backed by a binary encoder. Similarly, instead of using the plain binary decoder, you use a validating decoder backed by a binary decoder. Now, if you use <code>std::complex&lt;float&gt;</code> intead of <code>std::complex&lt;double&gt;</code> the validating encoder and decoder will throw exception stating that you are trying to encode or decode <code>float</code> instead of <code>double</code>. </p>
<p>You can use any encoder behind the validating encoder and any decoder behind the validating decoder. But in practice, only the binary encoder and the binary decoder have no knowledge of the underlying schema. All other encoders (JSON encoder) and decoders (JSON decoder, resolving decoder) do know about the schema and they validate internally. So, fronting them with a validating encoder or validating decoder is wasteful.</p>
<h2>Generic data objects</h2>
<p>A third way to encode and decode data is to use Avro's generic datum. Avro's generic datum allows you to read any arbitray data corresponding to an arbitrary schema into a generic object. One need not know anything about the schema or data at complie time.</p>
<p>Here is an example how one can use the generic datum.</p>
<p><b>File: generic.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;cpx.hh&quot;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 <span class="keywordtype">int</span>
<a name="l00031"></a>00031 main()
<a name="l00032"></a>00032 {
<a name="l00033"></a>00033     std::ifstream ifs(<span class="stringliteral">&quot;cpx.json&quot;</span>);
<a name="l00034"></a>00034 
<a name="l00035"></a>00035     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> cpxSchema;
<a name="l00036"></a>00036     <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31" title="Given a stream comtaining a JSON schema, compiles the schema to a ValidSchema object.">avro::compileJsonSchema</a>(ifs, cpxSchema);
<a name="l00037"></a>00037 
<a name="l00038"></a>00038     std::auto_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream</a>();
<a name="l00039"></a>00039     <a class="code" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073" title="Shared pointer to Encoder.">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder</a>();
<a name="l00040"></a>00040     e-&gt;init(*out);
<a name="l00041"></a>00041     c::cpx c1;
<a name="l00042"></a>00042     c1.re = 100.23;
<a name="l00043"></a>00043     c1.im = 105.77;
<a name="l00044"></a>00044     <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(*e, c1);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     std::auto_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream</a>(*out);
<a name="l00047"></a>00047     <a class="code" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7" title="Shared pointer to Decoder.">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder</a>();
<a name="l00048"></a>00048     d-&gt;init(*in);
<a name="l00049"></a>00049 
<a name="l00050"></a>00050     <a class="code" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type.">avro::GenericDatum</a> datum(cpxSchema);
<a name="l00051"></a>00051     <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(*d, datum);
<a name="l00052"></a>00052     std::cout &lt;&lt; <span class="stringliteral">&quot;Type: &quot;</span> &lt;&lt; datum.type() &lt;&lt; std::endl;
<a name="l00053"></a>00053     <span class="keywordflow">if</span> (datum.type() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">avro::AVRO_RECORD</a>) {
<a name="l00054"></a>00054         <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericRecord.html" title="The generic container for Avro records.">avro::GenericRecord</a>&amp; r = datum.value&lt;<a class="code" href="classavro_1_1GenericRecord.html" title="The generic container for Avro records.">avro::GenericRecord</a>&gt;();
<a name="l00055"></a>00055         std::cout &lt;&lt; <span class="stringliteral">&quot;Field-count: &quot;</span> &lt;&lt; r.<a class="code" href="classavro_1_1GenericRecord.html#a46b8694d70bfb56c9819c22d7e103515" title="Returns the number of fields in the current record.">fieldCount</a>() &lt;&lt; std::endl;
<a name="l00056"></a>00056         <span class="keywordflow">if</span> (r.<a class="code" href="classavro_1_1GenericRecord.html#a46b8694d70bfb56c9819c22d7e103515" title="Returns the number of fields in the current record.">fieldCount</a>() == 2) {
<a name="l00057"></a>00057             <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type.">avro::GenericDatum</a>&amp; f0 = r.<a class="code" href="classavro_1_1GenericRecord.html#a638d1d70375086c034b8b22e110cf234" title="Returns the field at the given position pos.">fieldAt</a>(0);
<a name="l00058"></a>00058             <span class="keywordflow">if</span> (f0.<a class="code" href="classavro_1_1GenericDatum.html#a75ffbe2191c0c94a739a6b3530916fad" title="The avro data type this datum holds.">type</a>() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">avro::AVRO_DOUBLE</a>) {
<a name="l00059"></a>00059                 std::cout &lt;&lt; <span class="stringliteral">&quot;Real: &quot;</span> &lt;&lt; f0.<a class="code" href="classavro_1_1GenericDatum.html#a9e3892b91bc891188f963ee2695122a8" title="Returns the value held by this datum.">value</a>&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;
<a name="l00060"></a>00060             }
<a name="l00061"></a>00061             <span class="keyword">const</span> <a class="code" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type.">avro::GenericDatum</a>&amp; f1 = r.<a class="code" href="classavro_1_1GenericRecord.html#a638d1d70375086c034b8b22e110cf234" title="Returns the field at the given position pos.">fieldAt</a>(1);
<a name="l00062"></a>00062             <span class="keywordflow">if</span> (f1.<a class="code" href="classavro_1_1GenericDatum.html#a75ffbe2191c0c94a739a6b3530916fad" title="The avro data type this datum holds.">type</a>() == <a class="code" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">avro::AVRO_DOUBLE</a>) {
<a name="l00063"></a>00063                 std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; f1.<a class="code" href="classavro_1_1GenericDatum.html#a9e3892b91bc891188f963ee2695122a8" title="Returns the value held by this datum.">value</a>&lt;<span class="keywordtype">double</span>&gt;() &lt;&lt; std::endl;
<a name="l00064"></a>00064             }
<a name="l00065"></a>00065         }
<a name="l00066"></a>00066     }
<a name="l00067"></a>00067     <span class="keywordflow">return</span> 0;
<a name="l00068"></a>00068 }
</pre></div><p>In this example, we encode the data using generated code and decode it with generic datum. Then we examine the contents of the generic datum and extract them. Please see <a class="el" href="classavro_1_1GenericDatum.html">avro::GenericDatum</a> for more details on how to use it.</p>
<h2>Reading data with a schema different from that of the writer</h2>
<p>It is possible to read the data written according to one schema using a different schema, provided the reader's schema and the writer's schema are compatible according to the Avro's Schema resolution rules. </p>
<p>For example, you have a reader which is interested only in the imaginary part of a complex number while the writer writes both the real and imaginary parts. It is possible to do automatic schema resolution between the writer's schema and schema as shown below.</p>
<p><b>File: imaginary.json</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 {
<a name="l00002"></a>00002     <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;record&quot;</span>, 
<a name="l00003"></a>00003     <span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;cpx&quot;</span>,
<a name="l00004"></a>00004     <span class="stringliteral">&quot;fields&quot;</span> : [
<a name="l00005"></a>00005         {<span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;im&quot;</span>, <span class="stringliteral">&quot;type&quot;</span> : <span class="stringliteral">&quot;double&quot;</span>}
<a name="l00006"></a>00006     ]
<a name="l00007"></a>00007 }
</pre></div><pre>
avrogencpp -i imaginary.json -o imaginary.hh -n i
</pre><p><b>File: resolving.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;cpx.hh&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;imaginary.hh&quot;</span>
<a name="l00023"></a>00023 
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &quot;avro/Specific.hh&quot;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &quot;avro/Generic.hh&quot;</span>
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> load(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)
<a name="l00033"></a>00033 {
<a name="l00034"></a>00034     std::ifstream ifs(filename);
<a name="l00035"></a>00035     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> result;
<a name="l00036"></a>00036     <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31" title="Given a stream comtaining a JSON schema, compiles the schema to a ValidSchema object.">avro::compileJsonSchema</a>(ifs, result);
<a name="l00037"></a>00037     <span class="keywordflow">return</span> result;
<a name="l00038"></a>00038 }
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keywordtype">int</span>
<a name="l00041"></a>00041 main()
<a name="l00042"></a>00042 {
<a name="l00043"></a>00043     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> cpxSchema = load(<span class="stringliteral">&quot;cpx.json&quot;</span>);
<a name="l00044"></a>00044     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> imaginarySchema = load(<span class="stringliteral">&quot;imaginary.json&quot;</span>);
<a name="l00045"></a>00045 
<a name="l00046"></a>00046     std::auto_ptr&lt;avro::OutputStream&gt; out = <a class="code" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">avro::memoryOutputStream</a>();
<a name="l00047"></a>00047     <a class="code" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073" title="Shared pointer to Encoder.">avro::EncoderPtr</a> e = <a class="code" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6" title="Returns an encoder that can encode binary Avro standard.">avro::binaryEncoder</a>();
<a name="l00048"></a>00048     e-&gt;init(*out);
<a name="l00049"></a>00049     c::cpx c1;
<a name="l00050"></a>00050     c1.re = 100.23;
<a name="l00051"></a>00051     c1.im = 105.77;
<a name="l00052"></a>00052     <a class="code" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f" title="Generic encoder function that makes use of the codec_traits.">avro::encode</a>(*e, c1);
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     std::auto_ptr&lt;avro::InputStream&gt; in = <a class="code" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6" title="Returns a new InputStream, with the data from the given byte array.">avro::memoryInputStream</a>(*out);
<a name="l00055"></a>00055     <a class="code" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7" title="Shared pointer to Decoder.">avro::DecoderPtr</a> d = <a class="code" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96" title="Returns a decoder that decodes avro data from base written according to writerSchema and resolves aga...">avro::resolvingDecoder</a>(cpxSchema, imaginarySchema,
<a name="l00056"></a>00056         <a class="code" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148" title="Returns an decoder that can decode binary Avro standard.">avro::binaryDecoder</a>());
<a name="l00057"></a>00057     d-&gt;init(*in);
<a name="l00058"></a>00058 
<a name="l00059"></a>00059     i::cpx c2;
<a name="l00060"></a>00060     <a class="code" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d" title="Generic decoder function that makes use of the codec_traits.">avro::decode</a>(*d, c2);
<a name="l00061"></a>00061     std::cout &lt;&lt; <span class="stringliteral">&quot;Imaginary: &quot;</span> &lt;&lt; c2.im &lt;&lt; std::endl;
<a name="l00062"></a>00062 
<a name="l00063"></a>00063 }
</pre></div><p>In this example, writer and reader deal with different schemas, both are recornd with the same name cpx. The writer schema has two fields and the reader's has just one. We generated code for writer's schema in a namespace <code>c</code> and the reader's in <code>i</code>.</p>
<p>Please notice how the reading part of the example at line 42 reads as if the stream contains the data corresponding to its schema. The schema resolution is automatically done by the resolving decoder.</p>
<p>In this example, we have used a simple (somewhat artificial) projection (where the set of fields in the reader's schema is a subset of set of fields in the writer's). But more complex resolutions are allowed by Avro specification.</p>
<h2>Using Avro data files</h2>
<p>Avro specification specifies a format for data files. Avro C++ implements the sepcification. The code below demonstrates how one can use the Avro data file to store and retrieve a collection of objects corresponding to a given schema.</p>
<p><b>File: datafile.cc</b></p>
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;fstream&gt;</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="preprocessor">#include &quot;cpx.hh&quot;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &quot;avro/Encoder.hh&quot;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &quot;avro/Decoder.hh&quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;avro/ValidSchema.hh&quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;avro/Compiler.hh&quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &quot;avro/DataFile.hh&quot;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> loadSchema(<span class="keyword">const</span> <span class="keywordtype">char</span>* filename)
<a name="l00030"></a>00030 {
<a name="l00031"></a>00031     std::ifstream ifs(filename);
<a name="l00032"></a>00032     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> result;
<a name="l00033"></a>00033     <a class="code" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31" title="Given a stream comtaining a JSON schema, compiles the schema to a ValidSchema object.">avro::compileJsonSchema</a>(ifs, result);
<a name="l00034"></a>00034     <span class="keywordflow">return</span> result;
<a name="l00035"></a>00035 }
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="keywordtype">int</span>
<a name="l00038"></a>00038 main()
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040     <a class="code" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">avro::ValidSchema</a> cpxSchema = loadSchema(<span class="stringliteral">&quot;cpx.json&quot;</span>);
<a name="l00041"></a>00041 
<a name="l00042"></a>00042     {
<a name="l00043"></a>00043         <a class="code" href="classavro_1_1DataFileWriter.html" title="An Avro datafile that can store objects of type T.">avro::DataFileWriter&lt;c::cpx&gt;</a> dfw(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);
<a name="l00044"></a>00044         c::cpx c1;
<a name="l00045"></a>00045         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; i++) {
<a name="l00046"></a>00046             c1.re = i * 100;
<a name="l00047"></a>00047             c1.im = i + 100;
<a name="l00048"></a>00048             dfw.write(c1);
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050         dfw.close();
<a name="l00051"></a>00051     }
<a name="l00052"></a>00052 
<a name="l00053"></a>00053     {
<a name="l00054"></a>00054         <a class="code" href="classavro_1_1DataFileReader.html" title="Reads the contents of data file one after another.">avro::DataFileReader&lt;c::cpx&gt;</a> dfr(<span class="stringliteral">&quot;test.bin&quot;</span>, cpxSchema);
<a name="l00055"></a>00055         c::cpx c2;
<a name="l00056"></a>00056         <span class="keywordflow">while</span> (dfr.read(c2)) {
<a name="l00057"></a>00057             std::cout &lt;&lt; <span class="charliteral">&#39;(&#39;</span> &lt;&lt; c2.re &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; c2.im &lt;&lt; <span class="charliteral">&#39;)&#39;</span> &lt;&lt; std::endl;
<a name="l00058"></a>00058         }
<a name="l00059"></a>00059     }
<a name="l00060"></a>00060     <span class="keywordflow">return</span> 0;
<a name="l00061"></a>00061 }
<a name="l00062"></a>00062 
</pre></div><p>Please see <a class="el" href="DataFile_8hh_source.html">DataFile.hh</a> for more details. </p>
</div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 21 2013 13:40:26 for Avro C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
