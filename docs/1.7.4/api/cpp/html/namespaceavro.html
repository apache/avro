<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Avro C++: avro Namespace Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Avro C++
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">avro Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A bunch of templates and specializations for encoding and decoding specific types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro_1_1concepts.html">concepts</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>The concept classes are used to simplify <a class="el" href="classavro_1_1NodeImpl.html" title="Implementation details for Node.">NodeImpl</a>. </p>
<br/></td></tr>
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__serializable.html">is_serializable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1is__promotable.html">is_promotable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1type__to__avro.html">type_to_avro</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriterBase.html">DataFileWriterBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-independent portion of <a class="el" href="classavro_1_1DataFileWriter.html" title="An Avro datafile that can store objects of type T.">DataFileWriter</a>.  <a href="classavro_1_1DataFileWriterBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileWriter.html">DataFileWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An Avro datafile that can store objects of type T.  <a href="classavro_1_1DataFileWriter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReaderBase.html">DataFileReaderBase</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The type independent portion of rader.  <a href="classavro_1_1DataFileReaderBase.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DataFileReader.html">DataFileReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of data file one after another.  <a href="classavro_1_1DataFileReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Decoder.html">Decoder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> is an interface implemented by every decoder capable of decoding Avro data.  <a href="classavro_1_1Decoder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a> is derived from <a class="el" href="classavro_1_1Decoder.html">Decoder</a>, with an additional function to obtain the field ordering of fiedls within a record.  <a href="classavro_1_1ResolvingDecoder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Encoder.html">Encoder</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base class for all Avro encoders.  <a href="classavro_1_1Encoder.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Exception.html">Exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for std::runtime_error that provides convenience constructor for boost::format objects.  <a href="classavro_1_1Exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericDatum.html">GenericDatum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic datum which can hold any Avro type.  <a href="classavro_1_1GenericDatum.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericContainer.html">GenericContainer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for all generic type for containers.  <a href="classavro_1_1GenericContainer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericUnion.html">GenericUnion</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for unions.  <a href="classavro_1_1GenericUnion.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericRecord.html">GenericRecord</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro records.  <a href="classavro_1_1GenericRecord.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericArray.html">GenericArray</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro arrays.  <a href="classavro_1_1GenericArray.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericMap.html">GenericMap</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic container for Avro maps.  <a href="classavro_1_1GenericMap.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericEnum.html">GenericEnum</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro enum.  <a href="classavro_1_1GenericEnum.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericFixed.html">GenericFixed</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic container for Avro fixed.  <a href="classavro_1_1GenericFixed.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericReader.html">GenericReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to read generic datum from decoders.  <a href="classavro_1_1GenericReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1GenericWriter.html">GenericWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to write generic datum to encoders.  <a href="classavro_1_1GenericWriter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html">codec_traits&lt; std::pair&lt; ValidSchema, GenericDatum &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Generic datum along with its schema.  <a href="structavro_1_1codec__traits_3_01std_1_1pair_3_01ValidSchema_00_01GenericDatum_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html">codec_traits&lt; GenericDatum &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for <a class="el" href="classavro_1_1GenericDatum.html" title="Generic datum which can hold any Avro type.">GenericDatum</a>.  <a href="structavro_1_1codec__traits_3_01GenericDatum_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Layout.html">Layout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1PrimitiveLayout.html">PrimitiveLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1CompoundLayout.html">CompoundLayout</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Name.html">Name</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Node.html">Node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a> is the building block for parse trees.  <a href="classavro_1_1Node.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation details for <a class="el" href="classavro_1_1Node.html" title="Node is the building block for parse trees.">Node</a>.  <a href="classavro_1_1NodeImpl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodePrimitive.html">NodePrimitive</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeSymbolic.html">NodeSymbolic</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeRecord.html">NodeRecord</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeEnum.html">NodeEnum</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeArray.html">NodeArray</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeMap.html">NodeMap</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeUnion.html">NodeUnion</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NodeFixed.html">NodeFixed</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Parser.html">Parser</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a reader or ValidatingReade with an interface that uses explicit get* names instead of getValue.  <a href="classavro_1_1Parser.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses from an avro encoding to the requested type.  <a href="classavro_1_1ReaderImpl.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Resolver.html">Resolver</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolverSchema.html">ResolverSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Schema.html">Schema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The root <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> object is a base class. Nobody constructs this class directly.  <a href="classavro_1_1Schema.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullSchema.html">NullSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BoolSchema.html">BoolSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1IntSchema.html">IntSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1LongSchema.html">LongSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FloatSchema.html">FloatSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1DoubleSchema.html">DoubleSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1StringSchema.html">StringSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1BytesSchema.html">BytesSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1RecordSchema.html">RecordSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1EnumSchema.html">EnumSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ArraySchema.html">ArraySchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1MapSchema.html">MapSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1UnionSchema.html">UnionSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1FixedSchema.html">FixedSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1SymbolicSchema.html">SymbolicSchema</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Serializer.html">Serializer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that wraps a Writer or ValidatingWriter with an interface that uses explicit write* names instead of writeValue.  <a href="classavro_1_1Serializer.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits.html">codec_traits</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Codec_traits tells avro how to encode and decode an object of given type.  <a href="structavro_1_1codec__traits.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01bool_01_4.html">codec_traits&lt; bool &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro boolean.  <a href="structavro_1_1codec__traits_3_01bool_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int32__t_01_4.html">codec_traits&lt; int32_t &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro int.  <a href="structavro_1_1codec__traits_3_01int32__t_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01int64__t_01_4.html">codec_traits&lt; int64_t &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro long.  <a href="structavro_1_1codec__traits_3_01int64__t_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01float_01_4.html">codec_traits&lt; float &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro float.  <a href="structavro_1_1codec__traits_3_01float_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01double_01_4.html">codec_traits&lt; double &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro double.  <a href="structavro_1_1codec__traits_3_01double_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html">codec_traits&lt; std::string &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro string.  <a href="structavro_1_1codec__traits_3_01std_1_1string_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html">codec_traits&lt; std::vector&lt; uint8_t &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro bytes.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01uint8__t_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01boost_1_1array_3_01uint8__t_00_01N_01_4_01_4.html">codec_traits&lt; boost::array&lt; uint8_t, N &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro fixed.  <a href="structavro_1_1codec__traits_3_01boost_1_1array_3_01uint8__t_00_01N_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html">codec_traits&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro arrays.  <a href="structavro_1_1codec__traits_3_01std_1_1vector_3_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html">codec_traits&lt; std::map&lt; std::string, T &gt; &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a> for Avro maps.  <a href="structavro_1_1codec__traits_3_01std_1_1map_3_01std_1_1string_00_01T_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1InputStream.html">InputStream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy input stream.  <a href="classavro_1_1InputStream.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1OutputStream.html">OutputStream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-copy output stream.  <a href="classavro_1_1OutputStream.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamReader.html">StreamReader</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience class for reading from an <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>.  <a href="structavro_1_1StreamReader.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1StreamWriter.html">StreamWriter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convinience class to write data into an <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>.  <a href="structavro_1_1StreamWriter.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structavro_1_1Null.html">Null</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">define a type to identify <a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions">Null</a> in template functions  <a href="structavro_1_1Null.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1NullValidator.html">NullValidator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1Validator.html">Validator</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used by both the ValidatingSerializer and ValidationParser objects.  <a href="classavro_1_1Validator.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> is basically a non-mutable <a class="el" href="classavro_1_1Schema.html" title="The root Schema object is a base class. Nobody constructs this class directly.">Schema</a> that has passed some minumum of sanity checks.  <a href="classavro_1_1ValidSchema.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for writing avro data to a stream.  <a href="classavro_1_1WriterImpl.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee87abbccf24444198442e0ae2a9b01b"></a><!-- doxytag: member="avro::DataFileSync" ref="aee87abbccf24444198442e0ae2a9b01b" args="" -->
typedef boost::array&lt; uint8_t, 16 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aee87abbccf24444198442e0ae2a9b01b">DataFileSync</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The sync value. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a409dd1e501d982d3828c65ddf69b68b7"></a><!-- doxytag: member="avro::DecoderPtr" ref="a409dd1e501d982d3828c65ddf69b68b7" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Decoder.html">Decoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac16ed8c1d8bb7c68f40d2cd753a0a1b7"></a><!-- doxytag: member="avro::ResolvingDecoderPtr" ref="ac16ed8c1d8bb7c68f40d2cd753a0a1b7" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1ResolvingDecoder.html">ResolvingDecoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1ResolvingDecoder.html" title="ResolvingDecoder is derived from Decoder, with an additional function to obtain the field ordering of...">ResolvingDecoder</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a74279cf96c71ffd8f18d005c32ab8073"></a><!-- doxytag: member="avro::EncoderPtr" ref="a74279cf96c71ffd8f18d005c32ab8073" args="" -->
typedef boost::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Encoder.html">Encoder</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders.">Encoder</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a53c572cb71b20e20e429257209a42f91"></a><!-- doxytag: member="avro::NodePtr" ref="a53c572cb71b20e20e429257209a42f91" args="" -->
typedef boost::shared_ptr&lt; <a class="el" href="classavro_1_1Node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodePtr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8add0ad4d31ac7bd6baf95a10ea75254"></a><!-- doxytag: member="avro::NoName" ref="a8add0ad4d31ac7bd6baf95a10ea75254" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a610df85391dab7ced3d430c5cb3e8fee"></a><!-- doxytag: member="avro::HasName" ref="a610df85391dab7ced3d430c5cb3e8fee" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1Name.html">Name</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HasName</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85148fbeb2b2e17c9ad5bc357f16aff"></a><!-- doxytag: member="avro::NoLeaves" ref="ac85148fbeb2b2e17c9ad5bc357f16aff" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a71cf21198637dd41d9099615f32854c7"></a><!-- doxytag: member="avro::SingleLeaf" ref="a71cf21198637dd41d9099615f32854c7" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>SingleLeaf</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afd609b669d85b5209ccbc21cd8ef8945"></a><!-- doxytag: member="avro::MultiLeaves" ref="afd609b669d85b5209ccbc21cd8ef8945" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; NodePtr &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MultiLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b6da0159d149557988b1a7e40773d9b"></a><!-- doxytag: member="avro::NoLeafNames" ref="a5b6da0159d149557988b1a7e40773d9b" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoLeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa436fd2c922cd09d74494180f669e034"></a><!-- doxytag: member="avro::LeafNames" ref="aa436fd2c922cd09d74494180f669e034" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">concepts::MultiAttribute</a><br class="typebreak"/>
&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>LeafNames</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aecfce3e38687f7603287dd60dc271252"></a><!-- doxytag: member="avro::NoSize" ref="aecfce3e38687f7603287dd60dc271252" args="" -->
typedef <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">concepts::NoAttribute</a><br class="typebreak"/>
&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a46fa86efe35f9ecda21bb1849da70f05"></a><!-- doxytag: member="avro::HasSize" ref="a46fa86efe35f9ecda21bb1849da70f05" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">concepts::SingleAttribute</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>HasSize</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea022243932db4fd5cf9d387644bb6ce"></a><!-- doxytag: member="avro::NodeImplPrimitive" ref="aea022243932db4fd5cf9d387644bb6ce" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplPrimitive</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0020a7a6d3590c6e20305780e1f8105"></a><!-- doxytag: member="avro::NodeImplSymbolic" ref="ae0020a7a6d3590c6e20305780e1f8105" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplSymbolic</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a095db2b00faf42c54eff9ddca916f664"></a><!-- doxytag: member="avro::NodeImplRecord" ref="a095db2b00faf42c54eff9ddca916f664" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplRecord</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94c214009072cd60af44ebc912d3c72b"></a><!-- doxytag: member="avro::NodeImplEnum" ref="a94c214009072cd60af44ebc912d3c72b" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">LeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplEnum</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa04c70cd3863feee6699197aab1dac75"></a><!-- doxytag: member="avro::NodeImplArray" ref="aa04c70cd3863feee6699197aab1dac75" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">SingleLeaf</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplArray</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88f276e8d8fd426534c06c8b351780e7"></a><!-- doxytag: member="avro::NodeImplMap" ref="a88f276e8d8fd426534c06c8b351780e7" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplMap</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c4e7bbdf8250ea8481e5e6222e57918"></a><!-- doxytag: member="avro::NodeImplUnion" ref="a1c4e7bbdf8250ea8481e5e6222e57918" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1MultiAttribute.html">MultiLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplUnion</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7c3e3db25d7e71e41742bb70eaea2db"></a><!-- doxytag: member="avro::NodeImplFixed" ref="ad7c3e3db25d7e71e41742bb70eaea2db" args="" -->
typedef <a class="el" href="classavro_1_1NodeImpl.html">NodeImpl</a>&lt; <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasName</a>, <br class="typebreak"/>
<a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeaves</a>, <a class="el" href="structavro_1_1concepts_1_1NoAttribute.html">NoLeafNames</a>, <a class="el" href="structavro_1_1concepts_1_1SingleAttribute.html">HasSize</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NodeImplFixed</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace6d357bce9a8329f8b4f52bb5b7e366"></a><!-- doxytag: member="avro::Reader" ref="ace6d357bce9a8329f8b4f52bb5b7e366" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Reader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae20de889520d0e7006b1c83aad1fc929"></a><!-- doxytag: member="avro::ValidatingReader" ref="ae20de889520d0e7006b1c83aad1fc929" args="" -->
typedef <a class="el" href="classavro_1_1ReaderImpl.html">ReaderImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingReader</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50a5fe95b057b10bdad444b383bf556b"></a><!-- doxytag: member="avro::Writer" ref="a50a5fe95b057b10bdad444b383bf556b" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1NullValidator.html">NullValidator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Writer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a86c844697fdbee2981c59c5c32acd054"></a><!-- doxytag: member="avro::ValidatingWriter" ref="a86c844697fdbee2981c59c5c32acd054" args="" -->
typedef <a class="el" href="classavro_1_1WriterImpl.html">WriterImpl</a>&lt; <a class="el" href="classavro_1_1Validator.html">Validator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidatingWriter</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">SchemaResolution</a> { <br/>
&#160;&#160;<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175">RESOLVE_NO_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d">RESOLVE_MATCH</a>, 
<a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74">RESOLVE_PROMOTABLE_TO_LONG</a>, 
<b>RESOLVE_PROMOTABLE_TO_FLOAT</b>, 
<br/>
&#160;&#160;<b>RESOLVE_PROMOTABLE_TO_DOUBLE</b>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> { <br/>
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09">AVRO_BYTES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3">AVRO_INT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340">AVRO_LONG</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8">AVRO_FLOAT</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800">AVRO_DOUBLE</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2">AVRO_BOOL</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff">AVRO_NULL</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597">AVRO_ENUM</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb">AVRO_ARRAY</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c">AVRO_MAP</a>, 
<br/>
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9">AVRO_UNION</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7">AVRO_FIXED</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, 
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129">AVRO_SYMBOLIC</a> =  AVRO_NUM_TYPES, 
<br/>
&#160;&#160;<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c">AVRO_UNKNOWN</a> =  -1
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The "type" for the schema.  <a href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main parse entry point function.  <a href="#a0180913cf37820fd8c10a35af371945c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a71d3c0e0c943565a98085d3e2d195196"></a><!-- doxytag: member="avro::parse" ref="a71d3c0e0c943565a98085d3e2d195196" args="(ResolvingReader &amp;p, T &amp;val)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a576812f2f2731e4e6569df149a6c4a54"></a><!-- doxytag: member="avro::translatingParse" ref="a576812f2f2731e4e6569df149a6c4a54" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a274e8f2e3a165ff45bf932a82127fc78">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main serializer entry point function.  <a href="#a274e8f2e3a165ff45bf932a82127fc78"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a5e711b20e43db4ee5051375680f2d5fb"></a><!-- doxytag: member="avro::serialize" ref="a5e711b20e43db4ee5051375680f2d5fb" args="(Writer &amp;s, const T &amp;val, const boost::false_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a5e711b20e43db4ee5051375680f2d5fb">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object.  <a href="#a31c14823127aff747cc83e6714de9e31"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a23cb7c42622aad8310cffa013c022d14">compileJsonSchema</a> (std::istream &amp;is, <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, std::string &amp;error)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-throwing version of compileJsonSchema.  <a href="#a23cb7c42622aad8310cffa013c022d14"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1694b4608e27e3a3f82c41f943fc4be"></a><!-- doxytag: member="avro::compileJsonSchemaFromStream" ref="ae1694b4608e27e3a3f82c41f943fc4be" args="(InputStream &amp;is)" -->
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromStream</b> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;is)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fa891ce6908de70fac5b1a55d44b87c"></a><!-- doxytag: member="avro::compileJsonSchemaFromMemory" ref="a7fa891ce6908de70fac5b1a55d44b87c" args="(const uint8_t *input, size_t len)" -->
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromMemory</b> (const uint8_t *input, size_t len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b87e7e48b22ec268d67728c14db75c1"></a><!-- doxytag: member="avro::compileJsonSchemaFromString" ref="a0b87e7e48b22ec268d67728c14db75c1" args="(const char *input)" -->
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const char *input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a100a903ab9c073eebe525f106862fdd7"></a><!-- doxytag: member="avro::compileJsonSchemaFromString" ref="a100a903ab9c073eebe525f106862fdd7" args="(const std::string &amp;input)" -->
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromString</b> (const std::string &amp;input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac392c82f4e10896af45f64168590a3bc"></a><!-- doxytag: member="avro::compileJsonSchemaFromFile" ref="ac392c82f4e10896af45f64168590a3bc" args="(const char *filename)" -->
AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compileJsonSchemaFromFile</b> (const char *filename)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f78e53cb84a0189b626e6a5726b148"></a><!-- doxytag: member="avro::binaryDecoder" ref="a04f78e53cb84a0189b626e6a5726b148" args="()" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a04f78e53cb84a0189b626e6a5726b148">binaryDecoder</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode binary Avro standard. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9408498d77f42a536074433cc541d8ae"></a><!-- doxytag: member="avro::validatingDecoder" ref="a9408498d77f42a536074433cc541d8ae" args="(const ValidSchema &amp;schema, const DecoderPtr &amp;base)" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9408498d77f42a536074433cc541d8ae">validatingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a> &amp;base)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Decoder.html" title="Decoder is an interface implemented by every decoder capable of decoding Avro data.">Decoder</a> against the given schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac8a9c93b0621227de3dcca383e36ff"></a><!-- doxytag: member="avro::jsonDecoder" ref="a7ac8a9c93b0621227de3dcca383e36ff" args="(const ValidSchema &amp;schema)" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a7ac8a9c93b0621227de3dcca383e36ff">jsonDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an decoder that can decode Avro standard for JSON. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL <a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">resolvingDecoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;writer, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;reader, const <a class="el" href="namespaceavro.html#a409dd1e501d982d3828c65ddf69b68b7">DecoderPtr</a> &amp;base)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema.  <a href="#aeef8b583abe36b25a8d2094d7a3d4b96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0158bd2fc76615b68db68d7e4f7c4f6"></a><!-- doxytag: member="avro::binaryEncoder" ref="ad0158bd2fc76615b68db68d7e4f7c4f6" args="()" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad0158bd2fc76615b68db68d7e4f7c4f6">binaryEncoder</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that can encode binary Avro standard. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ba750d980390623baeae24bc24b286e"></a><!-- doxytag: member="avro::validatingEncoder" ref="a1ba750d980390623baeae24bc24b286e" args="(const ValidSchema &amp;schema, const EncoderPtr &amp;base)" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a1ba750d980390623baeae24bc24b286e">validatingEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema, const <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a> &amp;base)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that validates sequence of calls to an underlying <a class="el" href="classavro_1_1Encoder.html" title="The abstract base class for all Avro encoders.">Encoder</a> against the given schema. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0847ef62f42f6f0d0af28da9f7c7cf15"></a><!-- doxytag: member="avro::jsonEncoder" ref="a0847ef62f42f6f0d0af28da9f7c7cf15" args="(const ValidSchema &amp;schema)" -->
AVRO_DECL <a class="el" href="namespaceavro.html#a74279cf96c71ffd8f18d005c32ab8073">EncoderPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0847ef62f42f6f0d0af28da9f7c7cf15">jsonEncoder</a> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;schema)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an encoder that can encode Avro standard for JSON. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a793048d50960fa83ada15d4c5b9c58b7"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a793048d50960fa83ada15d4c5b9c58b7" args="(std::ostream &amp;os, const Name &amp;n)" -->
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classavro_1_1Name.html">Name</a> &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb0c98243cbfe723262a61c747e858b"></a><!-- doxytag: member="avro::resolveSymbol" ref="a1fb0c98243cbfe723262a61c747e858b" args="(const NodePtr &amp;node)" -->
NodePtr&#160;</td><td class="memItemRight" valign="bottom"><b>resolveSymbol</b> (const NodePtr &amp;node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58cb2d5a007fb9634a3878af7b32c398"></a><!-- doxytag: member="avro::nextType" ref="a58cb2d5a007fb9634a3878af7b32c398" args="(Parser&lt; ValidatingReader &gt; &amp;p)" -->
<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>nextType</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95e8d0ef60e0b85451fccf401289492f"></a><!-- doxytag: member="avro::currentRecordName" ref="a95e8d0ef60e0b85451fccf401289492f" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>currentRecordName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f9441b454deb1dec9dfa6eebca935b"></a><!-- doxytag: member="avro::nextFieldName" ref="a01f9441b454deb1dec9dfa6eebca935b" args="(Parser&lt; ValidatingReader &gt; &amp;p, std::string &amp;name)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>nextFieldName</b> (<a class="el" href="classavro_1_1Parser.html">Parser</a>&lt; <a class="el" href="classavro_1_1ReaderImpl.html">ValidatingReader</a> &gt; &amp;p, std::string &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab21938e7ba64b1704e3233852846dfcf"></a><!-- doxytag: member="avro::constructResolver" ref="ab21938e7ba64b1704e3233852846dfcf" args="(const ValidSchema &amp;rwriterSchema, const ValidSchema &amp;readerSchema, const Layout &amp;readerLayout)" -->
<a class="el" href="classavro_1_1Resolver.html">Resolver</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>constructResolver</b> (const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;rwriterSchema, const <a class="el" href="classavro_1_1ValidSchema.html">ValidSchema</a> &amp;readerSchema, const <a class="el" href="classavro_1_1Layout.html">Layout</a> &amp;readerLayout)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a068734327d24a1e80caeee07b70b367f"></a><!-- doxytag: member="avro::encode" ref="a068734327d24a1e80caeee07b70b367f" args="(Encoder &amp;e, const T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a068734327d24a1e80caeee07b70b367f">encode</a> (<a class="el" href="classavro_1_1Encoder.html">Encoder</a> &amp;e, const T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic encoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a>. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a9893c6f7b0f264029261056da57fbd2d"></a><!-- doxytag: member="avro::decode" ref="a9893c6f7b0f264029261056da57fbd2d" args="(Decoder &amp;d, T &amp;t)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a9893c6f7b0f264029261056da57fbd2d">decode</a> (<a class="el" href="classavro_1_1Decoder.html">Decoder</a> &amp;d, T &amp;t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic decoder function that makes use of the <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">codec_traits</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a17924697cd3e7fed6b15e16f60bba607"></a><!-- doxytag: member="avro::memoryOutputStream" ref="a17924697cd3e7fed6b15e16f60bba607" args="(size_t chunkSize=4 *1024)" -->
AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607">memoryOutputStream</a> (size_t chunkSize=4 *1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>, which grows in memory chunks of specified size. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6">memoryInputStream</a> (const uint8_t *data, size_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>, with the data from the given byte array.  <a href="#a383a86da8c86de91708d6865293f10f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a0ccce9f2136f59050dd9b866130fb052">memoryInputStream</a> (const <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;source)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> with the contents written into an outputstream.  <a href="#a0ccce9f2136f59050dd9b866130fb052"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a49f045f7aa22d1b628aa0fec12f82332">fileOutputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents would be stored in a file.  <a href="#a49f045f7aa22d1b628aa0fec12f82332"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ad65fd382f9f5f4b90b580861bf2f7f0c">fileInputStream</a> (const char *filename, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given file.  <a href="#ad65fd382f9f5f4b90b580861bf2f7f0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#aa81fb803530d3b67946a48ec6ea9faf6">ostreamOutputStream</a> (std::ostream &amp;os, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents will be sent to the given std::ostream.  <a href="#aa81fb803530d3b67946a48ec6ea9faf6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL std::auto_ptr<br class="typebreak"/>
&lt; <a class="el" href="classavro_1_1InputStream.html">InputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a6ace2f37da00282385a25d29900f6fb7">istreamInputStream</a> (std::istream &amp;in, size_t bufferSize=8 *1024)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream.  <a href="#a6ace2f37da00282385a25d29900f6fb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeab3d9f5f2a4a4f96d3ffb8ba27e523"></a><!-- doxytag: member="avro::copy" ref="adeab3d9f5f2a4a4f96d3ffb8ba27e523" args="(InputStream &amp;in, OutputStream &amp;out)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#adeab3d9f5f2a4a4f96d3ffb8ba27e523">copy</a> (<a class="el" href="classavro_1_1InputStream.html">InputStream</a> &amp;in, <a class="el" href="classavro_1_1OutputStream.html">OutputStream</a> &amp;out)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function to copy all the contents of an input stream into an output stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a83ca7f599d09b940bd236e77aa508381">isPrimitive</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a primitive.  <a href="#a83ca7f599d09b940bd236e77aa508381"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a183aa500a8985117239abdc5922d8602">isCompound</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a non primitive valid type.  <a href="#a183aa500a8985117239abdc5922d8602"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e596e801aaf532e26895ad9d7bfcdb1"></a><!-- doxytag: member="avro::isAvroType" ref="a5e596e801aaf532e26895ad9d7bfcdb1" args="(Type t)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a5e596e801aaf532e26895ad9d7bfcdb1">isAvroType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is a valid avro type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae66c7c7a5f5cdbacf66009aa4a8079ef"></a><!-- doxytag: member="avro::isAvroTypeOrPseudoType" ref="ae66c7c7a5f5cdbacf66009aa4a8079ef" args="(Type t)" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ae66c7c7a5f5cdbacf66009aa4a8079ef">isAvroTypeOrPseudoType</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> t)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if and only if the given type is within the valid range of enumeration. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">AVRO_DECL const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#abb20ffcc3629ced067077fc4ab82653a">toString</a> (<a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the given type into a string.  <a href="#abb20ffcc3629ced067077fc4ab82653a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac820da0b6f2cbab9f887f0663f1f2801"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="ac820da0b6f2cbab9f887f0663f1f2801" args="(std::ostream &amp;os, avro::Type type)" -->
AVRO_DECL std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#ac820da0b6f2cbab9f887f0663f1f2801">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a> type)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a string form of the given type into the given ostream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4ab8b3abddb0a14d47cbe76214488d7b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structavro_1_1Null.html">Null</a> &amp;null)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes schema for null <code>null</code> type to <code>os</code>.  <a href="#a4ab8b3abddb0a14d47cbe76214488d7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e8b5609576bc00f398f30363ed2a986"></a><!-- doxytag: member="avro::encodeZigzag64" ref="a9e8b5609576bc00f398f30363ed2a986" args="(int64_t input)" -->
AVRO_DECL uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag64</b> (int64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e909a789ac2b2fbe8b416c90d39fb99"></a><!-- doxytag: member="avro::decodeZigzag64" ref="a1e909a789ac2b2fbe8b416c90d39fb99" args="(uint64_t input)" -->
AVRO_DECL int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag64</b> (uint64_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0553f3f786db4254c3518387d1575b0e"></a><!-- doxytag: member="avro::encodeZigzag32" ref="a0553f3f786db4254c3518387d1575b0e" args="(int32_t input)" -->
AVRO_DECL uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeZigzag32</b> (int32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf774f56a1909853388449ce639dc591"></a><!-- doxytag: member="avro::decodeZigzag32" ref="acf774f56a1909853388449ce639dc591" args="(uint32_t input)" -->
AVRO_DECL int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>decodeZigzag32</b> (uint32_t input)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf3c29b569928eace8b617d4cff845ce"></a><!-- doxytag: member="avro::encodeInt32" ref="aaf3c29b569928eace8b617d4cff845ce" args="(int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)" -->
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt32</b> (int32_t input, boost::array&lt; uint8_t, 5 &gt; &amp;output)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54564bbdb2ead318181a3c04fde7d0da"></a><!-- doxytag: member="avro::encodeInt64" ref="a54564bbdb2ead318181a3c04fde7d0da" args="(int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)" -->
AVRO_DECL size_t&#160;</td><td class="memItemRight" valign="bottom"><b>encodeInt64</b> (int64_t input, boost::array&lt; uint8_t, 10 &gt; &amp;output)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename Reader , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a4d738c814577420a7f84377be6912555">parse</a> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain.  <a href="#a4d738c814577420a7f84377be6912555"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a7737443ffaa03bbb901299bcdaacace0"></a><!-- doxytag: member="avro::parse" ref="a7737443ffaa03bbb901299bcdaacace0" args="(Reader &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Reader &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parse</b> (<a class="el" href="classavro_1_1ReaderImpl.html">Reader</a> &amp;p, std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="acd0b554d35352db4cc84814c0d03f8a1"></a><!-- doxytag: member="avro::translatingParse" ref="acd0b554d35352db4cc84814c0d03f8a1" args="(ResolvingReader &amp;p, T &amp;val, const boost::true_type &amp;)" -->
template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>translatingParse</b> (<a class="el" href="classavro_1_1ResolvingReader.html">ResolvingReader</a> &amp;p, T &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a3a93ede267b00ea138e35ac681724705"></a><!-- doxytag: member="avro::serialize" ref="a3a93ede267b00ea138e35ac681724705" args="(Writer &amp;s, T val, const boost::true_type &amp;)" -->
template&lt;typename Writer , typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceavro.html#a3a93ede267b00ea138e35ac681724705">serialize</a> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, T val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The remainder of the file includes default implementations for serializable types. <br/></td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="a10bd31869f16892b2ce5e15b4b87388d"></a><!-- doxytag: member="avro::serialize" ref="a10bd31869f16892b2ce5e15b4b87388d" args="(Writer &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const boost::true_type &amp;)" -->
template&lt;typename Writer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classavro_1_1WriterImpl.html">Writer</a> &amp;s, const std::vector&lt; uint8_t &gt; &amp;val, const <a class="el" href="structboost_1_1integral__constant.html">boost::true_type</a> &amp;)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47c9d8f1ab53aaf6cedb7f344d241ec5"></a><!-- doxytag: member="avro::InputStream" ref="a47c9d8f1ab53aaf6cedb7f344d241ec5" args="" -->
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>InputStream</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceavro.html#afac45d280b253381efc5f489b86c641f">ValidSchema</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to implement an avro spec parser using a flex/bison compiler.  <a href="#afac45d280b253381efc5f489b86c641f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69535672c36b355e52a501291bb3a1a2"></a><!-- doxytag: member="avro::Schema" ref="a69535672c36b355e52a501291bb3a1a2" args="" -->
class AVRO_DECL&#160;</td><td class="memItemRight" valign="bottom"><b>Schema</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A bunch of templates and specializations for encoding and decoding specific types. </p>
<p>Primitive AVRO types BOOLEAN, INT, LONG, FLOAT, DOUBLE, STRING and BYTES get decoded to and encoded from C++ types bool, int32_t, int64_t, float, double, std::string and std::vector&lt;uint8_t&gt; respectively. In addition, std::vector&lt;T&gt; for aribtrary type T gets encoded as an Avro array of T. Similarly, std::map&lt;std::string, T&gt; for arbitrary type T gets encoded as an Avro map with value type T.</p>
<p>Users can have their custom types encoded/decoded by specializing <a class="el" href="structavro_1_1codec__traits.html" title="Codec_traits tells avro how to encode and decode an object of given type.">avro::codec_traits</a> class for their types. </p>
</div><hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ad17da92a723dce9b89e7c845749615b3"></a><!-- doxytag: member="avro::SchemaResolution" ref="ad17da92a723dce9b89e7c845749615b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#ad17da92a723dce9b89e7c845749615b3">avro::SchemaResolution</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175"></a><!-- doxytag: member="RESOLVE_NO_MATCH" ref="ad17da92a723dce9b89e7c845749615b3a86f5b5067a89554ec0750cc077049175" args="" -->RESOLVE_NO_MATCH</em>&nbsp;</td><td>
<p>The schemas definitely do not match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d"></a><!-- doxytag: member="RESOLVE_MATCH" ref="ad17da92a723dce9b89e7c845749615b3ad0049d58769053c630bdb7318249a94d" args="" -->RESOLVE_MATCH</em>&nbsp;</td><td>
<p>The schemas match at a cursory level. </p>
<p>For records and enums, this means the name is the same, but it does not necessarily mean that every symbol or field is an exact match. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74"></a><!-- doxytag: member="RESOLVE_PROMOTABLE_TO_LONG" ref="ad17da92a723dce9b89e7c845749615b3a34b74d42b07300bec077eb686a8d4b74" args="" -->RESOLVE_PROMOTABLE_TO_LONG</em>&nbsp;</td><td>
<p>For primitives, the matching may occur if the type is promotable. </p>
<p>This means that the writer matches reader if the writer's type is promoted the specified type. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7"></a><!-- doxytag: member="avro::Type" ref="a29e528c3fe1cb5660067a02721fae0b7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7">avro::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The "type" for the schema. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f"></a><!-- doxytag: member="AVRO_STRING" ref="a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f" args="" -->AVRO_STRING</em>&nbsp;</td><td>
<p>String </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09"></a><!-- doxytag: member="AVRO_BYTES" ref="a29e528c3fe1cb5660067a02721fae0b7aa5ff10208f8bf3952647c48c1f67ca09" args="" -->AVRO_BYTES</em>&nbsp;</td><td>
<p>Sequence of variable length bytes data </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3"></a><!-- doxytag: member="AVRO_INT" ref="a29e528c3fe1cb5660067a02721fae0b7a53f57f125161dc143d955e0eecafd7a3" args="" -->AVRO_INT</em>&nbsp;</td><td>
<p>32-bit integer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340"></a><!-- doxytag: member="AVRO_LONG" ref="a29e528c3fe1cb5660067a02721fae0b7a692a9ce3245cea9dcbc10ee73b8c6340" args="" -->AVRO_LONG</em>&nbsp;</td><td>
<p>64-bit integer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8"></a><!-- doxytag: member="AVRO_FLOAT" ref="a29e528c3fe1cb5660067a02721fae0b7a49eb3fcb0154b63104c8041e07ef02b8" args="" -->AVRO_FLOAT</em>&nbsp;</td><td>
<p>Floating point number </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800"></a><!-- doxytag: member="AVRO_DOUBLE" ref="a29e528c3fe1cb5660067a02721fae0b7a6d280a38797d72263c8b1c83f981b800" args="" -->AVRO_DOUBLE</em>&nbsp;</td><td>
<p>Double precision floating point number </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2"></a><!-- doxytag: member="AVRO_BOOL" ref="a29e528c3fe1cb5660067a02721fae0b7a8fbd33da2d41bf10e877dabac5af5dd2" args="" -->AVRO_BOOL</em>&nbsp;</td><td>
<p>Boolean value </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff"></a><!-- doxytag: member="AVRO_NULL" ref="a29e528c3fe1cb5660067a02721fae0b7ae6058ac1a8cd7ab916450d8616c40cff" args="" -->AVRO_NULL</em>&nbsp;</td><td>
<p><a class="el" href="structavro_1_1Null.html" title="define a type to identify Null in template functions">Null</a> </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3"></a><!-- doxytag: member="AVRO_RECORD" ref="a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3" args="" -->AVRO_RECORD</em>&nbsp;</td><td>
<p>Record, a sequence of fields </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597"></a><!-- doxytag: member="AVRO_ENUM" ref="a29e528c3fe1cb5660067a02721fae0b7a9154a0e620b5b68d6342967cd5c35597" args="" -->AVRO_ENUM</em>&nbsp;</td><td>
<p>Enumeration </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb"></a><!-- doxytag: member="AVRO_ARRAY" ref="a29e528c3fe1cb5660067a02721fae0b7ad79083497fa17d6fe8d83416c06601eb" args="" -->AVRO_ARRAY</em>&nbsp;</td><td>
<p>Homogeneous array of some specific type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c"></a><!-- doxytag: member="AVRO_MAP" ref="a29e528c3fe1cb5660067a02721fae0b7a44369402b245cfed83f5ae543a84de2c" args="" -->AVRO_MAP</em>&nbsp;</td><td>
<p>Homogeneous map from string to some specific type </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9"></a><!-- doxytag: member="AVRO_UNION" ref="a29e528c3fe1cb5660067a02721fae0b7a83c5aa9e51fda5279e0e5cee0eba02d9" args="" -->AVRO_UNION</em>&nbsp;</td><td>
<p>Union of one or more types </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7"></a><!-- doxytag: member="AVRO_FIXED" ref="a29e528c3fe1cb5660067a02721fae0b7aff4ee863b4a5df4f182a2a86402417e7" args="" -->AVRO_FIXED</em>&nbsp;</td><td>
<p>Fixed number of bytes </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d"></a><!-- doxytag: member="AVRO_NUM_TYPES" ref="a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d" args="" -->AVRO_NUM_TYPES</em>&nbsp;</td><td>
<p>Marker </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129"></a><!-- doxytag: member="AVRO_SYMBOLIC" ref="a29e528c3fe1cb5660067a02721fae0b7acfdf8d57cc8f759934fe19a3a31ee129" args="" -->AVRO_SYMBOLIC</em>&nbsp;</td><td>
<p>User internally to avoid circular references. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c"></a><!-- doxytag: member="AVRO_UNKNOWN" ref="a29e528c3fe1cb5660067a02721fae0b7ae3b06dcbfa25fabecc2bb036e870b46c" args="" -->AVRO_UNKNOWN</em>&nbsp;</td><td>
<p>Used internally. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a31c14823127aff747cc83e6714de9e31"></a><!-- doxytag: member="avro::compileJsonSchema" ref="a31c14823127aff747cc83e6714de9e31" args="(std::istream &amp;is, ValidSchema &amp;schema)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL void <a class="el" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>schema</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Given a stream comtaining a JSON schema, compiles the schema to a <a class="el" href="classavro_1_1ValidSchema.html" title="A ValidSchema is basically a non-mutable Schema that has passed some minumum of sanity checks...">ValidSchema</a> object. </p>
<p>Throws if the schema cannot be compiled to a valid schema </p>

</div>
</div>
<a class="anchor" id="a23cb7c42622aad8310cffa013c022d14"></a><!-- doxytag: member="avro::compileJsonSchema" ref="a23cb7c42622aad8310cffa013c022d14" args="(std::istream &amp;is, ValidSchema &amp;schema, std::string &amp;error)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL bool <a class="el" href="namespaceavro.html#a31c14823127aff747cc83e6714de9e31">avro::compileJsonSchema</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Non-throwing version of compileJsonSchema. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if no error, false if error (with the error string set) </dd></dl>

</div>
</div>
<a class="anchor" id="ad65fd382f9f5f4b90b580861bf2f7f0c"></a><!-- doxytag: member="avro::fileInputStream" ref="ad65fd382f9f5f4b90b580861bf2f7f0c" args="(const char *filename, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; <a class="el" href="namespaceavro.html#ad65fd382f9f5f4b90b580861bf2f7f0c">avro::fileInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given file. </p>
<p>Data is read in chunks of given buffer size. </p>

</div>
</div>
<a class="anchor" id="a49f045f7aa22d1b628aa0fec12f82332"></a><!-- doxytag: member="avro::fileOutputStream" ref="a49f045f7aa22d1b628aa0fec12f82332" args="(const char *filename, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>&gt; <a class="el" href="namespaceavro.html#a49f045f7aa22d1b628aa0fec12f82332">avro::fileOutputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents would be stored in a file. </p>
<p>Data is written in chunks of given buffer size.</p>
<p>If there is a file with the given name, it is truncated and overwritten. If there is no file with the given name, it is created. </p>

</div>
</div>
<a class="anchor" id="a183aa500a8985117239abdc5922d8602"></a><!-- doxytag: member="avro::isCompound" ref="a183aa500a8985117239abdc5922d8602" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceavro.html#a183aa500a8985117239abdc5922d8602">avro::isCompound</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if and only if the given type is a non primitive valid type. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p>References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a091926107dab9cc29dff31c8e4eee47d">AVRO_NUM_TYPES</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>.</p>

</div>
</div>
<a class="anchor" id="a83ca7f599d09b940bd236e77aa508381"></a><!-- doxytag: member="avro::isPrimitive" ref="a83ca7f599d09b940bd236e77aa508381" args="(Type t)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespaceavro.html#a83ca7f599d09b940bd236e77aa508381">avro::isPrimitive</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if and only if the given type is a primitive. </p>
<p>Primitive types are: string, bytes, int, long, float, double, boolean and null </p>

<p>References <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a56769d2bfc0a8c97c14a5d249fa9ade3">AVRO_RECORD</a>, and <a class="el" href="namespaceavro.html#a29e528c3fe1cb5660067a02721fae0b7a653cfbb5f5aca522271b435e7215087f">AVRO_STRING</a>.</p>

</div>
</div>
<a class="anchor" id="a6ace2f37da00282385a25d29900f6fb7"></a><!-- doxytag: member="avro::istreamInputStream" ref="a6ace2f37da00282385a25d29900f6fb7" args="(std::istream &amp;in, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; <a class="el" href="namespaceavro.html#a6ace2f37da00282385a25d29900f6fb7">avro::istreamInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> whose contents come from the given std::istream. </p>
<p>The std::istream object should outlive the returned <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>. </p>

</div>
</div>
<a class="anchor" id="a383a86da8c86de91708d6865293f10f6"></a><!-- doxytag: member="avro::memoryInputStream" ref="a383a86da8c86de91708d6865293f10f6" args="(const uint8_t *data, size_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; <a class="el" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6">avro::memoryInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a>, with the data from the given byte array. </p>
<p>It does not copy the data, the byte array should remain valid until the <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> is used. </p>

</div>
</div>
<a class="anchor" id="a0ccce9f2136f59050dd9b866130fb052"></a><!-- doxytag: member="avro::memoryInputStream" ref="a0ccce9f2136f59050dd9b866130fb052" args="(const OutputStream &amp;source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1InputStream.html">InputStream</a>&gt; <a class="el" href="namespaceavro.html#a383a86da8c86de91708d6865293f10f6">avro::memoryInputStream</a> </td>
          <td>(</td>
          <td class="paramtype">const OutputStream &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1InputStream.html" title="A no-copy input stream.">InputStream</a> with the contents written into an outputstream. </p>
<p>The output stream must have been returned by an earlier call to <a class="el" href="namespaceavro.html#a17924697cd3e7fed6b15e16f60bba607" title="Returns a new OutputStream, which grows in memory chunks of specified size.">memoryOutputStream()</a>. The contents for the new input stream are the snapshot of the outputstream. One can construct any number of memory input stream from a single memory output stream. </p>

</div>
</div>
<a class="anchor" id="a4ab8b3abddb0a14d47cbe76214488d7b"></a><!-- doxytag: member="avro::operator&lt;&lt;" ref="a4ab8b3abddb0a14d47cbe76214488d7b" args="(std::ostream &amp;os, const Null &amp;null)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; avro::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Null &amp;&#160;</td>
          <td class="paramname"><em>null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes schema for null <code>null</code> type to <code>os</code>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>The ostream to write to. </td></tr>
    <tr><td class="paramname">null</td><td>The value to be written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa81fb803530d3b67946a48ec6ea9faf6"></a><!-- doxytag: member="avro::ostreamOutputStream" ref="aa81fb803530d3b67946a48ec6ea9faf6" args="(std::ostream &amp;os, size_t bufferSize=8 *1024)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL std::auto_ptr&lt;<a class="el" href="classavro_1_1OutputStream.html">OutputStream</a>&gt; <a class="el" href="namespaceavro.html#aa81fb803530d3b67946a48ec6ea9faf6">avro::ostreamOutputStream</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em> = <code>8&#160;*1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a new <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a> whose contents will be sent to the given std::ostream. </p>
<p>The std::ostream object should outlive the returned <a class="el" href="classavro_1_1OutputStream.html" title="A no-copy output stream.">OutputStream</a>. </p>

</div>
</div>
<a class="anchor" id="a0180913cf37820fd8c10a35af371945c"></a><!-- doxytag: member="avro::parse" ref="a0180913cf37820fd8c10a35af371945c" args="(Reader &amp;p, T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">avro::parse</a> </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main parse entry point function. </p>
<p>Takes a parser (either validating or plain) and the object that should receive the parsed data. </p>

</div>
</div>
<a class="anchor" id="a4d738c814577420a7f84377be6912555"></a><!-- doxytag: member="avro::parse" ref="a4d738c814577420a7f84377be6912555" args="(Reader &amp;p, T &amp;val, const boost::false_type &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Reader , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceavro.html#a0180913cf37820fd8c10a35af371945c">avro::parse</a> </td>
          <td>(</td>
          <td class="paramtype">Reader &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structboost_1_1integral__constant.html">boost::false_type</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Type trait should be set to <a class="el" href="structavro_1_1is__serializable.html">is_serializable</a> in otherwise force the compiler to complain. </p>
<p>The remainder of the file includes default implementations for serializable types. </p>

</div>
</div>
<a class="anchor" id="aeef8b583abe36b25a8d2094d7a3d4b96"></a><!-- doxytag: member="avro::resolvingDecoder" ref="aeef8b583abe36b25a8d2094d7a3d4b96" args="(const ValidSchema &amp;writer, const ValidSchema &amp;reader, const DecoderPtr &amp;base)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL <a class="el" href="namespaceavro.html#ac16ed8c1d8bb7c68f40d2cd753a0a1b7">ResolvingDecoderPtr</a> <a class="el" href="namespaceavro.html#aeef8b583abe36b25a8d2094d7a3d4b96">avro::resolvingDecoder</a> </td>
          <td>(</td>
          <td class="paramtype">const ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValidSchema &amp;&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DecoderPtr &amp;&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a decoder that decodes avro data from base written according to writerSchema and resolves against readerSchema. </p>
<p>The client uses the decoder as if the data were written using readerSchema. // FIXME: Handle out of order fields. </p>

</div>
</div>
<a class="anchor" id="a274e8f2e3a165ff45bf932a82127fc78"></a><!-- doxytag: member="avro::serialize" ref="a274e8f2e3a165ff45bf932a82127fc78" args="(Writer &amp;s, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceavro.html#a274e8f2e3a165ff45bf932a82127fc78">avro::serialize</a> </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The main serializer entry point function. </p>
<p>Takes a serializer (either validating or plain) and the object that should be serialized. </p>

</div>
</div>
<a class="anchor" id="abb20ffcc3629ced067077fc4ab82653a"></a><!-- doxytag: member="avro::toString" ref="abb20ffcc3629ced067077fc4ab82653a" args="(Type type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AVRO_DECL const std::string&amp; <a class="el" href="namespaceavro.html#abb20ffcc3629ced067077fc4ab82653a">avro::toString</a> </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts the given type into a string. </p>
<p>Useful for generating messages. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="afac45d280b253381efc5f489b86c641f"></a><!-- doxytag: member="avro::ValidSchema" ref="afac45d280b253381efc5f489b86c641f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class AVRO_DECL <a class="el" href="classavro_1_1ValidSchema.html">avro::ValidSchema</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This class is used to implement an avro spec parser using a flex/bison compiler. </p>
<p>In order for the lexer to be reentrant, this class provides a lexer object for each parse. The bison parser also uses this class to build up an avro parse tree as the avro spec is parsed. </p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Thu Feb 21 2013 13:22:27 for Avro C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
